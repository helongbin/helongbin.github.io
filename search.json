[{"title":"BOM","url":"http://yoursite.com/2017/09/12/BOM/","content":"<h1 id=\"window\"><a href=\"#window\" class=\"headerlink\" title=\"window\"></a>window</h1><p>页面中如果有多个iframe，那么浏览器会为每个iframe分别创建一个window对象</p>\n<h2 id=\"常用属性\"><a href=\"#常用属性\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h2><ul>\n<li>name：读取/设置当前窗口的名称</li>\n<li>self：指代当前窗口本，slef===window</li>\n<li>parent：当前窗口的父窗口，在iframe中用的很多</li>\n<li>top：指代当前窗口的最顶级父窗口，在iframe中用的很多</li>\n<li>opener：指代创建当前窗口窗口的引用</li>\n<li>innerHeight/innerWidth：number类型，浏览器显示区域的宽高</li>\n<li>outerHeigth/outerWidth：number，浏览器外层窗口的宽高</li>\n</ul>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><p><strong>与窗口有关的window对象的方法</strong></p>\n<ol>\n<li>close()：关闭窗口，有些浏览器默认禁用</li>\n<li>open(‘ur’l,[name],[features])：window.open()打开窗口<br>设置参数为’_self’：当前窗口打开<br>‘_blank’：打开空白页面<br>‘_parent’：在父窗口中打开<br>‘_top’：在顶层窗口中打开<br>第三个参数为特性：left，top，width，height，是否显示菜单状态地址栏等。。。</li>\n<li>window.focus()：申请获取焦点</li>\n<li>window.blur()：失去焦点</li>\n<li>window.alert()：警告框</li>\n<li>window.prompt()：输入框</li>\n<li>window.confirm()：确认框</li>\n</ol>\n<p><strong>与定时器有关的window对象的方法</strong></p>\n<ul>\n<li>window.setInterval(exp,time)，返回已经启动的周期性定时器对象</li>\n<li>window.clearInterval(tID)</li>\n<li>window.setTimeout(exp,time)</li>\n<li>window.clearTimeout(tID)</li>\n</ul>\n<h1 id=\"document\"><a href=\"#document\" class=\"headerlink\" title=\"document\"></a>document</h1><h1 id=\"navigator\"><a href=\"#navigator\" class=\"headerlink\" title=\"navigator\"></a>navigator</h1><p>指代当前的浏览器，可用于获取当前客户端浏览器和操作系统信息<br>常用属性：</p>\n<ul>\n<li>navigator.cookieEnabled：布尔类型，true或false，表示当前浏览器是否启用了cookie功能</li>\n<li>navigator.userAgent：string类型，UA，此属性可以反映出当前客户端浏览器的类型</li>\n</ul>\n<p>常见浏览器的UserAgent值：使用正则表达式区分各个浏览器</p>\n<table>\n<thead>\n<tr>\n<th>Chrome</th>\n<th>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.99 Safari/537.36</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Firefox</td>\n<td>Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0</td>\n</tr>\n<tr>\n<td>saFari</td>\n<td>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2</td>\n</tr>\n<tr>\n<td>IE</td>\n<td>Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; rv:11.0) like Gecko</td>\n</tr>\n<tr>\n<td>Opera</td>\n<td>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h1><p>包含着当前显示的页面的地址信息</p>\n<h2 id=\"常用属性-1\"><a href=\"#常用属性-1\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h2><ul>\n<li>location.href:String类型，读取/设置页面的URL地址；<br>当给location.href赋值时，也可以实现页面跳转</li>\n</ul>\n<h2 id=\"常用方法-1\"><a href=\"#常用方法-1\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><ul>\n<li>location.assign(url)：跳转至新的url（原来的url会产生历史记录）</li>\n<li>location.reload()：重新加载，即刷新当前页面</li>\n<li>location.replace(url)：替换当前的url（原来的url不会产生历史记录）</li>\n<li>location.search()：返回url中从问号至url末尾的全部内容，可以使用正则表达式匹配，然后解码提取字符串</li>\n</ul>\n<h1 id=\"screen\"><a href=\"#screen\" class=\"headerlink\" title=\"screen\"></a>screen</h1><p>表示当前浏览器所在的屏幕（PC，Pad，phone）</p>\n<h2 id=\"常用属性-2\"><a href=\"#常用属性-2\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h2><ul>\n<li>screen.colorDepth:number类型，返回当前显示器颜色的位深</li>\n<li>screen.availHeight:显示器分辨率可用高度（浏览器任务栏窗口除外）</li>\n<li><p>screen.availWidth:显示器分辨率可用宽度（浏览器任务栏窗口除外）<br>与window.innerWidth不同，后者表示窗口的可用宽度</p>\n</li>\n<li><p>screen.height:屏幕分辨率的高</p>\n</li>\n<li>screen.width:屏幕分辨率的宽</li>\n</ul>\n<h1 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h1><p>记录着当前浏览器窗口的URL访问历史</p>\n<h2 id=\"常用属性-3\"><a href=\"#常用属性-3\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h2><p>history.length:返回当前浏览器窗口历史列表的URL数量</p>\n<h2 id=\"常用方法-2\"><a href=\"#常用方法-2\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><ul>\n<li>history.back()：后退</li>\n<li>history.forward()：前进</li>\n<li>history.go(n)：n若为正，那么前进n步，n为负，那么后退n步</li>\n</ul>\n<h1 id=\"event\"><a href=\"#event\" class=\"headerlink\" title=\"event\"></a>event</h1><p>页面中每当发生某种状况时，浏览器就会自动创建一个Event对象，一个页面可能创建多个Event对象<br>Event Handler或Event Listener，指用于监听并处理事件的函</p>\n<h2 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h2><p><strong>事件不能绑定在未存在（或暂时未创建）的元素上，所以为动态创建后的元素绑定事件，必须先创建后绑定</strong></p>\n<ol>\n<li>直接在HTML中声明事件处理代码<br><code>&lt;a onclick=’alert(123);alert(234)’&gt;</code><br>此方法把JS混在HTML中，把网页的行为混在内容中，不推荐使用（行为与内容分离原则）            </li>\n<li><p>在脚本中为元素绑定事件处理函数<br>网页：<code>&lt;a id=’xxx’&gt;</code><br>脚本：<code>document.getElementById(‘’).onclick=function(){}</code><br>此方法把事件绑定和处理相关代码全部放在脚本中，实现了内容和行为分离，推荐使用<br>但此方法元素的一个监听事件只能绑定一个事件处理函数<br>使用这种方法：监听事件绑定事件处理函数只会绑定在冒泡阶段（从而没有捕获阶段）<br><code>onclick=‘add（‘pes’）’</code>参数不加引号表示变量，加引号表示单纯的一个字符串</p>\n</li>\n<li><p>高级事件绑定方法</p>\n<ol>\n<li><p>IE事件模型（IE8）：element.attachEvent(‘onXXX’,fn)<br>使用这种方式定义事件，事件处理函数会在全局作用域运行；this=window<br>而下面那种方式定义事件，事件处理函数会在其所属元素的作用域内运行</p>\n</li>\n<li><p>DOM事件模型（IE9支持）：element.addEventListener(‘XXX’,fn,[true|false])<br>有兼容性问题，可以逐渐为一个监听事件绑定多个事件处理函数<br>第三个可选参数为：是否使用捕获，默认为false；那么事件监听函数只会绑定在冒泡阶段；若改为true，那么事件监听函数只会绑定在捕获阶段<br>所有的事件都是由window上产生的，只是捕获默认为false（仍然会传播，但不做任何事情）<br>addEventLsitener的第三个参数：决定注册事件发生在捕获阶段还是冒泡阶段</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>如果事件源对象既绑定了捕获，也绑定了冒泡（定义了两次，一次true，一次false），那么事件的发生顺序取决于代码的执行顺序</p>\n<h2 id=\"封装事件绑定\"><a href=\"#封装事件绑定\" class=\"headerlink\" title=\"封装事件绑定\"></a>封装事件绑定</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> EventUtil=&#123;</div><div class=\"line\">    addHandler:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element,type,handler</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(element.addEventListener)&#123;</div><div class=\"line\">            element.addEventListener(type,handler,<span class=\"literal\">false</span>);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(element.attachEvent)&#123;</div><div class=\"line\">            element.attachEvent(‘on’+type,handler);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            element[‘on’+type]=handler;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    removeHandler:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element,type,handler</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(element.removeEventListener)&#123;</div><div class=\"line\">            element.removeEventListener(type,handler,<span class=\"literal\">false</span>);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(element.detachEvent)&#123;</div><div class=\"line\">            element.detachEvent(‘on’+type,handler);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            element[‘on’+type]=<span class=\"literal\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> btn=<span class=\"built_in\">document</span>.getElementById&#123;‘btn’&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> handler=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"number\">123</span>)&#125;;</div><div class=\"line\">EventUtil.addHandler(btn,’click’,handler);</div><div class=\"line\">EventUtil.removeHandler(btn,’click’,handler);</div><div class=\"line\"><span class=\"comment\">//以上方式没有考虑IE浏览器(IE8及以下)的作用与问题（当handler函数中涉及到this时，尤其要注意）</span></div></pre></td></tr></table></figure>\n<h2 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h2><p>当各个子元素的监听事件一样时，通过给父元素绑定事件，然后取得事件源（子元素），判定事件源的nodeName来决定事件处理函数；这样只需要绑定一次事件处理函数</p>\n<h2 id=\"事件解绑\"><a href=\"#事件解绑\" class=\"headerlink\" title=\"事件解绑\"></a>事件解绑</h2><p>element.detachEvent()<br>element.removeEventListener()</p>\n<p>注意：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">btn.addEventListener(‘click’,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"number\">1</span>)&#125;);</div><div class=\"line\">btn.removeEventListener(‘click’,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"number\">1</span>)&#125;);</div><div class=\"line\"><span class=\"comment\">//以上方法可以删除事件，但无法移除匿名函数所占的空间，因为两个匿名函数的引用地址不一样</span></div><div class=\"line\">btn.addEventListener(‘click’,fn1);</div><div class=\"line\">btn.removeEventListener(‘click’,fn1);</div><div class=\"line\"><span class=\"comment\">//这样可以删除事件的同时，移除函数所占的内存空间</span></div></pre></td></tr></table></figure>\n<p>移除子元素时，最好同时移除事件处理程序（或将其设为null）</p>\n<h2 id=\"获取Event\"><a href=\"#获取Event\" class=\"headerlink\" title=\"获取Event\"></a>获取Event</h2><p>鼠标事件源对象只有一个，且是当前鼠标所在位置，最上层（index最大）的元素对象，下层的兄弟元素无法获取到事件对象</p>\n<p>解决冒泡和捕获的弊端，增加和父元素同高宽、且透明的、在最上层的兄弟元素，通过给它绑定事件来达到不干扰的效果</p>\n<p>e.target：当前绑定事件处理函数的元素<br>e.currentTarget：当前触发事件的元素</p>\n<h3 id=\"Event的生命周期\"><a href=\"#Event的生命周期\" class=\"headerlink\" title=\"Event的生命周期\"></a>Event的生命周期</h3><p><strong>event对象的传递需要经过三个阶段</strong></p>\n<ol>\n<li>第一阶段：捕获阶段，event先传给父元素，再传给子元素（事件对象沿DOM树向下传播）</li>\n<li>第二阶段：目标触发阶段，event对象传递给事件的源头，并运行事件监听函数</li>\n<li>第三阶段：冒泡阶段，event对象先传给子元素，再传给父元素（事件对象沿DOM树向上传播）</li>\n</ol>\n<h3 id=\"Event的属性\"><a href=\"#Event的属性\" class=\"headerlink\" title=\"Event的属性\"></a>Event的属性</h3><ol>\n<li><p>获取事件源对象<br>IE：event.srcElement<br>Firefox：event.target<br>兼容性解决方案：var src=event.srcElement||event.target</p>\n</li>\n<li><p>阻止事件的默认行为<br>事件的默认行为：一个事件触发后，默认要执行的动作<br>IE：event.returnValue=false<br>DOM：event.preventDefault();<br>保证兼容性的写法：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>( event.preventDefault )&#123;</div><div class=\"line\">\t\tevent.preventDefault(  );\t\t<span class=\"comment\">//DOM</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\tevent.returnValue = <span class=\"literal\">false</span>;    \t<span class=\"comment\">//IE</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>停止事件的继续传播<br>IE：event.cancelBubble=true;  //取消冒泡<br>DOm：event.stopPropagation(); //停止传递<br>兼容性写法：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(event.stopPropagation())&#123;</div><div class=\"line\">event.stopPropagation();</div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">event.cancelBubble=<span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取事件的发生坐标<br>event.clientX和event.clientY //相对于浏览器显示区域的左上角为原点<br>event.pageX和event.pageY //以页面内容左上角为原点的坐标<br>event.screenX和event.screenY //以显示器左上角为原点的坐标<br>event.offsetX和event.offsetY //以事件源对象的左上角为坐标原点（小心事件冒泡）<br>scrollTop和scrollLeft<br>event.x和event.y //相对于浏览器显示区域的左上角为原点</p>\n</li>\n<li><p>事件的type属性<br>可以在一个函数内，通过检测event.type=‘click’|‘mouseover’来决定执行不同的操作</p>\n</li>\n</ol>\n<h2 id=\"事件的类别\"><a href=\"#事件的类别\" class=\"headerlink\" title=\"事件的类别\"></a>事件的类别</h2><p><strong>事件类别主要有以下</strong></p>\n<ul>\n<li>onload事件</li>\n<li>onselect事件</li>\n<li>onblur事件</li>\n<li>onfocus事件</li>\n<li>onclick事件</li>\n<li>onmouseover：包括子元素（mouseenter移动到子元素上不会触发）</li>\n<li>onmouseout：包括子元素（mouseleave移动到子元素上不会触发）</li>\n<li>onmousemove:鼠标移动时发生的事件</li>\n<li>onkeydown</li>\n<li>onkeypress</li>\n<li>onkeyup</li>\n<li>onchange事件</li>\n</ul>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"DOM","url":"http://yoursite.com/2017/09/12/DOM/","content":"<h1 id=\"核心-DOM\"><a href=\"#核心-DOM\" class=\"headerlink\" title=\"核心 DOM\"></a>核心 DOM</h1><h2 id=\"节点类型\"><a href=\"#节点类型\" class=\"headerlink\" title=\"节点类型\"></a>节点类型</h2><ol>\n<li>文档节点—document.node</li>\n<li>元素节点—element.node</li>\n<li>属性节点—attribute.node</li>\n<li>文本节点—text.node</li>\n<li>注释节点—comment.node</li>\n</ol>\n<h2 id=\"节点间关系\"><a href=\"#节点间关系\" class=\"headerlink\" title=\"节点间关系\"></a>节点间关系</h2><ol>\n<li>父节点<ul>\n<li>node.parentNode</li>\n</ul>\n</li>\n<li>子节点<ul>\n<li>node.childNodes</li>\n<li>node.firstChild</li>\n<li>node.lastChild</li>\n</ul>\n</li>\n<li>兄弟节点<ul>\n<li>node.nextSibling</li>\n<li>node.previousSibling</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"选择节点\"><a href=\"#选择节点\" class=\"headerlink\" title=\"选择节点\"></a>选择节点</h2><ol>\n<li><p>document.getElementById(‘id’)<br> 查找速度相对于使用节点关系来查找，要慢一些；只返回找到的第一个具有指定id的元素</p>\n</li>\n<li><p>node.getElementsByTagName(‘元素标签名’)<br> 返回一个类数组对象；只在当前node中查找；如果将node改为document，那么会返回document下的所有和指定标签同名的元素</p>\n</li>\n<li><p>document.getElementByName(‘name属性值’)<br> 返回类数组对象，表单用得比较多</p>\n</li>\n<li><p>node.getElementsByClassName(‘class类名’)<br> HTML5新方法，IE8不支持<br> element.classList.add/contains/remove/toggle(‘类名’)：分别表示增加、是否包含、删除、存在则删除不存在则添加，这些方法适用于元素含有多个类名（中间空格隔开的类名），且这些操作不会影响原有的类名，但在IE中IE10+才支持</p>\n</li>\n<li><p>node.querySelector(‘选择器’)<br> 返回匹配指定选择器的第一个元素，该种方式相对于getElementById()来说，虽然好用但效率更低<br>选择器可以是CSS样式表中不存在的选择器，仅仅是创建一个临时选择器，可以选中匹配该选择器的任何页面上的元素所以此方法可以代替以上的各种方法<br> var input=document.querySelector(‘[name=srcValue]’);//name右边的值有无引号皆可,但不能为变量</p>\n</li>\n<li><p>node.querySelectorAll(‘选择器’)：返回匹配指定选择器的所有元素，选择器同上</p>\n</li>\n</ol>\n<p>选择三个基础元素的快捷方法：</p>\n<ol>\n<li>document.documentElement=html</li>\n<li>document.head=head</li>\n<li>document.body=body</li>\n</ol>\n<h2 id=\"增删改节点\"><a href=\"#增删改节点\" class=\"headerlink\" title=\"增删改节点\"></a>增删改节点</h2><p>在操作节点对象时，一般将节点对象赋值给某个变量（引用地址赋给变量），然后变量.属性来操作节点对象的属性；如果将节点对象的属性值赋给变量，那么接下来对变量的操作将不会应用到节点对象上</p>\n<h3 id=\"创建和插入节点\"><a href=\"#创建和插入节点\" class=\"headerlink\" title=\"创建和插入节点\"></a>创建和插入节点</h3><p>可以创建head中的script和link元素来为页面加载动态脚本和样式</p>\n<p>添加新DOM节点对象，需要两步：</p>\n<ol>\n<li>创建新的节点对象，<ul>\n<li>var node=document.createElement(‘标签名’);</li>\n<li>document.creatTextNode(‘text’)</li>\n<li>document.createComment(‘注释’)</li>\n<li>document.createAttributeNode(‘属性名’)</li>\n<li>document.createDocumentFragment();创建文档片段</li>\n</ul>\n</li>\n<li>把新建的节点对象挂到DOM树上<ul>\n<li>parentNode.appendChild(node)：将新建的节点追加为父节点的最后一个子节点</li>\n<li>parentNode.insertBefore(newnode,参照节点)：在参照节点之前添加子节点（也可以用于移动子节点）</li>\n</ul>\n</li>\n</ol>\n<p>当添加节点以及节点的子节点时，可以先创建好节点以及子节点，先把子节点挂到节点上，再把节点挂到DOM树中</p>\n<p>每当DOM挂载一个新节点，浏览器必须重新绘制整个页面的所有内容—若元素很多，可能会看到很短的显示空白，——若代码在循环中，频繁的往DOM树挂载新内容，就可能发生页面的频闪<br>如何避免：<strong>先创建一个新的元素（如div），或者创建一个透明的不对应任何标签documentFragment对象，把需要批量创建的元素追加为新div或fragment的子元素，最后把新的div或fragment挂载到DOM树上，这样页面只闪一次</strong></p>\n<h3 id=\"删除和替换节点\"><a href=\"#删除和替换节点\" class=\"headerlink\" title=\"删除和替换节点\"></a>删除和替换节点</h3><p>parentNode.removeChild(childNode)<br>此方法也会导致页面重新绘制，所以不要放在循环里面，也最好不要一个一个删<br>另外子节点被删除前应解除所有绑定的事件，否则无法回收事件绑定所占用内存</p>\n<p>parentNode.replaceChild(newNode，oldNode)<br>替换一个已经存在的子节点</p>\n<h3 id=\"复制节点\"><a href=\"#复制节点\" class=\"headerlink\" title=\"复制节点\"></a>复制节点</h3><p>node.cloneNode(true/false)<br>深复制：包含所有子节点<br>浅复制：不包含子节点<br>IE存在一个bug，会复制事件处理程序，建议复制之前移除事件处理程序</p>\n<h3 id=\"处理文本节点\"><a href=\"#处理文本节点\" class=\"headerlink\" title=\"处理文本节点\"></a>处理文本节点</h3><p>node.normalize()：<br>会在node的后代节点中查找；如果找到了空文本节点则删除它，如果找到了相邻的文本节点则将其合并为一个文本节点</p>\n<h2 id=\"读取和修改节点信息\"><a href=\"#读取和修改节点信息\" class=\"headerlink\" title=\"读取和修改节点信息\"></a>读取和修改节点信息</h2><h3 id=\"节点信息\"><a href=\"#节点信息\" class=\"headerlink\" title=\"节点信息\"></a>节点信息</h3><ol>\n<li>node.nodeName(默认返回值都是大写)</li>\n<li>node.nodeType</li>\n<li>node.nodeValue</li>\n</ol>\n<p>在IE下，无法访问到Node类型（注意是大写的Node），nodeName等是可以访问到的；Ie8及之前版本把DOM节点当做COM对象来实现</p>\n<h3 id=\"节点内容\"><a href=\"#节点内容\" class=\"headerlink\" title=\"节点内容\"></a>节点内容</h3><ol>\n<li>nodeValue：文本节点对象的内容，需先选中文本节点对象</li>\n<li><p>innerHTML：用于读取或设置元素节点对象中的HTML内容;div.innerHTML=’’;清除元素内容最快的方法<br> 有一些元素不支持innerHTML属性，例如head，html，body，tr；IE8之前，title也不支持该属性<br> <code>div.outerHTML=’&lt;p&gt;0&lt;/p&gt;’</code>；那么p将会取代div（和innerHTML一样都可以读取和设置，不过outerHTML包含元素）<br> element.insertAdjacentHTML(插入位置，要插入的HTML文本)：</p>\n</li>\n<li><p>textContent：用于读取或设置元素节点对象中的所有文本内容；读取时，元素节点对象下的非文本内容（包括标签）会被忽略；设置时，元素节点对象下的非文本内容会被剔除，只留下设置的文本内容；<br> 此属性IE8不支持,但是是DOM标准属性</p>\n</li>\n<li><p>innerText：和textContent类似，IE8支持此属性，但Firefox不支持<br> textContent和innerText在遇到换行时，显示效果有些差异</p>\n</li>\n</ol>\n<h3 id=\"节点属性\"><a href=\"#节点属性\" class=\"headerlink\" title=\"节点属性\"></a>节点属性</h3><p>元素节点的attributes属性：返回一个类数组对象，表示当前元素节点的所有属性的集合<br>HTML写法：class<br>JS写法：className</p>\n<p>读取属性：属性节点的值一般用属性名.value</p>\n<ul>\n<li>element.attributes[下标].value：返回属性的值</li>\n<li>element.attributes[‘属性名’].value：返回属性的值</li>\n<li>element.getAttributeNode(‘属性名’).value：返回属性的值</li>\n<li>element.getAttribute(‘属性名’)：返回属性的值</li>\n</ul>\n<p>修改属性：</p>\n<ul>\n<li>element.setAttribute(name,value)：IE8不支持</li>\n<li>element.setAttributeNode(attrNode)：修改指定属性节点的值，将新节点设置进去</li>\n</ul>\n<p>移除属性：</p>\n<ul>\n<li>element.removeAttribute(‘属性名’)：移除该元素节点下指定属性名的值</li>\n<li>element.removeAttributeNode(attrNode)：移除指定属性节点的值</li>\n</ul>\n<p>判断属性：</p>\n<ul>\n<li>element.hasAttribute(‘属性名’)：该元素节点是否拥有指定属性名的属性</li>\n<li>element.hasAttributes()：是否拥有属性，无参数，IE8不支持</li>\n<li>node.ownerDocument：指向表示整个文档的文档节点#document</li>\n</ul>\n<h3 id=\"元素节点的style属性\"><a href=\"#元素节点的style属性\" class=\"headerlink\" title=\"元素节点的style属性\"></a>元素节点的style属性</h3><p>元素节点.style.属性和getAttribute()只能获取到内联样式的值（获取不到内部样式和外部样式的值），而且元素节点.style.属性和setAttribute()对元素样式做的任何修改本质上是修改元素内联样式（会覆盖外部样式的值），所以能够看得到效果<br>setAttribute()修改CSS样式时，注意第一个参数为style</p>\n<p>使用JS修改style属性的方法：</p>\n<ol>\n<li><p>现在CSS样式表中定义个一个规则，比如.hide和.show，然后修改元素节点的className属性，使其匹配CSS样式表中的选择器即可</p>\n</li>\n<li><p>元素节点对象.style.属性1=’ ’;<br> 元素节点对象.style.属性2=’ ’;<br> 使用这种方式，如果属性2和属性1不同名，那么后者不会覆盖前者；但每次只能添加一个属性</p>\n</li>\n<li><p>元素节点对象.style.cssText=’’;<br> 可以一次性添加多个属性，中间用分号相隔即可<br> 注意：使用这种方法时，为了防止新添加的cssText不覆盖之前的，就必须采用字符串拼接 old.cssText = old.cssText + strCss;但在IE8中，这种cssText拼接会导致丢失分号，需另外处理<br>考虑到兼容性问题，当修改style属性较少时，建议采用方法2</p>\n</li>\n</ol>\n<p>使用JS修改style属性时应注意以下几点：</p>\n<ol>\n<li>CSS写法：list-style-type<br> JS写法：obj.style.listStyleType</li>\n<li>float属性的例外<br> obj.style.float，这样写会导致错误<br> 应写成：IE:obj.style.styleFloat，其他浏览器:obj.style.cssFloat。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s=<span class=\"built_in\">window</span>.getComputedStyle(‘元素对象’) <span class=\"comment\">//IE不支持</span></div><div class=\"line\"><span class=\"keyword\">var</span> s=obj.currentStyle()                       <span class=\"comment\">//IE支持，其他浏览器不支持</span></div><div class=\"line\"><span class=\"comment\">//显示该元素对象所有样式最终计算出来的值</span></div><div class=\"line\"><span class=\"comment\">//只能用于读取；计算的样式无法被js修改</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(s.backgroundColor)</div></pre></td></tr></table></figure>\n<h2 id=\"元素树\"><a href=\"#元素树\" class=\"headerlink\" title=\"元素树\"></a>元素树</h2><p>元素树：只有元素节点（无文本节点，无属性节点，无注释节点）<br>元素树是节点树的子集，只操作元素节点</p>\n<table>\n<thead>\n<tr>\n<th>节点树</th>\n<th>元素树（以下属性注意IE8的兼容性）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>根对象：document</td>\n<td>根对象：document</td>\n</tr>\n<tr>\n<td>childNodes</td>\n<td>children</td>\n</tr>\n<tr>\n<td>firstChild</td>\n<td>firstElementChild</td>\n</tr>\n<tr>\n<td>lastChild</td>\n<td>lastElementChild</td>\n</tr>\n<tr>\n<td>parentNode</td>\n<td>parentElementNode（和左边无区别）</td>\n</tr>\n<tr>\n<td>nextSibling</td>\n<td>nextElementSibling</td>\n</tr>\n<tr>\n<td>previousSibling</td>\n<td>previousElementSibling</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"HTML-DOM\"><a href=\"#HTML-DOM\" class=\"headerlink\" title=\"HTML DOM\"></a>HTML DOM</h1><p>核心DOM只定义了几种不同的Node对象：属性Node，文本Node，元素Node；但是没有元素Node又可以细分为哪些<br>核心DOM提供了统一的操作接口；适合于操作节点（创建、删除、查找等）</p>\n<p>HTML DOM定义了100个左右的元素Node—-每个HTML标签都对应一个对象，且这些对象预定义了若干的属性<br>HTML DOM提供了封装好了的各种对象，所以可以直接元素对象.属性；适用于获取和修改属性的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> img=<span class=\"keyword\">new</span> Image();<span class=\"comment\">//HTML DOM对象大部分都不能new，所以禁止这样使用（换createElement）</span></div><div class=\"line\">img.src=<span class=\"string\">'C:\\Users\\Administrator\\Desktop\\新建文件夹\\Chrysanthemum.jpg'</span>;</div><div class=\"line\">img.style.cssText=<span class=\"string\">'width:100px;height:100px;'</span>;</div><div class=\"line\">table.width=<span class=\"number\">500</span>;</div><div class=\"line\">table.border=<span class=\"number\">1</span>;<span class=\"comment\">//注意是number类型无需px</span></div><div class=\"line\">img.className=<span class=\"string\">'img'</span>;</div><div class=\"line\">img.style.cssFloat=<span class=\"string\">'right'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> div=<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.container'</span>);</div><div class=\"line\">div.appendChild(img);</div></pre></td></tr></table></figure>\n<h2 id=\"常用的HTML-DOM对象\"><a href=\"#常用的HTML-DOM对象\" class=\"headerlink\" title=\"常用的HTML DOM对象\"></a>常用的HTML DOM对象</h2><h3 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h3><p>在js中可以直接new Image，并获取实例的属性width，height，src，title等</p>\n<h3 id=\"Table\"><a href=\"#Table\" class=\"headerlink\" title=\"Table\"></a>Table</h3><p>特别的属性：rows 类数组属性<br>特别的方法：</p>\n<ul>\n<li>insertRow(index) 为表格对象添加一个tr子对象；返回TableRow对象</li>\n<li>deleteRow(index) 从表格中删除一个tr子对象；返回TableRow对象</li>\n</ul>\n<p>TableRow对象<br>特别的属性：</p>\n<ul>\n<li>rowIndex：number类型，返回当前tr在table中序号</li>\n<li>cells：类数组对象，返回当前tr中所有的td的集合</li>\n</ul>\n<p>特别的方法：</p>\n<ul>\n<li>insertCell(index) 在tr中插入一个新的td</li>\n<li>deleteCell(index) 在tr中删除一个td</li>\n</ul>\n<p>TableCell对象<br>特别的属性：</p>\n<ul>\n<li>cellIndex</li>\n<li>innerHTML</li>\n<li>colSpan</li>\n<li>rowSpan</li>\n</ul>\n<p>有了table对象，在js中就能非常方便的生成DOM对象（比核心DOM简单得多）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> table=<span class=\"built_in\">document</span>.createElement(‘table’);</div><div class=\"line\">table.border=<span class=\"number\">1</span>;</div><div class=\"line\">table.width=<span class=\"number\">500</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> tr=table.insertRow();<span class=\"comment\">//直接插入即可，无需先创建再插入子节点</span></div><div class=\"line\"><span class=\"keyword\">var</span> td0=tr.insertCell();<span class=\"comment\">//直接插入即可，无需先创建再插入子节点</span></div><div class=\"line\"><span class=\"keyword\">var</span> td1=tr.insertCell();</div><div class=\"line\"><span class=\"keyword\">var</span> td2=tr.insertCell();</div><div class=\"line\">td0.innerHTML=’编号’;</div><div class=\"line\">td1.innerHTML=’名称’;</div><div class=\"line\">td2.innerHTML=’操作’;</div><div class=\"line\"><span class=\"keyword\">var</span> div=<span class=\"built_in\">document</span>.querySelector(‘.container’);</div><div class=\"line\">div.appendChild(table);</div></pre></td></tr></table></figure>\n<h3 id=\"Form\"><a href=\"#Form\" class=\"headerlink\" title=\"Form\"></a>Form</h3><p>属性：</p>\n<ul>\n<li>action</li>\n<li>method</li>\n<li>enctype</li>\n<li>length：表单中元素的数目</li>\n<li>arguments：包含表单中所有元素的数组</li>\n</ul>\n<p>方法：</p>\n<ul>\n<li>submit()：</li>\n<li>reset()：</li>\n</ul>\n<p>在提交表单时，最好不要用reset按钮和submit按钮，尽量使用button按钮外加onclick=function (){if(…){form1.submit()}}，这样就仅仅通过if判断条件来决定表单是否提交或重置；而无需阻止提交按钮和重置按钮的默认行为</p>\n<h3 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h3><p>input.focus()：表示申请获得焦点（百度首页打开页面搜索框就可以获得焦点，从而无需鼠标点击就可以直接输入）<br>input.blur():<br>input.select()：表示选中input内的所有文本，这样用户只需输入字符或桉删除键便可删除全部；而无需一个一个删除</p>\n<h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h3><p>特别的属性：</p>\n<ul>\n<li>multiple：表示是否允许多选</li>\n<li>size：number类型，下拉框长度；显示出来的选项的数量</li>\n<li>value：string，当前选中的option的value值（非text）</li>\n<li>selectedIndex：number，当前选中的option的下标</li>\n<li>options：类数组对象，包含所有的option</li>\n</ul>\n<p>特别的方法：</p>\n<ul>\n<li>add(option):添加一个新的option</li>\n<li>remove(index):删除一个option</li>\n</ul>\n<p>HTML文档中，multiple，sleected，checked（disabled，readonly）等属性在只要出现（无论是‘’还是multiple=‘false’），都会生效（其布尔值为true）<br>但在Javascript中想设置这些属性的值时，必须设为true或false</p>\n<h3 id=\"option\"><a href=\"#option\" class=\"headerlink\" title=\"option\"></a>option</h3><p>创建新的Option：<code>new Option(‘txt’,’value’);</code><br>HTML DOM中只有Image和Option可以new出来<br><code>new Option(‘北京’,’110’)：&lt;option value=’110’&gt;北京&lt;/option&gt;</code></p>\n<p>特别的属性：</p>\n<ul>\n<li>index：</li>\n<li>text：</li>\n<li>value：</li>\n<li>selected：布尔值，表示当前option是否被选中</li>\n</ul>\n<h2 id=\"HTML5新增DOM-api\"><a href=\"#HTML5新增DOM-api\" class=\"headerlink\" title=\"HTML5新增DOM api\"></a>HTML5新增DOM api</h2><h3 id=\"焦点管理\"><a href=\"#焦点管理\" class=\"headerlink\" title=\"焦点管理\"></a>焦点管理</h3><p>document.activeElement：始终引用DOM中当前获得了焦点的元素<br>document.hasFocus()：确认文档是否获得了焦点</p>\n<h3 id=\"文档加载状态（可以代替onload）\"><a href=\"#文档加载状态（可以代替onload）\" class=\"headerlink\" title=\"文档加载状态（可以代替onload）\"></a>文档加载状态（可以代替onload）</h3><p>document.readyState：loading（正在加载）/complete（文档加载完毕）</p>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"ECMAScript-基本语法","url":"http://yoursite.com/2017/09/10/ECMAScript-基本语法/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>一个完整的JavaScript实现应该由三个不同的部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）</p>\n<h1 id=\"HTML中使用JavaScript\"><a href=\"#HTML中使用JavaScript\" class=\"headerlink\" title=\"HTML中使用JavaScript\"></a>HTML中使用JavaScript</h1><h2 id=\"script元素\"><a href=\"#script元素\" class=\"headerlink\" title=\"script元素\"></a>script元素</h2><ol>\n<li>type属性默认为text/javascript</li>\n<li>src为外部脚本文件</li>\n<li>defer设置后脚本会被延迟到整个页面都解析完毕后再运行</li>\n<li>async设置后立即下载该脚本文件但延迟执行</li>\n</ol>\n<h2 id=\"文档模式\"><a href=\"#文档模式\" class=\"headerlink\" title=\"文档模式\"></a>文档模式</h2><p>如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式.</p>\n<ol>\n<li>混杂模式（quirks mode）混杂模式会让IE的行为与（包含非标准特性的）IE5相同，</li>\n<li>标准模式（standards mode）。而标准模式则让IE的行为更接近标准行为。</li>\n</ol>\n<h2 id=\"noscript\"><a href=\"#noscript\" class=\"headerlink\" title=\"noscript\"></a>noscript</h2><p>包含在noscript元素中的内容只有在这些情况下才会显示出来：浏览器不支持脚本；浏览器支持脚本，但脚本被禁用。</p>\n<h2 id=\"ECMAScript-6\"><a href=\"#ECMAScript-6\" class=\"headerlink\" title=\"ECMAScript 6\"></a>ECMAScript 6</h2><h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><ol>\n<li>ECMAScript中的一切（变量、函数名和操作符）都区分大小写</li>\n<li>标识符规则: 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其他字符可以是字母、下划线、美元符号或数字。建议采用驼峰命名法</li>\n<li>单行注释和块级注释.</li>\n<li>不要省略分号</li>\n<li>启用严格模式: 可以在顶部添加如下代码： “use strict”;</li>\n</ol>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ol>\n<li><strong>ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。</strong>  </li>\n<li><strong>ES6规定，var和function声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。</strong></li>\n<li>什么是变量：内存中存储一个数据的存储空间，然后起个名字</li>\n<li>何时使用变量：程序中接受的、待处理的、将要输出的数据都要在变量中临时保存，然后再使用</li>\n<li>变量如何使用：赋值与取值</li>\n</ol>\n<h3 id=\"通过var声明\"><a href=\"#通过var声明\" class=\"headerlink\" title=\"通过var声明\"></a>通过var声明</h3><ol>\n<li>定义变量应该使用var操作符（不使用var操作符将会定义一个全局变量，这种方式不被推荐），后面跟一个变量名。</li>\n<li>var message像这样只是声明一个变量，并没有初始化，它的值将是undefined。</li>\n<li><strong>声明提前</strong>: JavaScript引擎解释时会把所有用var声明的变量都提升到当前作用域的最前面。</li>\n</ol>\n<h3 id=\"通过let声明\"><a href=\"#通过let声明\" class=\"headerlink\" title=\"通过let声明\"></a>通过let声明</h3><ol>\n<li>es6支持块级作用域, let声明不会提前</li>\n<li>let不允许在相同作用域内，重复声明同一个变量。</li>\n<li>使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。  </li>\n</ol>\n<p>下面皆会报错</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"通过const声明\"><a href=\"#通过const声明\" class=\"headerlink\" title=\"通过const声明\"></a>通过const声明</h3><ol>\n<li>es6中const用来声明常量, </li>\n<li>其他用法和let一致</li>\n</ol>\n<h3 id=\"变量内存\"><a href=\"#变量内存\" class=\"headerlink\" title=\"变量内存\"></a>变量内存</h3><ol>\n<li>变量是如何存储的<br><img src=\"/images/变量内存.png\" alt=\"变量内存\"></li>\n<li>栈内存和堆内存的关系</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>栈内存</th>\n<th>堆内存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储基础数据类型</td>\n<td>存储引用数据类型</td>\n</tr>\n<tr>\n<td>按值访问</td>\n<td>按引用访问</td>\n</tr>\n<tr>\n<td>存储的值大小固定</td>\n<td>存储的值大小不定，可动态调整</td>\n</tr>\n<tr>\n<td>由系统自动分配内存空间</td>\n<td>由程序员通过代码进行分配</td>\n</tr>\n<tr>\n<td>主要用来执行程序</td>\n<td>主要用来存放对象</td>\n</tr>\n<tr>\n<td>空间小，运行效率高</td>\n<td>空间大，但是运行效率相对较低</td>\n</tr>\n<tr>\n<td>先进后出，后进先出</td>\n<td>无序存储，可根据引用直接获取</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><ol>\n<li>ECMAScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，其本质是一组无序的名值对组成</li>\n<li>ES6引入了一种新的基本数据类型Symbol，是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。</li>\n<li>现在共有七种数据类型：Undefined, Null, Boolean, String, Symbol, Number和Object.</li>\n<li>数据类型可以分为原始类型（数据直接保存在变量本地的数据类型，除Object外都是）和引用类型（变量本地只保存数据的引用）</li>\n</ol>\n<h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h3><ol>\n<li>注意，typeof是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。</li>\n<li>typeof操作符的操作数可以是变量（message），也可以是数值字面量。</li>\n<li>typeof的返回值</li>\n</ol>\n<ul>\n<li>“undefined” 如果这个值未定义</li>\n<li>“boolean” 如果这个值是布尔值</li>\n<li>“string” 如果这个值是字符串</li>\n<li>“number” 如果这个值是数值</li>\n<li>“object” 如果这个值是对象或者null</li>\n<li>“function” 如果这个值是函数</li>\n<li>“symbol” 如果这个值是Symbol类型（ES6新增）</li>\n</ul>\n<h3 id=\"Undefined\"><a href=\"#Undefined\" class=\"headerlink\" title=\"Undefined\"></a>Undefined</h3><ol>\n<li>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined</li>\n<li>对未初始化和未声明的变量执行 typeof 操作符都返回 undefined 值，但是如果直接访问未声明的变量就会报错了。</li>\n<li>对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型，这也是typeof存在的最大意义了。</li>\n</ol>\n<h3 id=\"Null\"><a href=\"#Null\" class=\"headerlink\" title=\"Null\"></a>Null</h3><ol>\n<li>Null类型是第二个只有一个值的数据类型，这个特殊的值是 null。</li>\n<li>null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因</li>\n<li>undefined值是派生自null值的，null == undefined将会返回true。</li>\n<li>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null 值就可以知道相应的变量是否已经保存了一个对象的引用</li>\n</ol>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h3><ol>\n<li>可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值，你也可以在任何数据前加!!使其转化为Boolean类型。</li>\n<li>转换规则</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>转换为true的值</th>\n<th>转换为false的值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Boolean</td>\n<td>true</td>\n<td>false</td>\n</tr>\n<tr>\n<td>String</td>\n<td>非空字符串</td>\n<td>“”</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>非零数字值（包括无穷大）</td>\n<td>0和NaN</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>任何对象</td>\n<td>null</td>\n</tr>\n<tr>\n<td>Undefined</td>\n<td>n/a（不适用）</td>\n<td>undefined</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h3><ol>\n<li>八进制字面量在严格模式下是无效的</li>\n<li>默认情况下，ECMAScript会将那些小数点后面带有 6个零以上的浮点数值转换为以 e表示法表示的数值（例如，0.0000003会被转换成3e-7）</li>\n<li>如果浮点数值本身表示的就是一个整数（如1.0），那么该值也会被转换为整数</li>\n<li>永远不要测试某个特定的浮点数值。 关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754数值的浮点计算的通病，ECMAScript并非独此一家；其他使用相同数值格式的语言也存在这个问题。</li>\n<li>NaN: <strong>任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身.</strong></li>\n<li>isNaN(): 这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”</li>\n<li>最小值: Number.MIN_VALUE; 最大值: Number.MAX_VALUE; 无穷;  Infinity 值</li>\n<li>isFinite(): 判断是否有穷</li>\n<li>Number(): 非数值转换为数值, 可以用于任何数据类型</li>\n<li>parseInt(): 用于把字符串转换成数值; 这个函数提供第二个参数：转换时使用的基数（即多少进制）。<ul>\n<li>转换字符串时会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回 NaN；</li>\n<li>如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，”1234blue”会被转换为1234，因为”blue”会被完全忽略</li>\n</ul>\n</li>\n<li>parseFloat(): 用于把字符串转换成数值;<ul>\n<li>小数点有效</li>\n<li>parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成0。</li>\n<li>由于parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。</li>\n</ul>\n</li>\n<li>var num=8;内存占用4个字节// 00000000 00000000 00000000 00001000 //最大可以10e308<br>1kb=1024byte（字节）1byte=8bit（位）<strong>整数存储32bit=4byte 浮点数存储64bit=8byte</strong></li>\n</ol>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><ol>\n<li>转义字符被作为一个字符来解析</li>\n<li>String(): 这个函数能够将任何类型的值转换为字符串。</li>\n<li>totoString():      <ul>\n<li>数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法。但null和undefined值没有这个方法。</li>\n<li>多数情况下，调用toString()方法不必传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数</li>\n</ul>\n</li>\n<li>可以使用加号+操作符把某个值与以空字符加在一起来转换为字符串。</li>\n<li><strong>凡是从页面上获取的数据或元素的属性，都是字符串，都要先类型转换，再计算</strong></li>\n<li><strong>每个字符占2字节</strong>，汉字、数字、字母、标点都是2字节（“张”，编号为24352，转换为2进制存储，小于2的16次方，故占两个字节（16位），“hello”：2*5=10个字节）</li>\n<li><strong>字符串一旦创建内容不可改变</strong>（原来的内存占用仍然存在）<br> 例：var str1=”hello”,str1=str1+”world”;<br> //共创建3个字符串，第一个内存空间保存着“hello”，第二个“world”，第三个“helloworld”，但是str1的指针从“hello”转向了“helloworld”</li>\n</ol>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><ol>\n<li>Symbol，表示独一无二的值。对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</li>\n<li>Symbol生成的是类似字符串的原始类型值, 不能添加属性, 不能使用new命令</li>\n<li>Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li>\n<li>注意，Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。</li>\n<li>Symbol值不能与其他类型的值进行运算，会报错。但是，Symbol值可以转为字符串。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var sym = Symbol(&apos;My symbol&apos;);</div><div class=\"line\">var a = &quot;your symbol is &quot; + sym; //报错</div><div class=\"line\">String(sym) // &apos;Symbol(My symbol)&apos;</div><div class=\"line\">sym.toString() // &apos;Symbol(My symbol)&apos;</div></pre></td></tr></table></figure>\n<ol>\n<li>对象属性名使用Symbol</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mySymbol = <span class=\"built_in\">Symbol</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第一种写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</div><div class=\"line\">a[mySymbol] = <span class=\"string\">'Hello!'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第二种写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;</div><div class=\"line\">  [mySymbol]: <span class=\"string\">'Hello!'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 第三种写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</div><div class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a, mySymbol, &#123; <span class=\"attr\">value</span>: <span class=\"string\">'Hello!'</span> &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 以上写法都得到同样结果</span></div><div class=\"line\">a[mySymbol] <span class=\"comment\">// \"Hello!\"</span></div></pre></td></tr></table></figure>\n<ol>\n<li>Symbol值作为对象属性名时，不能用点运算符。同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</li>\n<li>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</li>\n<li>Symbol值作为属性名时，该属性还是公开属性，不是私有属性。</li>\n<li>Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。</li>\n<li>Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。</li>\n<li><p>Symbol方法:</p>\n<ul>\n<li><p>Symbol.for(): 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p>\n<blockquote>\n<p>Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</p>\n</blockquote>\n</li>\n<li><p>Symbol.keyFor(): 返回一个已登记的Symbol类型值的key。</p>\n<blockquote>\n<p>需要注意的是，Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的iframe或service worker中取到同一个值。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>内置的Symbol值<br>除了定义自己使用的Symbol值以外，ES6还提供一些内置的Symbol值，指向语言内部使用的方法。</p>\n<ul>\n<li>对象的Symbol.hasInstance属性，指向一个内部方法。该对象使用instanceof运算符时，会调用这个方法，判断该对象是否为某个构造函数的实例。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。</li>\n<li>对象的Symbol.isConcatSpreadable属性，指向一个方法。该对象使用Array.prototype.concat()时，会调用这个方法，返回一个布尔值，表示该对象是否可以扩展成数组。</li>\n<li>对象的Symbol.isRegExp属性，指向一个方法。该对象被用作正则表达式时，会调用这个方法，返回一个布尔值，表示该对象是否为一个正则对象。</li>\n<li>对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。</li>\n<li>对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</li>\n<li>对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。</li>\n<li>对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。</li>\n<li>对象的Symbol.iterator属性，指向一个方法，即该对象进行for…of循环时，会调用这个方法，返回该对象的Iterator对象。</li>\n<li>对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</li>\n<li>对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。</li>\n<li>对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><p>Object每个实例都具有下列属性和方法</p>\n<ul>\n<li>Constructor：保存用于创建当前对象的函数，即构造函数</li>\n<li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在，propertyName必须是字符串</li>\n<li>isPrototypeOf(object)：用于检查传入的对象是否是另一个对象的原型</li>\n<li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。参数必须是字符串</li>\n<li>toLocaleString()：返回对象的字符串表示，与执行环境的地区对应</li>\n<li>toString()：返回对象的字符串表示</li>\n<li>valueOf()：分返回对象的字符串、数值或布尔值表示。通常与toString方法返回值相同。</li>\n</ul>\n<h3 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h3><p>js是弱类型语言：</p>\n<ol>\n<li>声明变量时不必预先定义数据类型，赋值时动态确定数据的类型</li>\n<li>同一变量，可先后保存不同类型的数据</li>\n<li>不同类型数据在计算过程中，会根据运算的需要，会动态隐式转换数据的类型</li>\n</ol>\n<h4 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h4><ol>\n<li>隐式转换默认使用Number()和String()；</li>\n<li>隐式转换不修改原变量的值（数据类型也不变），仅是临时转换</li>\n<li>算数计算：所有数据类型会被隐式转换成数值类型</li>\n<li>加法运算（算数运算特例）：只要有字符串，其它数据类型会被强制转换成字符串，然后执行字符串拼接操作</li>\n<li>布尔类型只有在和字符串做运算时，才会被转换成字符串</li>\n<li>隐式转换中：valueOf偏向于运算，toString偏向于显示。</li>\n</ol>\n<h4 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h4><p>通过调用函数，显示执行的类型转换</p>\n<ol>\n<li>任意类型-&gt;String：使用toString()或者String()</li>\n<li>任意类型-&gt;Number：str转换为数值用parseInt/parseFloat,其他类型转换为数值用Number()；</li>\n<li>任意类型-&gt;Boolean：使用Boolean()，false、“”、0、NaN、null、undefined会被转换成false</li>\n</ol>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><h3 id=\"一元操作符-–\"><a href=\"#一元操作符-–\" class=\"headerlink\" title=\"一元操作符(++,–,+,-)\"></a>一元操作符(++,–,+,-)</h3><ol>\n<li>应用于非数值的值时，递增和递减操作符执行前，该值会被转换为数值，然后在执行递增递减。对象是先调用它们的valueOf()和（或）toString()方法，再转换得到的值。</li>\n<li>在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。如+’10’ === 10 //true</li>\n</ol>\n<h3 id=\"位操作符-amp-lt-lt-gt-gt-gt-gt-gt\"><a href=\"#位操作符-amp-lt-lt-gt-gt-gt-gt-gt\" class=\"headerlink\" title=\"位操作符(~,&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;)\"></a>位操作符(~,&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;)</h3><h3 id=\"布尔操作符-amp-amp\"><a href=\"#布尔操作符-amp-amp\" class=\"headerlink\" title=\"布尔操作符(!,&amp;&amp;,||)\"></a>布尔操作符(!,&amp;&amp;,||)</h3><ol>\n<li>逻辑非操作符首先会将操作数转换为布尔值然后再计算。参考前面的Boolean转换表</li>\n<li>逻辑与在有一个操作数不是布尔值情况下不一定返回布尔值，遵循下列规则：<ul>\n<li>如果第一个操作数是对象，则返回第二个操作数</li>\n<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true    - 的情况下才返回该对象</li>\n<li>如果两个操作数都是对象，则返回第二个操作数</li>\n<li>如果有一个操作数是null，则返回null</li>\n<li>如果有一个操作数是NaN，则返回NaN</li>\n<li>如果有一个操作数是undefined，则返回undefined</li>\n</ul>\n</li>\n<li>逻辑或遵循规则<ul>\n<li>如果第一个操作数是对象，则返回第一个操作数</li>\n<li>如果第一个操作数是求值结果为false，则返回第二个操作数</li>\n<li>如果两个操作数都是对象，则返回第一个操作数</li>\n<li>如果两个操作数都是null，则返回null</li>\n<li>如果两个操作数都是NaN，则返回NaN</li>\n<li>如果两个操作数都是undefined，则返回undefined</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"乘性操作符\"><a href=\"#乘性操作符\" class=\"headerlink\" title=\"乘性操作符(*,/,%)\"></a>乘性操作符(*,/,%)</h3><p>在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转换为数值。也就是说，空字符串将被当作0，布尔值true将被当作1。</p>\n<ol>\n<li><p>乘法</p>\n<ul>\n<li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；</li>\n<li>如果有一个操作数是NaN，则结果是NaN；</li>\n<li>如果是Infinity与0相乘，则结果是NaN；</li>\n<li>如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>\n<li>如果是Infinity与Infinity相乘，则结果是Infinity；</li>\n<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的 规则。</li>\n</ul>\n</li>\n<li><p>除法</p>\n<ul>\n<li>如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；</li>\n<li>如果有一个操作数是NaN，则结果是NaN；</li>\n<li>如果是Infinity被Infinity除，则结果是NaN；</li>\n<li>如果是零被零除，则结果是NaN；</li>\n<li>如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>\n<li>如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>\n<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的 规则。</li>\n</ul>\n</li>\n<li><p>求模</p>\n<ul>\n<li>如果操作数都是数值，执行常规的除法计算，返回除得的余数；</li>\n<li>如果被除数是无穷大值而除数是有限大的数值，返回NaN；</li>\n<li>如果被除数是有限大的数值而除数是零，返回NaN；</li>\n<li>如果Infinity被Infinity除，返回NaN；</li>\n<li>如果被除数是有限大的数值而除数是无穷大值，返回被除数；</li>\n<li>如果被除数是零，返回零；</li>\n<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的 规则。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"加性操作符\"><a href=\"#加性操作符\" class=\"headerlink\" title=\"加性操作符(+,-)\"></a>加性操作符(+,-)</h3><ol>\n<li><p>加法</p>\n<ul>\n<li>如果有一个操作数是NaN，则结果是NaN；</li>\n<li>如果是Infinity加Infinity，则结果是Infinity；</li>\n<li>如果是-Infinity加-Infinity，则结果是-Infinity；</li>\n<li>如果是Infinity加-Infinity，则结果是NaN；</li>\n<li>如果是+0加+0，则结果是+0；</li>\n<li>如果是-0加-0，则结果是-0；</li>\n<li>如果是+0加-0，则结果是+0。</li>\n</ul>\n</li>\n<li><p>如果有一个操作数是字符串，那么就要应用如下规则：</p>\n<ul>\n<li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li>\n<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接 起来。<br>如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于undefined和null，则分别调用String()函数并取得字 符串”undefined”和”null”。</li>\n</ul>\n</li>\n<li><p>减法</p>\n<ul>\n<li>如果两个操作数都是数值，则执行常规的算术减法操作并返回结果；</li>\n<li>如果有一个操作数是NaN，则结果是NaN；</li>\n<li>如果是Infinity减Infinity，则结果是NaN；</li>\n<li>如果是-Infinity减-Infinity，则结果是NaN；</li>\n<li>如果是Infinity减-Infinity，则结果是Infinity；</li>\n<li>如果是-Infinity减Infinity，则结果是-Infinity；</li>\n<li>如果是+0减+0，则结果是+0；</li>\n<li>如果是+0减-0，则结果是-0；</li>\n<li>如果是-0减-0，则结果是+0；</li>\n<li>如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；</li>\n<li>如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关系操作符-gt-lt-gt-lt\"><a href=\"#关系操作符-gt-lt-gt-lt\" class=\"headerlink\" title=\"关系操作符(&gt;,&lt;,&gt;=,&lt;=)\"></a>关系操作符(&gt;,&lt;,&gt;=,&lt;=)</h3><ol>\n<li>对于字符串实际比较的是两个字符串中对应位置的每个字符的字符编码值  <ul>\n<li>如果两个操作数都是数值，则执行数值比较。</li>\n<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li>\n<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li>\n<li>如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。</li>\n<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li>\n<li>任何操作数与NaN比较都将返回false</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"相等操作符\"><a href=\"#相等操作符\" class=\"headerlink\" title=\"相等操作符(=\\==,!\\==,==,!=)\"></a>相等操作符(=\\==,!\\==,==,!=)</h3><ol>\n<li><p>相等和不相等——先转换再比较，全等和不全等——仅比较而不转换。</p>\n</li>\n<li><p>在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：</p>\n<ul>\n<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；</li>\n<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li>\n<li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较； 这两个操作符在进行比较时则要遵循下列规则。<br>null和undefined是相等的。</li>\n<li>要比较相等性之前，不能将null和undefined转换成其他任何值。</li>\n<li>如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。</li>\n<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"条件操作符-boolean-expression-true-value-false-value\"><a href=\"#条件操作符-boolean-expression-true-value-false-value\" class=\"headerlink\" title=\"条件操作符(boolean_expression?true_value:false_value)\"></a>条件操作符(boolean_expression?true_value:false_value)</h3><h3 id=\"逗号操作符\"><a href=\"#逗号操作符\" class=\"headerlink\" title=\"逗号操作符(,)\"></a>逗号操作符(,)</h3><h3 id=\"赋值操作符-以及-、-等复合赋值运算符\"><a href=\"#赋值操作符-以及-、-等复合赋值运算符\" class=\"headerlink\" title=\"赋值操作符(=以及*=、+=等复合赋值运算符)\"></a>赋值操作符(=以及*=、+=等复合赋值运算符)</h3><h3 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h3><ol>\n<li>解构只能用于数组或对象。其他原始类型的值都可以转为相应的对象，但是，undefined和null不能转为对象，因此报错。</li>\n<li>如果解构不成功，变量的值就等于undefined。</li>\n<li>不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</li>\n<li><p>解构赋值允许指定默认值。</p>\n<blockquote>\n<p>注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p>\n</blockquote>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var [x = 1] = [undefined];// x = 1</div><div class=\"line\">var [x = 1] = [null]; //x = null</div></pre></td></tr></table></figure>\n</li>\n<li><p>只要某种数据结构具有Iterable接口，都可以采用数组形式的解构赋值。</p>\n</li>\n<li><p>解构不仅可以用于数组，还可以用于对象。而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; //baz = &quot;aaa&quot;</div><div class=\"line\">let &#123; log, sin, cos &#125; = Math;</div><div class=\"line\">const [a, b, c, d, e] = &apos;hello&apos;;//a = &quot;h&quot;, b = &quot;e&quot;, c = &quot;l&quot;, d = &quot;l&quot;, e = &quot;o&quot;</div><div class=\"line\">let &#123;length : len&#125; = &apos;hello&apos;; //len = 5</div></pre></td></tr></table></figure>\n</li>\n<li><p>函数的参数也可以使用解构。</p>\n</li>\n<li><p>函数参数的解构也可以使用默认值。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</div><div class=\"line\">  return [x, y];</div><div class=\"line\">&#125;</div><div class=\"line\">move(&#123;x: 3, y: 8&#125;); // [3, 8]</div><div class=\"line\">move(&#123;x: 3&#125;); // [3, 0]</div><div class=\"line\">move(&#123;&#125;); // [0, 0]</div><div class=\"line\">move(); // [0, 0]</div></pre></td></tr></table></figure>\n<p> <strong>注意，指定函数参数的默认值时，不能采用下面的写法。</strong><br> 会得到与前一种写法不同的结果。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span>(<span class=\"params\">&#123;x, y&#125; = &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125;</span>) </span>&#123;</div><div class=\"line\"> <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div><div class=\"line\">move(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">8</span>&#125;); <span class=\"comment\">// [3, 8]</span></div><div class=\"line\">move(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>&#125;); <span class=\"comment\">// [3, undefined]</span></div><div class=\"line\">move(&#123;&#125;); <span class=\"comment\">// [undefined, undefined]</span></div><div class=\"line\">move(); <span class=\"comment\">// [0, 0]</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>用途</p>\n<ul>\n<li><p>交换变量的值</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[x, y] = [y, x];</div></pre></td></tr></table></figure>\n</li>\n<li><p>从函数返回多个值</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 返回一个数组</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> [a, b, c] = example();</div><div class=\"line\"><span class=\"comment\">// 返回一个对象</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    foo: <span class=\"number\">1</span>,</div><div class=\"line\">    bar: <span class=\"number\">2</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure>\n</li>\n<li><p>函数参数的定义<br>解构赋值可以方便地将一组参数与变量名对应起来。</p>\n</li>\n<li>提取JSON数据</li>\n<li>函数参数的默认值</li>\n<li><p>遍历Map结构</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var map = new Map();</div><div class=\"line\">map.set(&apos;first&apos;, &apos;hello&apos;);</div><div class=\"line\">map.set(&apos;second&apos;, &apos;world&apos;);</div><div class=\"line\"></div><div class=\"line\">for (let [key, value] of map) &#123;</div><div class=\"line\">  console.log(key + &quot; is &quot; + value);</div><div class=\"line\">&#125;</div><div class=\"line\">// first is hello</div><div class=\"line\">// second is world</div><div class=\"line\"></div><div class=\"line\">// 获取键名</div><div class=\"line\">for (let [key] of map) &#123;</div><div class=\"line\">  // ...</div><div class=\"line\">&#125;</div><div class=\"line\">// 获取键值</div><div class=\"line\">for (let [,value] of map) &#123;</div><div class=\"line\">  // ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>输入模块的指定方法<br>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p>\n</li>\n</ul>\n</li>\n<li><p>将一个已经声明的变量用于解构赋值，必须非常小心。因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 错误的写法</div><div class=\"line\">let x;</div><div class=\"line\">&#123;x&#125; = &#123;x: 1&#125;;</div><div class=\"line\">// 正确的写法</div><div class=\"line\">(&#123;x&#125; = &#123;x: 1&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>\n</li>\n</ol>\n<h2 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h2><ol>\n<li>break和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下</li>\n<li>switch语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串”10”不等于数值10）。</li>\n<li>可以在switch语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个case的值不一定是常量，可以是变量，甚至是表达式。</li>\n</ol>\n<h3 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for-in\"></a>for-in</h3><ol>\n<li><strong>ECMAScript对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的.</strong></li>\n<li>for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。</li>\n<li>建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。</li>\n</ol>\n<h3 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h3><p>严格模式下无效</p>\n<h3 id=\"for-of\"><a href=\"#for-of\" class=\"headerlink\" title=\"for-of\"></a>for-of</h3><ol>\n<li>ES6提供for…of循环，允许遍历获得键值。</li>\n<li>一个数据结构只要部署了Symbol.iterator方法，就被视为具有Iterable接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</li>\n<li>for…of循环可以使用的范围包括数组、Set和Map结构及其entries,values,keys方法返回的对象、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串。</li>\n<li>遍历无iterator接口的类数组时, 使用Array.from方法将其转为数组。</li>\n<li>遍历对象时, Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。</li>\n<li>与其他遍历方法的比较<ul>\n<li>for循环比较麻烦</li>\n<li>forEach无法调处循环</li>\n<li>for…in循环有几个缺点。<ol>\n<li>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。</li>\n<li>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li>\n<li>某些情况下，for…in循环会以任意顺序遍历键名。</li>\n</ol>\n</li>\n<li>for…of循环相比上面几种做法，有一些显著的优点。<ol>\n<li>有着同for…in一样的简洁语法，但是没有for…in那些缺点。</li>\n<li>不同用于forEach方法，它可以与break、continue和return配合使用。</li>\n<li>提供了遍历所有数据结构的统一操作接口。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><ol>\n<li>return语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined值。</li>\n<li>arguments对象只是与数组类似（它并不是Array的实例）</li>\n<li>arguments对象为其内部属性以及函数形式参数创建getter和setter函数。因此改变形参的值会影响arguments对象的值，但是严格模式不允许创建getter和setter方法。</li>\n<li>严格模式下: <ul>\n<li>如何使用 arguments 对象做出了一些限制</li>\n<li>不能把函数或参数命名为eval或arguments；</li>\n</ul>\n</li>\n<li>没有重载<br>没有函数签名，真正的重载是不可能做到的。 如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。</li>\n</ol>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>一个函数内表示一个作用域范围<br>局部变量：在函数内部创建的变量（局部变量随函数调用而创建，随调用完而释放）；局部变量有两种，一种是函数参数（在函数内定义的参数才是局部变量），另一种是函数内用var/let/const声明的</p>\n<p>作用域有两种：</p>\n<ol>\n<li>全局作用域：最外层函数和最外层函数外面定义的变量、所有未定义直接赋值的变量、所有windows对象的属性拥有全局作用域</li>\n<li>局部作用域：函数内部定义的变量，只能在函数内部访问到</li>\n</ol>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>JavaScript的内部属性[Scope]包含了函数被创建的作用域中对象的集合，这个集合就是函数的作用域链，它决定了那些数据可以访问</p>\n<p>当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充；作用域链是保证对执行环境有权访问的所有变量和函数的有序访问，最前端是当前执行的代码所在环境的变量对象，下一个变量对象来自外部环境，再下一个来自下一个包含环境，全局执行环境的变量对象是作用域链中的最后一个对象</p>\n<p><strong>with和try catch语句会改变作用域链</strong></p>\n<h3 id=\"执行环境\"><a href=\"#执行环境\" class=\"headerlink\" title=\"执行环境\"></a>执行环境</h3><p>每一个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，解析器在处理数据时会在后台使用它<br>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境</p>\n<p>执行环境被创建时，作用域链就会初始化为当前运行函数的[[Scope]]所包含的对象，这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当执行环境被销毁，活动对象也随之销毁</p>\n<h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h3><p>定义未指定函数名称的函数<br>何时使用匿名函数：如果一个函数仅临时使用一次</p>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3><p>this：是唯一的一个引用关键字。始终指向程序当前正在使用的对象,this仅用于函数内。</p>\n<ol>\n<li>this和定义在哪无关，仅和调用时的对象有关（指离方法最近的那个对象）</li>\n<li>匿名函数自调，其中this也指向window</li>\n<li>全局函数：this，始终指向window对象 </li>\n<li>对象的方法：this，始终指向调用方法的对象</li>\n<li>构造函数中的this：指刚创建的新对象</li>\n<li>若没有明确指定调用对象（尽管在函数内部），this指代window</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name); <span class=\"comment\">//this指向 new正在创建的对象Student</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> lilei=<span class=\"keyword\">new</span> Student(<span class=\"string\">\"Li Lei\"</span>);  <span class=\"comment\">//Li Lei</span></div><div class=\"line\"><span class=\"keyword\">var</span> eric=<span class=\"keyword\">new</span> Student(<span class=\"string\">\"Eric\"</span>);  <span class=\"comment\">// Eric</span></div><div class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">\"global variable\"</span>; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">method</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(v); </div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.v); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"keyword\">var</span> Class1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\">\t<span class=\"keyword\">var</span> v = <span class=\"string\">\"private variable\"</span>; </div><div class=\"line\">\t<span class=\"keyword\">this</span>.v = <span class=\"string\">\"object variable\"</span>; </div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> method2 = method; </div><div class=\"line\">\t<span class=\"keyword\">this</span>.method2 = method; </div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> method3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(v); </div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.v); </div><div class=\"line\">\t&#125; </div><div class=\"line\">\t<span class=\"keyword\">this</span>.method3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(v); </div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.v); </div><div class=\"line\">\t&#125; </div><div class=\"line\">\tmethod2(); <span class=\"comment\">//g,g；method全局函数在故都是g</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.method2(); <span class=\"comment\">//g,o method全局函数，故第一个是g，第二个受this影响，是o</span></div><div class=\"line\">\tmethod3(); <span class=\"comment\">//p,g 局部函数，第一个变量取局部，第二个受this影响，指向window是g</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.method3();<span class=\"comment\">//p,o局部函数，第一个局部p，第二个this指class1，为o</span></div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Class1(); </div><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"window\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> Bob = &#123;</div><div class=\"line\">    name: <span class=\"string\">\"Bob\"</span>,</div><div class=\"line\">    showName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        alert(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> Tom = &#123;</div><div class=\"line\">    name: <span class=\"string\">\"Tom\"</span>,</div><div class=\"line\">    showName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> fun = Bob.showName;</div><div class=\"line\">        fun();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">Tom.showName();<span class=\"comment\">//window，实际执行的是fun()，而fun()的调用对象为window</span></div></pre></td></tr></table></figure>\n<h3 id=\"this、执行上下文、作用域、变量、对象属性\"><a href=\"#this、执行上下文、作用域、变量、对象属性\" class=\"headerlink\" title=\"this、执行上下文、作用域、变量、对象属性\"></a>this、执行上下文、作用域、变量、对象属性</h3><h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>this指代当前函数运行所在的执行上下文（执行环境），执行上下文也是对象，我叫它环境对象；<br>每一个环境对象都有与之关联的变量对象，环境对象中所有定义的函数和变量都存在这个变量对象中；<br>变量对象在函数运行时临时创建，被函数的作用域链引用，作用域链的最顶端称为活动对象，最底端为window对象；<br>环境对象（执行上下文this）是在函数运行时临时创建的，指向调用该函数的对象，且随时可能改变</p>\n<h4 id=\"函数创建和运行\"><a href=\"#函数创建和运行\" class=\"headerlink\" title=\"函数创建和运行\"></a>函数创建和运行</h4><ol>\n<li>建立变量对象:<ol>\n<li>建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值</li>\n<li>检查当前上下文中的函数声明：每找到一个函数声明，就在变量对象下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用；如果上述函数名已经存在于变量对象下，那么对应的属性值会被新的引用所覆盖。</li>\n<li>检查当前上下文中的变量声明：每找到一个变量的声明，就在变量对象下，用变量名建立一个属性，属性值为undefined。如果该变量名已经存在于变量对象属性中，直接跳过(防止指向函数的属性的值被变量属性覆盖为undefined)，原属性值不会被修改。</li>\n</ol>\n</li>\n<li>初始化作用域链</li>\n<li>确定上下文中this的指向对象</li>\n<li>代码执行阶段:执行函数体中的代码，一行一行地运行代码，给变量中的变量属性赋值。</li>\n</ol>\n<h4 id=\"变量和对象属性\"><a href=\"#变量和对象属性\" class=\"headerlink\" title=\"变量和对象属性\"></a>变量和对象属性</h4><p>变量在定义时就已经确定，其作用域永远不会变；变量的查找是通过作用域链的，不受this影响，仅受使用该变量的方法所在的作用域影响;<br>对象属性是存在于实例对象中，查找时受this影响，先从this指向的对象查找，再通过原型链查找</p>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ol>\n<li>使用注意点<ul>\n<li>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。</li>\n<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>\n<li>不可以使用arguments对象，该对象在函数体内不存在。</li>\n<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Generator-函数\"><a href=\"#Generator-函数\" class=\"headerlink\" title=\"Generator 函数\"></a>Generator 函数</h2><h3 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ol>\n<li>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</li>\n<li>Generator函数有多种理解角度。从语法上，首先可以把它理解成==一个函数的内部状态的遍历器==（也就是说，Generator函数是一个状态机）。它每调用一次，就进入下一个内部状态。Generator函数可以控制内部状态的变化，依次遍历这些状态。</li>\n<li><p>有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义遍历器的每个成员，即不同的内部状态（yield语句在英语里的意思就是“产出”）。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* helloWorldGenerator() &#123;</div><div class=\"line\">  yield &apos;hello&apos;;</div><div class=\"line\">  yield &apos;world&apos;;</div><div class=\"line\">  return &apos;ending&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var hw = helloWorldGenerator();</div><div class=\"line\"></div><div class=\"line\">hw.next() // &#123; value: &apos;hello&apos;, done: false &#125;</div><div class=\"line\">hw.next() // &#123; value: &apos;world&apos;, done: false &#125;</div><div class=\"line\">hw.next() // &#123; value: &apos;ending&apos;, done: true &#125;</div><div class=\"line\">hw.next() // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>调用该函数后, 返回一个Iterator对象（该对象同时实现了Iterable接口，并且调用该对象的Symbol.iterator方法返回该对象自身）。</p>\n<p> 调用Iterator对象的next方法，使得指针移向下一个状态。每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield命令是暂停执行的标记，而next方法可以恢复执行。</p>\n<p> 总结一下，调用Generator函数，返回一个实现了Iterator接口的对象，用来操作内部指针。以后，每次调用Iterator对象的next方法，就会返回一个实现了IteratorResult接口的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>\n</li>\n</ol>\n<h3 id=\"yield语句\"><a href=\"#yield语句\" class=\"headerlink\" title=\"yield语句\"></a>yield语句</h3><p>Iterator对象next方法的运行逻辑如下。</p>\n<ol>\n<li>遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li>\n<li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。</li>\n<li>如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li>\n<li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li>\n</ol>\n<p>yield语句不能用在普通函数中，否则会报错。</p>\n<h3 id=\"与Iterator的关系\"><a href=\"#与Iterator的关系\" class=\"headerlink\" title=\"与Iterator的关系\"></a>与Iterator的关系</h3><p>调用Generator函数返回一个Iterator对象。这里的Iterator对象也实现了Iterable接口，Symbol.iterator方法执行后，返回自身。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* gen()&#123;</div><div class=\"line\"> // some code</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">var i = gen();</div><div class=\"line\">    </div><div class=\"line\">i[Symbol.iterator]() === i // true</div></pre></td></tr></table></figure>\n<h3 id=\"next方法的参数\"><a href=\"#next方法的参数\" class=\"headerlink\" title=\"next方法的参数\"></a>next方法的参数</h3><ol>\n<li><p>yield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* foo(x) &#123;</div><div class=\"line\">  var y = 2 * (yield (x + 1));</div><div class=\"line\">  var z = yield (y / 3);</div><div class=\"line\">  return (x + y + z);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var it = foo(5);</div><div class=\"line\"></div><div class=\"line\">it.next() // &#123; value:6, done:false &#125;</div><div class=\"line\">it.next(12) // &#123; value:8, done:false &#125;</div><div class=\"line\">it.next(13) // &#123; value:42, done:true &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li>Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</li>\n<li>由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。</li>\n</ol>\n<h3 id=\"for…of循环\"><a href=\"#for…of循环\" class=\"headerlink\" title=\"for…of循环\"></a>for…of循环</h3><p>for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function *foo() &#123;</div><div class=\"line\"> yield 1;</div><div class=\"line\"> yield 2;</div><div class=\"line\"> yield 3;</div><div class=\"line\"> yield 4;</div><div class=\"line\"> yield 5;</div><div class=\"line\"> return 6;</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">for (let v of foo()) &#123;</div><div class=\"line\"> console.log(v);</div><div class=\"line\">&#125;</div><div class=\"line\">// 1 2 3 4 5</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。</p>\n</blockquote>\n<h3 id=\"throw方法\"><a href=\"#throw方法\" class=\"headerlink\" title=\"throw方法\"></a>throw方法</h3><p>Generator函数还有一个特点，它可以在函数体外抛出错误，然后在函数体内捕获。<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var g = function* () &#123;</div><div class=\"line\">  while (true) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">      yield;</div><div class=\"line\">    &#125; catch (e) &#123;</div><div class=\"line\">      if (e != &apos;a&apos;) throw e;</div><div class=\"line\">      console.log(&apos;内部捕获&apos;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var i = g();</div><div class=\"line\">i.next();</div><div class=\"line\"></div><div class=\"line\">try &#123;</div><div class=\"line\">  i.throw(&apos;a&apos;);</div><div class=\"line\">  i.throw(&apos;b&apos;);</div><div class=\"line\">&#125; catch (e) &#123;</div><div class=\"line\">  console.log(&apos;外部捕获&apos;, e);</div><div class=\"line\">&#125;</div><div class=\"line\">// 内部捕获 a</div><div class=\"line\">// 外部捕获 b</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>迭代器i连续抛出两个错误。第一个错误被Generator函数体内的catch捕获，然后Generator函数执行完成，于是第二个错误被函数体外的catch捕获。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var gen = function* gen()&#123;</div><div class=\"line\">  yield console.log(&apos;hello&apos;);</div><div class=\"line\">  yield console.log(&apos;world&apos;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var g = gen();</div><div class=\"line\">g.next();</div><div class=\"line\"></div><div class=\"line\">try &#123;</div><div class=\"line\">  g.throw(); // 会终止遍历器</div><div class=\"line\">&#125; catch (e) &#123;</div><div class=\"line\">  g.next();</div><div class=\"line\">&#125;</div><div class=\"line\">// hello</div></pre></td></tr></table></figure>\n<blockquote>\n<p>上面代码只输出hello就结束了，因为第二次调用next方法时，遍历器状态已经变成终止了。但是，如果使用throw命令抛出错误，不会影响遍历器状态。</p>\n</blockquote>\n<p>这种函数体内捕获错误的机制，大大方便了对错误的处理。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数写一个错误处理语句。</p>\n<p>使用Generator函数可以大大简化错误捕获。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* g()&#123;</div><div class=\"line\">  try &#123;</div><div class=\"line\">    var a = yield foo(&apos;a&apos;);</div><div class=\"line\">    var b = yield foo(&apos;b&apos;);</div><div class=\"line\">    var c = yield foo(&apos;c&apos;);</div><div class=\"line\">  &#125; catch (e) &#123;</div><div class=\"line\">    console.log(e);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  console.log(a, b, c);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>反过来，Generator函数内抛出的错误，也可以被函数体外的catch捕获。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function *foo() &#123;</div><div class=\"line\">  var x = yield 3;</div><div class=\"line\">  var y = x.toUpperCase();</div><div class=\"line\">  yield y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var it = foo();</div><div class=\"line\"></div><div class=\"line\">it.next(); // &#123; value:3, done:false &#125;</div><div class=\"line\"></div><div class=\"line\">try &#123;</div><div class=\"line\">  it.next(42);</div><div class=\"line\">&#125; catch (err) &#123;</div><div class=\"line\">  console.log(err);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>一旦Generator执行过程中抛出错误，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。</strong></p>\n<h3 id=\"yield-语句\"><a href=\"#yield-语句\" class=\"headerlink\" title=\"yield*语句\"></a>yield*语句</h3><p>如果yield命令后面跟的是一个Iterable对象，需要在yield命令后面加上星号，表明它返回的是一个Iterable对象。这被称为yield*语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">let delegatedIterator = (function* () &#123;</div><div class=\"line\">  yield &apos;Hello!&apos;;</div><div class=\"line\">  yield &apos;Bye!&apos;;</div><div class=\"line\">&#125;());</div><div class=\"line\"></div><div class=\"line\">let delegatingIterator = (function* () &#123;</div><div class=\"line\">  yield &apos;Greetings!&apos;;</div><div class=\"line\">  yield* delegatedIterator;</div><div class=\"line\">  yield &apos;Ok, bye.&apos;;</div><div class=\"line\">&#125;());</div><div class=\"line\"></div><div class=\"line\">for(let value of delegatingIterator) &#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;</div><div class=\"line\">// &quot;Greetings!</div><div class=\"line\">// &quot;Hello!&quot;</div><div class=\"line\">// &quot;Bye!&quot;</div><div class=\"line\">// &quot;Ok, bye.&quot;</div></pre></td></tr></table></figure>\n<ol>\n<li><strong>yield*语句等同于在Generator函数内部，部署一个for…of循环。</strong></li>\n<li>如果yield*后面跟着一个数组，由于数组原生支持Iterable对象，因此就会遍历数组成员。</li>\n<li>yield命令后面如果不加星号，返回的是整个值，加了星号就表示返回的是Iterable对象。</li>\n<li>yield*命令可以很方便地取出嵌套数组的所有成员。(遍历二叉树等)</li>\n</ol>\n<h3 id=\"作为对象属性的Generator函数\"><a href=\"#作为对象属性的Generator函数\" class=\"headerlink\" title=\"作为对象属性的Generator函数\"></a>作为对象属性的Generator函数</h3><p>如果一个对象的属性是Generator函数，可以简写成下面的形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">let obj = &#123;</div><div class=\"line\">  * myGeneratorMethod() &#123;</div><div class=\"line\">    ···</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">let obj = &#123;</div><div class=\"line\">  myGeneratorMethod: function* () &#123;</div><div class=\"line\">    // ···</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"构造函数是Generator函数\"><a href=\"#构造函数是Generator函数\" class=\"headerlink\" title=\"构造函数是Generator函数\"></a>构造函数是Generator函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* F()&#123;</div><div class=\"line\">  yield this.x = 2;</div><div class=\"line\">  yield this.y = 3;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">&apos;next&apos; in (new F()) // true</div><div class=\"line\"></div><div class=\"line\">//可以生成一个空对象，使用bind方法绑定F内部的this。这样，构造函数调用以后，这个空对象就是F的实例对象了。</div><div class=\"line\">var obj = &#123;&#125;;</div><div class=\"line\">var f = F.bind(obj)();</div><div class=\"line\"></div><div class=\"line\">f.next();</div><div class=\"line\">f.next();</div><div class=\"line\">f.next();</div><div class=\"line\"></div><div class=\"line\">console.log(obj); // &#123; x: 2, y: 3 &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Generator函数推导\"><a href=\"#Generator函数推导\" class=\"headerlink\" title=\"Generator函数推导\"></a>Generator函数推导</h3><p>ES7在数组推导的基础上，提出了Generator函数推导（Generator comprehension）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">let generator = function* () &#123;</div><div class=\"line\">  for (let i = 0; i &lt; 6; i++) &#123;</div><div class=\"line\">    yield i;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let squared = ( for (n of generator()) n * n );</div><div class=\"line\">// 等同于</div><div class=\"line\">// let squared = Array.from(generator()).map(n =&gt; n * n);</div><div class=\"line\"></div><div class=\"line\">console.log(...squared); // 0 1 4 9 16 25</div></pre></td></tr></table></figure>\n<p>“推导”这种语法结构，不仅可以用于数组，ES7将其推广到了Generator函数。for…of循环会自动调用Iterator对象的next方法，将返回值的value属性作为数组的一个成员。</p>\n<p>Generator函数推导是对数组结构的一种模拟，它的最大优点是惰性求值，即直到真正用到时才会求值，这样可以保证效率。请看下面的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">let bigArray = new Array(100000);</div><div class=\"line\">for (let i = 0; i &lt; 100000; i++) &#123;</div><div class=\"line\">  bigArray[i] = i;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let first = bigArray.map(n =&gt; n * n)[0];</div><div class=\"line\">console.log(first);</div></pre></td></tr></table></figure>\n<p>上面例子遍历一个大数组，但是在真正遍历之前，这个数组已经生成了，占用了系统资源。如果改用Generator函数推导，就能避免这一点。下面代码只在用到时，才会生成一个大数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">let bigGenerator = function* () &#123;</div><div class=\"line\">  for (let i = 0; i &lt; 100000; i++) &#123;</div><div class=\"line\">    yield i;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">let squared = ( for (n of bigGenerator()) n * n );</div><div class=\"line\"></div><div class=\"line\">console.log(squared.next());</div></pre></td></tr></table></figure>\n<h3 id=\"Generator与状态机\"><a href=\"#Generator与状态机\" class=\"headerlink\" title=\"Generator与状态机\"></a>Generator与状态机</h3><p>Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ticking = true;</div><div class=\"line\">var clock = function() &#123;</div><div class=\"line\">  if (ticking)</div><div class=\"line\">    console.log(&apos;Tick!&apos;);</div><div class=\"line\">  else</div><div class=\"line\">    console.log(&apos;Tock!&apos;);</div><div class=\"line\">  ticking = !ticking;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用Generator实现，就是下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var clock = function*(_) &#123;</div><div class=\"line\">  while (true) &#123;</div><div class=\"line\">    yield _;</div><div class=\"line\">    console.log(&apos;Tick!&apos;);</div><div class=\"line\">    yield _;</div><div class=\"line\">    console.log(&apos;Tock!&apos;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p>\n<h3 id=\"Generator与协程\"><a href=\"#Generator与协程\" class=\"headerlink\" title=\"Generator与协程\"></a>Generator与协程</h3><p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p>\n<ol>\n<li>协程与子例程的差异</li>\n</ol>\n<p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>\n<p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p>\n<ol>\n<li>协程与普通线程的差异</li>\n</ol>\n<p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>\n<p>由于ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p>\n<p>Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>\n<p>如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><ol>\n<li>异步操作的同步化表达</li>\n</ol>\n<p>Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>\n<ol>\n<li>控制流管理</li>\n</ol>\n<p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p>\n<ol>\n<li>部署Iterable接口</li>\n</ol>\n<p>利用Generator函数，可以在任意对象上部署Iterable接口。</p>\n<ol>\n<li>作为数据结构</li>\n</ol>\n<p>Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p>\n<h2 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。</p>\n<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>\n<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>\n<p>“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>\n<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>\n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>\n<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>\n<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function factorial(n, total = 1) &#123;</div><div class=\"line\">  if (n === 1) return total;</div><div class=\"line\">  return factorial(n - 1, n * total);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">factorial(5) // 120</div></pre></td></tr></table></figure>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><h3 id=\"export命令\"><a href=\"#export命令\" class=\"headerlink\" title=\"export命令\"></a>export命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// profile.js</div><div class=\"line\">export var name = &apos;Michael&apos;;</div><div class=\"line\">export var year = 1958;</div><div class=\"line\"></div><div class=\"line\">var name = &apos;Michael&apos;;</div><div class=\"line\">var year = 1958;</div><div class=\"line\"></div><div class=\"line\">export &#123;name, year&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"import命令\"><a href=\"#import命令\" class=\"headerlink\" title=\"import命令\"></a>import命令</h3><ol>\n<li>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// main.js</div><div class=\"line\">import &#123;name, year&#125; from &apos;./profile&apos;;</div><div class=\"line\"></div><div class=\"line\">function setHeader(element) &#123;</div><div class=\"line\">  element.textContent = name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>如果想为输入的变量重新取一个名字，import语句中要使用as关键字，将输入的变量重命名。</li>\n<li>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">export &#123; es6 as default &#125; from &apos;./someModule&apos;;</div><div class=\"line\"></div><div class=\"line\">// 等同于</div><div class=\"line\">import &#123; es6 &#125; from &apos;./someModule&apos;;</div><div class=\"line\">export default es6;</div></pre></td></tr></table></figure>\n<h3 id=\"模块的整体输入\"><a href=\"#模块的整体输入\" class=\"headerlink\" title=\"模块的整体输入\"></a>模块的整体输入</h3><p>使用*号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// main.js</div><div class=\"line\">import * as circle from &apos;circle&apos;;</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;圆面积：&quot; + circle.area(4));</div><div class=\"line\">console.log(&quot;圆周长：&quot; + circle.circumference(14));</div></pre></td></tr></table></figure>\n<h3 id=\"module命令\"><a href=\"#module命令\" class=\"headerlink\" title=\"module命令\"></a>module命令</h3><p>module命令可以取代import语句，达到整体输入模块的作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// main.js</div><div class=\"line\">module circle from &apos;circle&apos;;</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;圆面积：&quot; + circle.area(4));</div><div class=\"line\">console.log(&quot;圆周长：&quot; + circle.circumference(14));</div></pre></td></tr></table></figure>\n<h3 id=\"export-default命令\"><a href=\"#export-default命令\" class=\"headerlink\" title=\"export default命令\"></a>export default命令</h3><ol>\n<li>export default命令，为模块指定默认输出。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// export-default.js</div><div class=\"line\">export default function () &#123;</div><div class=\"line\">  console.log(&apos;foo&apos;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// import-default.js</div><div class=\"line\">import customName from &apos;./export-default&apos;;</div><div class=\"line\">customName(); // &apos;foo&apos;</div></pre></td></tr></table></figure>\n<p><strong>需要注意的是，这时import命令后面，不使用大括号。</strong></p>\n<ol>\n<li>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export deault命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</li>\n<li>本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。</li>\n</ol>\n<h3 id=\"模块的继承\"><a href=\"#模块的继承\" class=\"headerlink\" title=\"模块的继承\"></a>模块的继承</h3><p>模块之间也可以继承。</p>\n<p>假设有一个circleplus模块，继承了circle模块。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// circleplus.js</div><div class=\"line\">export * from &apos;circle&apos;;</div><div class=\"line\">export var e = 2.71828182846;</div><div class=\"line\">export default function(x) &#123;</div><div class=\"line\">    return Math.exp(x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><h3 id=\"try-catch-语句\"><a href=\"#try-catch-语句\" class=\"headerlink\" title=\"try-catch 语句\"></a>try-catch 语句</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">try&#123;</div><div class=\"line\">// 可能会导致错误的代码</div><div class=\"line\">&#125; catch(error)&#123;</div><div class=\"line\">// 在错误发生时怎么处理</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>内置使用内置的Error对象具有两个标准属性name和message</p>\n<ul>\n<li>name：错误名称</li>\n<li>message：错误提示信息</li>\n<li>stack：错误的堆栈（非标准属性，但是大多数平台支持）</li>\n</ul>\n<h3 id=\"finally-子句\"><a href=\"#finally-子句\" class=\"headerlink\" title=\"finally 子句\"></a>finally 子句</h3><p>finally都是可选的，但 finally 子句一经使用,其代码无论如何都会执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function fn()&#123;</div><div class=\"line\">  try &#123;</div><div class=\"line\">    var x = 1;</div><div class=\"line\">    throw new Error(&apos;error&apos;);</div><div class=\"line\">  &#125; catch (e) &#123;</div><div class=\"line\">    console.log(&apos;x=&apos; + x);</div><div class=\"line\">    return x;</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    x = 2;</div><div class=\"line\">    console.log(&apos;x=&apos; + x);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码说明，即使有return语句在前，finally代码块依然会得到执行，且在其执行完毕后，并不影响return语句要返回的值。</p>\n<h3 id=\"错误类型\"><a href=\"#错误类型\" class=\"headerlink\" title=\"错误类型\"></a>错误类型</h3><ol>\n<li>EvalError<br> 如果没有把 eval() 当成函数调用,就会抛出EvalError错误。一些浏览器不会正确抛出这个错误。</li>\n<li>RangeError<br> 当一个值超出有效范围时发生的错误。</li>\n<li>ReferenceError<br> 引用一个不存在的变量时发生的错误</li>\n<li>SyntaxError<br> 解析代码时发生的语法错误。</li>\n<li>TypeError<br> 变量或参数不是预期类型时发生的错误。</li>\n<li>URIError<br> URI相关函数的参数不正确时抛出的错误</li>\n</ol>\n<h3 id=\"抛出错误\"><a href=\"#抛出错误\" class=\"headerlink\" title=\"抛出错误\"></a>抛出错误</h3><ol>\n<li>与 try-catch 语句相配的还有一个 throw 操作符,用于随时抛出自定义错误。抛出错误时,必须要给 throw 操作符指定一个值,这个值是什么类型,没有要求。</li>\n<li>另外,利用原型链还可以通过继承 Error 来创建自定义错误类型</li>\n</ol>\n<h3 id=\"错误-error-事件\"><a href=\"#错误-error-事件\" class=\"headerlink\" title=\"错误( error )事件\"></a>错误( error )事件</h3><ol>\n<li>任何没有通过 try-catch 处理的错误都会触发 window 对象的 error 事件</li>\n<li>只要发生错误,无论是不是浏览器生成的,都会触发 error 事件,并执行这个事件处理程序。</li>\n<li>图像也支持 error 事件。只要图像的 src 特性中的 URL 不能返回可以被识别的图像格式,就会触发 error 事件。</li>\n</ol>\n<h1 id=\"变量、作用域和内存问题\"><a href=\"#变量、作用域和内存问题\" class=\"headerlink\" title=\"变量、作用域和内存问题\"></a>变量、作用域和内存问题</h1><h2 id=\"基本类型和引用类型的值\"><a href=\"#基本类型和引用类型的值\" class=\"headerlink\" title=\"基本类型和引用类型的值\"></a>基本类型和引用类型的值</h2><p>ECMAScript 中所有函数的参数都是按值传递的</p>\n<p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。</p>\n<p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部</p>\n<h2 id=\"执行环境及作用域\"><a href=\"#执行环境及作用域\" class=\"headerlink\" title=\"执行环境及作用域\"></a>执行环境及作用域</h2><p>==标识符解析是沿着作用域链一级一级地搜索标识符的过程==。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>\n<p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。根据 ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>\n<p>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。</p>\n<ol>\n<li>当执行流进入下列任何一个语句时，作用域链就会得到加长：<ul>\n<li>try-catch语句的catch块；</li>\n<li>with语句。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"垃圾收集\"><a href=\"#垃圾收集\" class=\"headerlink\" title=\"垃圾收集\"></a>垃圾收集</h2><ol>\n<li>标记清除<br> JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。</li>\n<li>引用计数<br> 另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。只有IE低版本使用</li>\n<li>性能问题<br> 垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。</li>\n<li>管理内存<br> 一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。<br> 局部变量会在它们离开执行环境时自动被解除引用</li>\n</ol>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"ECMAScript-面向对象程序设计","url":"http://yoursite.com/2017/09/10/ECMAScript-面相对象程序设计/","content":"<h1 id=\"对象的属性\"><a href=\"#对象的属性\" class=\"headerlink\" title=\"对象的属性\"></a>对象的属性</h1><h2 id=\"数据属性\"><a href=\"#数据属性\" class=\"headerlink\" title=\"数据属性\"></a>数据属性</h2><p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。</p>\n<ul>\n<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>\n<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>\n<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>\n<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。</li>\n</ul>\n<p>像例子中那样直接在对象上定义的属性,它们的 [[Configurable]] 、 [[Enumerable]] 和 [[Writable]] 特性都被设置为 true ,而 [[Value]] 特性被设置为”Nicholas”。例如: var person = { name: “Nicholas” };</p>\n<ol>\n<li>要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改对应的特性值。 <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(person, <span class=\"string\">\"name\"</span>, &#123;</div><div class=\"line\">  writable: <span class=\"literal\">false</span>,</div><div class=\"line\">  value: <span class=\"string\">\"Nicholas\"</span></div><div class=\"line\">&#125;);</div><div class=\"line\">alert(person.name); <span class=\"comment\">//\"Nicholas\"</span></div><div class=\"line\">person.name = <span class=\"string\">\"Greg\"</span>;</div><div class=\"line\">alert(person.name); <span class=\"comment\">//\"Nicholas\"</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h2><p>访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。</p>\n<ul>\n<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li>\n<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li>\n<li>[[Get]]：在读取属性时调用的函数。默认值为undefined。</li>\n<li>[[Set]]：在写入属性时调用的函数。默认值为undefined。</li>\n</ul>\n<p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。<br>    <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> book = &#123;</div><div class=\"line\">  _year: <span class=\"number\">2004</span>,</div><div class=\"line\">  edition: <span class=\"number\">1</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(book, <span class=\"string\">\"year\"</span>, &#123;</div><div class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._year;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (newValue &gt; <span class=\"number\">2004</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>._year = newValue;</div><div class=\"line\">      <span class=\"keyword\">this</span>.edition += newValue - <span class=\"number\">2004</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">book.year = <span class=\"number\">2005</span>;</div><div class=\"line\">alert(book.edition); <span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>要创建访问器属性，一般都使用两个非标准的方法：defineGetter()和defineSetter()。<br>在不支持 Object.defineProperty() 方法的浏览器中不能修改 [[Configurable]] 和 [[Enumerable]] 。</p>\n<h2 id=\"定义多个属性\"><a href=\"#定义多个属性\" class=\"headerlink\" title=\"定义多个属性\"></a>定义多个属性</h2><p>Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>\n<h2 id=\"读取属性的特性\"><a href=\"#读取属性的特性\" class=\"headerlink\" title=\"读取属性的特性\"></a>读取属性的特性</h2><p>Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get 和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value</p>\n<h1 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h1><h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>用函数来封装以特定接口创建对象的细节<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</div><div class=\"line\"> <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\"> o.name = name;</div><div class=\"line\"> o.age = age;</div><div class=\"line\"> o.job = job;</div><div class=\"line\"> o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">   alert(<span class=\"keyword\">this</span>.name);</div><div class=\"line\"> &#125;;</div><div class=\"line\"> <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">\"Nicholas\"</span>, <span class=\"number\">29</span>, <span class=\"string\">\"Software Engineer\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">\"Greg\"</span>, <span class=\"number\">27</span>, <span class=\"string\">\"Doctor\"</span>);</div></pre></td></tr></table></figure></p>\n<p>可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。<br><strong>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</strong></p>\n<h2 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</div><div class=\"line\"> <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\"> <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\"> <span class=\"keyword\">this</span>.job = job;</div><div class=\"line\"> <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">   alert(<span class=\"keyword\">this</span>.name);</div><div class=\"line\"> &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Nicholas\"</span>, <span class=\"number\">29</span>, <span class=\"string\">\"Software Engineer\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Greg\"</span>, <span class=\"number\">27</span>, <span class=\"string\">\"Doctor\"</span>);</div></pre></td></tr></table></figure>\n<p>以上相对于工厂模式有三个不同之处</p>\n<ul>\n<li>没有显式地创建对象；</li>\n<li>直接将属性和方法赋给了this对象；</li>\n<li>没有return语句。</li>\n</ul>\n<p>以这种方式调用构造函数实际上会经历以下 4个步骤： </p>\n<ul>\n<li>创建一个新对象； </li>\n<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； </li>\n<li>执行构造函数中的代码（为这个新对象添加属性）； </li>\n<li>返回新对象。</li>\n</ul>\n<p><strong>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍</strong></p>\n<h2 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h2><p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Person.prototype.name = <span class=\"string\">\"Nicholas\"</span>;</div><div class=\"line\">Person.prototype.age = <span class=\"number\">29</span>;</div><div class=\"line\">Person.prototype.job = <span class=\"string\">\"Software Engineer\"</span>;</div><div class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  alert(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"组合使用构造函数模式和原型模式\"><a href=\"#组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"组合使用构造函数模式和原型模式\"></a>组合使用构造函数模式和原型模式</h2><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">  <span class=\"keyword\">this</span>.job = job;</div><div class=\"line\">&#125;</div><div class=\"line\">Person.prototype = &#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span> : Person,</div><div class=\"line\">  sayName : function()&#123;</div><div class=\"line\">    alert(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h2><p>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">  <span class=\"keyword\">this</span>.job = job;</div><div class=\"line\">  <span class=\"comment\">//方法</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span>.sayName != <span class=\"string\">\"function\"</span>)&#123;</div><div class=\"line\">    Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      alert(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"寄生构造函数模式\"><a href=\"#寄生构造函数模式\" class=\"headerlink\" title=\"寄生构造函数模式\"></a>寄生构造函数模式</h2><p>工厂模式的变种，少用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">  o.name = name;</div><div class=\"line\">  o.age = age;</div><div class=\"line\">  o.job = job;</div><div class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    alert(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> friend = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Nicholas\"</span>, <span class=\"number\">29</span>, <span class=\"string\">\"Software Engineer\"</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"稳妥构造函数模式\"><a href=\"#稳妥构造函数模式\" class=\"headerlink\" title=\"稳妥构造函数模式\"></a>稳妥构造函数模式</h2><p>稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">  <span class=\"comment\">//可以在这里定义私有变量和函数</span></div><div class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    alert(name);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> friend = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Nicholas\"</span>, <span class=\"number\">29</span>, <span class=\"string\">\"Software Engineer\"</span>);</div></pre></td></tr></table></figure>\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><h2 id=\"class基本含义\"><a href=\"#class基本含义\" class=\"headerlink\" title=\"class基本含义\"></a>class基本含义</h2><p>类就是构造函数，可以使用new命令， 类的方法都定义在类的protopyte属性上，<br>prototype对象的constructor属性指向类本身，类内部定义的所有方法都是不可枚举的（和ES5不一致）</p>\n<p>定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>\n<h2 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h2><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>\n<p>constructor方法默认返回实例对象（即this）</p>\n<p><strong>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</div><div class=\"line\">point.toString() <span class=\"comment\">// (2, 3)</span></div><div class=\"line\">point.hasOwnProperty(<span class=\"string\">'x'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">point.hasOwnProperty(<span class=\"string\">'y'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">point.hasOwnProperty(<span class=\"string\">'toString'</span>) <span class=\"comment\">// false</span></div><div class=\"line\">point.__proto__.hasOwnProperty(<span class=\"string\">'toString'</span>) <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。</p>\n<p>可以通过实例的<strong>proto</strong>属性为Class添加方法。</p>\n<h2 id=\"Class不存在变量提升\"><a href=\"#Class不存在变量提升\" class=\"headerlink\" title=\"Class不存在变量提升\"></a>Class不存在变量提升</h2><h2 id=\"class表达式\"><a href=\"#class表达式\" class=\"headerlink\" title=\"class表达式\"></a>class表达式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> MyClass = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Me</span> </span>&#123;</div><div class=\"line\">  getClassName() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Me.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p>\n<h2 id=\"创建私有方法\"><a href=\"#创建私有方法\" class=\"headerlink\" title=\"创建私有方法\"></a>创建私有方法</h2><ul>\n<li><p>将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> </span>&#123;</div><div class=\"line\">  foo (baz) &#123;</div><div class=\"line\">    bar.call(<span class=\"keyword\">this</span>, baz);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">baz</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.snaf = baz;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p>\n<ul>\n<li>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</li>\n</ul>\n<h2 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h2><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">  printName(name = <span class=\"string\">'there'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.print(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>`</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  print(text) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(text);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"keyword\">new</span> Logger();</div><div class=\"line\"><span class=\"keyword\">const</span> &#123; printName &#125; = logger;</div><div class=\"line\">printName(); <span class=\"comment\">// TypeError: Cannot read property 'print' of undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p>\n<p><strong>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。如下</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.printName = <span class=\"keyword\">this</span>.printName.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>另一种解决方法是使用箭头函数。<br>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</p>\n<h2 id=\"class的静态方法，静态属性和实例属性\"><a href=\"#class的静态方法，静态属性和实例属性\" class=\"headerlink\" title=\"class的静态方法，静态属性和实例属性\"></a>class的静态方法，静态属性和实例属性</h2><ol>\n<li>在一个方法前加上static关键字 ，表示该方法不会被实例继承，而是通过类来调用</li>\n<li>父类的静态方法可以被子类继承</li>\n<li>静态方法也是可以从super对象上调用的</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\"> <span class=\"keyword\">static</span> classMethod() &#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\"> <span class=\"keyword\">static</span> classMethod() &#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.classMethod() + <span class=\"string\">', too'</span>;</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Bar.classMethod();</div></pre></td></tr></table></figure>\n<ol>\n<li>类的静态属性只要在实例属性写法前面，加上static关键字就可以了。如下</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">class MyClass &#123;</div><div class=\"line\"> static myStaticProp = 42;</div><div class=\"line\">    </div><div class=\"line\"> constructor() &#123;</div><div class=\"line\">   console.log(MyClass.myProp); // 42</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"为对象扩展属性\"><a href=\"#为对象扩展属性\" class=\"headerlink\" title=\"为对象扩展属性\"></a>为对象扩展属性</h3><ol>\n<li>自有属性：通过对象的引用添加的属性，其他对象无法访问</li>\n<li>原型属性：通过原型对象添加的属性（也叫共有属性）</li>\n</ol>\n<h3 id=\"检测自有属性和原型属性\"><a href=\"#检测自有属性和原型属性\" class=\"headerlink\" title=\"检测自有属性和原型属性\"></a>检测自有属性和原型属性</h3><ol>\n<li>先检查在整个原型关系上是否存在某个属性<br> var bool=“属性名” in 对象<br> 返回true则表示属性名包含在对象中或包含在原型对象中</li>\n<li>检查自有属性<br> var bool=obj.hasOwnProperty(“属性名”);<br> 返回true:说明对象中包含指定属性名<br> 返回false：仅说明对象中没有，不代表原型对象中没有</li>\n</ol>\n<h3 id=\"获得对象的原型\"><a href=\"#获得对象的原型\" class=\"headerlink\" title=\"获得对象的原型\"></a>获得对象的原型</h3><ol>\n<li>1通过构造函数的prototype属性获得</li>\n<li>通过Object.getPrototypeOf(obj)获得</li>\n</ol>\n<h3 id=\"检测原型\"><a href=\"#检测原型\" class=\"headerlink\" title=\"检测原型\"></a>检测原型</h3><p>父对象.isPrototypeOf(子对象)</p>\n<h3 id=\"修改对象的原型\"><a href=\"#修改对象的原型\" class=\"headerlink\" title=\"修改对象的原型\"></a>修改对象的原型</h3><p>将父对象设为子对象的原型</p>\n<ol>\n<li>Object.setPrototypeOf(子对象，父对象)</li>\n<li>构造函数.prototype=父对象<br> 为之后构造函数创建的所有子对象，自动继承父对象，但必须在创建对象之前修改</li>\n</ol>\n<h3 id=\"各种对象原型示意图\"><a href=\"#各种对象原型示意图\" class=\"headerlink\" title=\"各种对象原型示意图\"></a>各种对象原型示意图</h3><p><img src=\"/images/prototype.png\" alt=\"原型示意图\"></p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p><strong>继承是通过原型链实现的，而原型链是通过对象的<strong>proto</strong>属性实现的</strong><br>原型对象等于另一个类型的实例, 层层递进，就构成了实例与原型的链条。</p>\n<p>问题：</p>\n<ol>\n<li>将实例赋值给另一个原型之后，那么该实例上的引用类型就会被另一个原型的所有实例共享</li>\n<li>在创建子类型的实例时，不能向超类型的构造函数中传递参数</li>\n</ol>\n<h2 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">function SubType()&#123;SuperType.call(this)&#125;</div></pre></td></tr></table></figure>\n<p>Subtype继承SuperType<br>函数不过是在特定环境中执行代码的对象，于是这样，SubType的实例就不会共享SuperType的引用类型了，而且在this后面子类型可以向超类型传参</p>\n<p>但是，仍然把脱不了构造函数的问题：</p>\n<ol>\n<li>所有子类型都只能使用构造函数模式，那么每一个在子类型中创建的方法都不一样，无法做到函数复用</li>\n<li>使用call无法做到子类型继承超类型的原型</li>\n</ol>\n<h2 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h2><p>融合借用构造函数和原型链的优点，把需要实例继承的方法和属性定义在子类型或超类型的原型中，而需要实例独有的引用类型（数组或方法）和属性则定义在子类型和超类型的构造函数中；</p>\n<p>实现了两种继承：</p>\n<ol>\n<li>call对象冒充，子类型的构造函数继承超类型的构造函数；这样，子类型的实例在创建时就使用了两个构造函数；</li>\n<li><p>原型链继承，子类型继承超类型原型中的方法和属性</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person(name)&#123;</div><div class=\"line\">this.name=name;</div><div class=\"line\">this.colors=[‘red’,’blue’,’green’];</div><div class=\"line\">&#125;</div><div class=\"line\">Person.prototype.sayName=function()&#123;</div><div class=\"line\">console.log(this.name)</div><div class=\"line\">&#125;;</div><div class=\"line\">function Student(name,age)&#123;</div><div class=\"line\">Person.call(this,name);</div><div class=\"line\">//第一种继承：通过此方法可以让子类型Student的实例继承超类型Person，这样创建Student的实例时，同时会使用两个构造函数（Student和Person），</div><div class=\"line\">//所以就算是未传参的colors数组也会在Student的实例上创建（构造函数中，创建实例时引用类型也是完全复制，而非仅仅复制地址）</div><div class=\"line\">this.age=age;</div><div class=\"line\">&#125;</div><div class=\"line\">Student.prototype=new Person();//第二种继承</div><div class=\"line\">Student.prototype.constructor=Student;</div><div class=\"line\">Student.prototype.sayAge=function()&#123;</div><div class=\"line\">console.log(this.age);</div><div class=\"line\">&#125;;</div><div class=\"line\">var s1=new Student(‘James’,29);</div><div class=\"line\">s1.colors.push(‘black’);</div><div class=\"line\">console.log(s1.colors);</div><div class=\"line\">s1.sayName();</div><div class=\"line\">s1.sayAge();</div><div class=\"line\">var s2=new Student(‘Tom’,28);</div><div class=\"line\">console.log(s2.colors);</div><div class=\"line\">s2.sayName();</div><div class=\"line\">s2.sayAge();</div><div class=\"line\">console.log(s1.sayName===s2.sayName);//true Person的原型方法，继承且共享</div><div class=\"line\">console.log(s1.sayAge===s2.sayAge);//true Student的原型方法，继承且共享</div><div class=\"line\">console.log(Student.prototype.colors);//red blue green</div><div class=\"line\">console.log(s2.colors);//red blue green</div><div class=\"line\">console.log(Student.prototype.colors==s2.colors);//false 这三个语句说明实例中的引用类型colors不是继承原型的，而是构造函数创建的</div><div class=\"line\">console.log(s1.colors===s2.colors);//false 通过构造函数Person.call(this,name)继承</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"/images/组合继承.png\" alt=\"组合继承\"></p>\n<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">F.prototype=o;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ES5的object.create()方法规范了原型式继承</p>\n<h2 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h2><h2 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h2><p>因为组合式继承中SuperType.call(this,name)和SubType.prototype=new SuperType();都会调用超类型SuperType()，这样导致的结果就是：子类型SubType的原型中含有name，SubType的实例中也含有name，只不过实例中的name屏蔽了原型中的name；</p>\n<p>但是调用了两次超类型，创建了两组name属性，浪费内存；</p>\n<p>如果将组合式继承中的SubType.prototype=new SuperType();改为SubType.prototype=SuperType.prototype；那么这句话就不会调用超类型，仅仅是将超类型的原型赋给子类型的原型（此后超类型原型全等于子类型原型）；然后SubType.prototype.sayAge=function(){}；这样不仅子类型可以继承超类型原型，还能修改超类型原型，而且只调用了一次超类型</p>\n<p>修改上面的组合式继承代码如下：<br>Person.call(this,name);<br>Student.prototype=Person.prototype;</p>\n<h2 id=\"class继承\"><a href=\"#class继承\" class=\"headerlink\" title=\"class继承\"></a>class继承</h2><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承</p>\n<h3 id=\"使用super\"><a href=\"#使用super\" class=\"headerlink\" title=\"使用super\"></a>使用super</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y, color) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(x, y); <span class=\"comment\">// 调用父类的constructor(x, y)</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">  &#125;</div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.color + <span class=\"string\">' '</span> + <span class=\"keyword\">super</span>.toString(); <span class=\"comment\">// 调用父类的toString()</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>\n<ul>\n<li>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</li>\n<li>第二种情况，super作为对象时，指向父类的原型对象。</li>\n</ul>\n<h3 id=\"类的prototype属性和proto属性\"><a href=\"#类的prototype属性和proto属性\" class=\"headerlink\" title=\"类的prototype属性和proto属性\"></a>类的prototype属性和<strong>proto</strong>属性</h3><ol>\n<li>子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</li>\n<li>子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。</li>\n</ol>\n<h3 id=\"图解ES5和ES6继承的不同\"><a href=\"#图解ES5和ES6继承的不同\" class=\"headerlink\" title=\"图解ES5和ES6继承的不同\"></a>图解ES5和ES6继承的不同</h3><p><img src=\"/images/ES5继承.png\" alt=\"ES5的继承\"><br><img src=\"/images/ES6继承.png\" alt=\"ES6的继承\"></p>\n<h1 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h1><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>之前说过可以递归时可以使用arguments.callee，但在严格模式下,不能通过脚本访问 arguments.callee ,访问这个属性会导致错误。不过,可以使用命名函数表达式来达成相同的结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> factorial = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">num</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (num &lt;= <span class=\"number\">1</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num * f(num<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><ol>\n<li>为什么要用闭包：全局变量可共享，容易被污染<br> 局部变量虽然私有，但不可重用/共享</li>\n<li>解决：3步：<ol>\n<li>用大的方法将变量和操作变量的方法封装起来</li>\n<li>在外层方法结尾，将操作变量的方法对象返回</li>\n<li>在全局使用专门的方法名接住外层方法返回的函数对象 </li>\n</ol>\n</li>\n<li>何时使用闭包：保护可共享可重用的局部变量</li>\n<li>判断闭包：3特点<ol>\n<li>一定是方法的嵌套</li>\n<li>内层方法使用了外层方法的局部变量</li>\n<li>内层方法被外层方法返回到外部，而且被反复调用</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"闭包详解\"><a href=\"#闭包详解\" class=\"headerlink\" title=\"闭包详解\"></a>闭包详解</h3><ol>\n<li><p>闭包的执行流程(如下图)</p>\n<ol>\n<li>声明提前，window中创建两个变量，fun为undefined，getCounter是个函数，在声明的同时会创建两个对象（函数体对象和函数作用域链对象），其中函数体对象中的作用域链属性指向了函数作用域链对象，函数作用域链对象中默认创建一个元素，该元素指向window </li>\n<li><p>fun=getCounter()；  </p>\n<p> 先执行右边，调用父函数，首先创建一个父函数的活动对象，并在其作用域链对象中推入一个新元素，该新元素指向了这个活动对象，并且活动对象中存入父函数的局部变量n；  </p>\n<p> 父函数返回子函数，这表示在定义子函数，所以创建两个对象（子函数体对象和子函数作用域链对象），子函数体的作用域链属性指向子函数作用域链对象，并且子函数作用域链对象中默认创建两个元素，一个指向window，一个指向父函数的活动对象  </p>\n<p> 父函数将子函数的引用地址赋值给fun，父函数调用结束，父函数的作用域链对象中弹出元素，结束对父函数活动对象的引用，但父函数活动对象不会被释放，因为子函数的作用域链对象中有元素正在引用父函数的活动对象</p>\n</li>\n<li><p>console.log(fun())，表示执行fun，此时将创建fun（子函数）的活动对象，并在子函数的作用域链中推入新元素，该元素指向这个活动对象；执行完毕后，子函数的作用域链对象弹出元素，结束对子函数活动对象的引用，子函数活动对象被释放</p>\n</li>\n<li>由此形成一条链，window全局变量fun指向子函数体，子函数体指向子函数作用域链，子函数作用域链指向window和父函数的活动对象，父函数活动对象中保存了局部变量n，只能通过fun访问该变量，所以闭包保护了可以共享的局部变量</li>\n</ol>\n</li>\n<li><p>只要被window对象中全局变量引用的都不会被释放 （黑色箭头）<br>window全局对象中的变量fun引用了function(){return n++}，<br>function(){return n++}的作用域链属性引用着自己的作用域链对象，<br>该作用域链对象引用着getCounter的活动对象（）和window对象<br>==所以闭包占内存较大（多占了父函数的活动对象）==</p>\n</li>\n</ol>\n<p><img src=\"/images/闭包.png\" alt=\"闭包\"></p>\n<ol>\n<li><p>父函数被引用多次的情况</p>\n<ol>\n<li>外层函数调用几次，就有几个受保护的局部变量<br>假如再var fun1=getCounter()，那么闭包的执行流程中第2步~第4步再执行一遍，两个子函数的地址不一样（因为匿名，所以再次执行的时候会再次分配一个地址存储函数体），所以会有两个子函数体对象，两个子函数作用域链对象，两个getCounter()活动对象，里面分别存储了1个n，所以共有2个受保护的局部变量</li>\n<li><p>同一次外层函数调用返回的内层函数，都共享同一闭包中的局部变量。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> arr=[];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</div><div class=\"line\">\t\t\tarr[i]=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> i&#125;;\t        <span class=\"comment\">//arr[0],arr[1],arr[2]</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> arr;                        \t  &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> arr=fun1();                        </div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>]()); <span class=\"comment\">//3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">1</span>]()); <span class=\"comment\">//3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">2</span>]()); <span class=\"comment\">//3</span></div></pre></td></tr></table></figure>\n<p>上面的函数有一个副作用，就是闭包只能取得包含函数中任何变量的最后一个值，可以通过再创建一个匿名函数，强制把自我及时执行的结果返回到数组中，如下代码：其实是闭包的嵌套；创建了3个闭包（每个闭包都包含一个匿名函数和一个变量m），每个闭包都有属于自己的一个变量m，自我及时执行的结果就是把i及时的赋给每一个m；从而3个m都不一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">var</span> arr=[];</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</div><div class=\"line\">\tarr[i]=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> m</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;(i);\t<span class=\"comment\">//强制把及时自我执行的结果返回到数组中</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">return</span> arr;  </div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">var</span> arr=fun1();                        </div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>]()); <span class=\"comment\">//0</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr[<span class=\"number\">1</span>]()); <span class=\"comment\">//1</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr[<span class=\"number\">2</span>]()); <span class=\"comment\">//2</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h3><ol>\n<li>内存泄露问题<br>在IE8中，闭包的作用域链中保存着一个HTML元素，那么最好是在不需要时将其值设为null，否则它占用的内存永远不会被回收</li>\n<li>模仿块级作用域<br>一般在全局作用域，使用匿名函数(function(){var a;这里是私有作用域})()，既可以正常使用，又不怕内存占用和变量命名冲突，这样就创建了私有作用域，只要函数执行完毕，就可以立即销毁其作用域链了</li>\n<li>私有变量？？？<br>如果在函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量，而利用这一点，就可以创建用于访问私有变量的公有方法：在构造函数中定义特权方法<ol>\n<li>静态私有变量<br>通过在私有作用域中定义私有变量和函数，同样可以创建特权方法</li>\n<li>模块模式<br>为以对象字面量定义的对象创建私有变量和特权方法</li>\n<li>增强的模块模式</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"异步操作\"><a href=\"#异步操作\" class=\"headerlink\" title=\"异步操作\"></a>异步操作</h1><p>==写的并不全, 简单记录了一下, 以后有时间再搞==</p>\n<p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>\n<ul>\n<li>回调函数</li>\n<li>事件监听</li>\n<li>发布/订阅</li>\n<li>Promise 对象</li>\n</ul>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2>","categories":["前端"],"tags":["JavaScript"]},{"title":"ECMAScript-引用类型","url":"http://yoursite.com/2017/09/10/ECMAScript-引用类型/","content":"<h1 id=\"Object类型\"><a href=\"#Object类型\" class=\"headerlink\" title=\"Object类型\"></a>Object类型</h1><h2 id=\"创建对象的方式\"><a href=\"#创建对象的方式\" class=\"headerlink\" title=\"创建对象的方式\"></a>创建对象的方式</h2><ol>\n<li>new Object()</li>\n<li>对象字面量var obj = {};</li>\n<li>es6新方式<br>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">'world'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\"> v,</div><div class=\"line\"> method() &#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"string\">'Hello!'</span>;</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"访问对象的属性\"><a href=\"#访问对象的属性\" class=\"headerlink\" title=\"访问对象的属性\"></a>访问对象的属性</h2><ol>\n<li>点表示法</li>\n<li>方括号<br> 相对于点表示法, 方括号有以下几个优点<ul>\n<li>方括号内可以使用变量</li>\n<li>如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法</li>\n<li>ES6允许字面量定义对象时，把表达式放在方括号内作为属性名。  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> lastWord = <span class=\"string\">'last word'</span>;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;</div><div class=\"line\">  <span class=\"string\">'first word'</span>: <span class=\"string\">'hello'</span>,</div><div class=\"line\">  [lastWord]: <span class=\"string\">'world'</span>,</div><div class=\"line\">  [<span class=\"string\">'h'</span>+<span class=\"string\">'ello'</span>]() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hi'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"name-对象方法的属性\"><a href=\"#name-对象方法的属性\" class=\"headerlink\" title=\"name(对象方法的属性)\"></a>name(对象方法的属性)</h3><p>函数的name属性，返回函数名。ES6为对象方法也添加了name属性。<br>    <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  sayName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  get firstName() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Nicholas\"</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">person.sayName.name   <span class=\"comment\">// \"sayName\"</span></div><div class=\"line\">person.firstName.name <span class=\"comment\">// \"get firstName\"</span></div></pre></td></tr></table></figure></p>\n<p>上面代码中，方法的name属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上get。如果是存值函数，方法名的前面会加上set。</p>\n<p>有两种特殊情况：bind方法创造的函数，name属性返回“bound”加上原函数的名字；Function构造函数创造的函数，name属性返回“anonymous”。</p>\n<h3 id=\"proto属性\"><a href=\"#proto属性\" class=\"headerlink\" title=\"proto属性\"></a><strong>proto</strong>属性</h3><p>用来读取或设置当前对象的prototype对象。该属性一度被正式写入ES6草案，但后来又被移除。目前，所有浏览器（包括IE11）都部署了这个属性。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"hasOwnProperty-NaN\"><a href=\"#hasOwnProperty-NaN\" class=\"headerlink\" title=\"hasOwnProperty()\"></a>hasOwnProperty()</h3><p>obj.hasOwnProperty(prop)方法用来判断某个对象是否含有指定的自身属性。</p>\n<h3 id=\"isPrototypeOf-NaN\"><a href=\"#isPrototypeOf-NaN\" class=\"headerlink\" title=\"isPrototypeOf()\"></a>isPrototypeOf()</h3><p>prototype.isPrototypeOf(object)方法测试一个对象是否存在于另一个对象的原型链上。</p>\n<h3 id=\"propertyIsEnumerable-NaN\"><a href=\"#propertyIsEnumerable-NaN\" class=\"headerlink\" title=\"propertyIsEnumerable()\"></a>propertyIsEnumerable()</h3><p>obj.propertyIsEnumerable(prop)方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性。</p>\n<h3 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys()\"></a>Object.keys()</h3><p>返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。</p>\n<h3 id=\"Object-getOwnPropertyNames\"><a href=\"#Object-getOwnPropertyNames\" class=\"headerlink\" title=\"Object.getOwnPropertyNames()\"></a>Object.getOwnPropertyNames()</h3><p>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。</p>\n<h3 id=\"Object-preventExtensions\"><a href=\"#Object-preventExtensions\" class=\"headerlink\" title=\"Object.preventExtensions()\"></a>Object.preventExtensions()</h3><p>方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</p>\n<h3 id=\"Object-isExtensible\"><a href=\"#Object-isExtensible\" class=\"headerlink\" title=\"Object.isExtensible()\"></a>Object.isExtensible()</h3><p>方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</p>\n<h3 id=\"Object-seal\"><a href=\"#Object-seal\" class=\"headerlink\" title=\"Object.seal()\"></a>Object.seal()</h3><p>方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。</p>\n<h3 id=\"Object-isSealed\"><a href=\"#Object-isSealed\" class=\"headerlink\" title=\"Object.isSealed()\"></a>Object.isSealed()</h3><p>方法判断一个对象是否是密封的（sealed）。</p>\n<h3 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze()\"></a>Object.freeze()</h3><p>方法可以冻结一个对象。冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。</p>\n<h3 id=\"Object-isFrozen\"><a href=\"#Object-isFrozen\" class=\"headerlink\" title=\"Object.isFrozen()\"></a>Object.isFrozen()</h3><p>方法判断一个对象是否被冻结（frozen）。</p>\n<h3 id=\"Object-getOwnPropertySymbols\"><a href=\"#Object-getOwnPropertySymbols\" class=\"headerlink\" title=\"Object.getOwnPropertySymbols()\"></a>Object.getOwnPropertySymbols()</h3><p>方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键。</p>\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h3><p>Object.create(Object.prototype, { a: { value: 1, writable: true, configurable: true } });<br>创建一个继承自Object.prototype的对象，有一个属性a，其可写，可配置，不可枚举，值为1。</p>\n<h3 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty()\"></a>Object.defineProperty()</h3><p>Object.defineProperty(obj, prop, descriptor)</p>\n<h3 id=\"Object-defineProperties\"><a href=\"#Object-defineProperties\" class=\"headerlink\" title=\"Object.defineProperties()\"></a>Object.defineProperties()</h3><p>Object.defineProperties(obj, props)</p>\n<h3 id=\"Object-getOwnPropertyDescriptor\"><a href=\"#Object-getOwnPropertyDescriptor\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptor()\"></a>Object.getOwnPropertyDescriptor()</h3><p>返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</p>\n<h3 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a>Object.is()</h3><p>用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p>\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h3><p>将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。只要有一个参数不是对象，就会抛出TypeError错误。</p>\n<p><strong>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</strong></p>\n<ol>\n<li>assign方法有很多用处。  <ol>\n<li>为对象添加属性和方法</li>\n<li>克隆对象</li>\n<li>合并多个对象</li>\n<li>为属性指定默认值</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a>Object.setPrototypeOf()</h3><p>Object.setPrototypeOf(object, prototype)<br>作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。</p>\n<h3 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a>Object.getPrototypeOf()</h3><p>Object.getPrototypeOf(obj);<br>与setPrototypeOf方法配套，用于读取一个对象的prototype对象。</p>\n<h3 id=\"Object-observe\"><a href=\"#Object-observe\" class=\"headerlink\" title=\"Object.observe()\"></a>Object.observe()</h3><p>监听对象（以及数组）的变化。一旦监听对象发生变化，就会触发回调函数。(es7)<br>    <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> user = &#123;&#125;;</div><div class=\"line\"><span class=\"built_in\">Object</span>.observe(user, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">changes</span>)</span>&#123;</div><div class=\"line\">  changes.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">change</span>) </span>&#123;</div><div class=\"line\">    user.fullName = user.firstName+<span class=\"string\">\" \"</span>+user.lastName;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">user.firstName = <span class=\"string\">'Michael'</span>;</div><div class=\"line\">user.lastName = <span class=\"string\">'Jackson'</span>;</div><div class=\"line\">user.fullName <span class=\"comment\">// 'Michael Jackson'</span></div></pre></td></tr></table></figure></p>\n<ol>\n<li>changes <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">function observer(changes)&#123;</div><div class=\"line\">  changes.forEach(function(change) &#123;</div><div class=\"line\">    console.log(&apos;发生变动的属性：&apos; + change.name);</div><div class=\"line\">    console.log(&apos;变动前的值：&apos; + change.oldValue);</div><div class=\"line\">    console.log(&apos;变动后的值：&apos; + change.object[change.name]);</div><div class=\"line\">    console.log(&apos;变动类型：&apos; + change.type);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Object.observe(o, observer);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>参照上面代码，Object.observe方法指定的回调函数，接受一个数组（changes）作为参数。该数组的成员与对象的变化一一对应，也就是说，对象发生多少个变化，该数组就有多少个成员。每个成员是一个对象（change），它的name属性表示发生变化源对象的属性名，oldValue属性表示发生变化前的值，object属性指向变动后的源对象，type属性表示变化的种类。基本上，change对象是下面的样子。</p>\n<ol>\n<li>可以监听六种变化。<ul>\n<li>add：添加属性</li>\n<li>update：属性值的变化</li>\n<li>delete：删除属性</li>\n<li>setPrototype：设置原型</li>\n<li>reconfigure：属性的attributes对象发生变化</li>\n<li>preventExtensions：对象被禁止扩展（当一个对象变得不可扩展时，也就不必再监听了）</li>\n</ul>\n</li>\n<li>可以有第三个参数<br>Object.observe(o, observer, [‘delete’]);<br>Object.observe方法还可以接受第三个参数，用来指定监听的事件种类。</li>\n</ol>\n<h3 id=\"Object-unobserve\"><a href=\"#Object-unobserve\" class=\"headerlink\" title=\"Object.unobserve()\"></a>Object.unobserve()</h3><p>Object.unobserve(o, observer);<br>用来取消监听。</p>\n<h3 id=\"rest参数-es7提案\"><a href=\"#rest参数-es7提案\" class=\"headerlink\" title=\"rest参数(es7提案)\"></a>rest参数(es7提案)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> &#123; x, y, ...z &#125; = &#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">b</span>: <span class=\"number\">4</span> &#125;;</div><div class=\"line\">x <span class=\"comment\">// 1</span></div><div class=\"line\">y <span class=\"comment\">// 2</span></div><div class=\"line\">z <span class=\"comment\">// &#123; a: 3, b: 4 &#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"扩展运算符（…）-es7提案\"><a href=\"#扩展运算符（…）-es7提案\" class=\"headerlink\" title=\"扩展运算符（…）(es7提案)\"></a>扩展运算符（…）(es7提案)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> z = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">b</span>: <span class=\"number\">4</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> n = &#123; ...z &#125;;</div><div class=\"line\">n <span class=\"comment\">// &#123; a: 3, b: 4 &#125;</span></div></pre></td></tr></table></figure>\n<ol>\n<li><strong>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</strong></li>\n<li>如果扩展运算符的参数是null或undefined，这个两个值会被忽略，不会报错。</li>\n</ol>\n<h1 id=\"Array-类型\"><a href=\"#Array-类型\" class=\"headerlink\" title=\"Array 类型\"></a>Array 类型</h1><h2 id=\"创建数组\"><a href=\"#创建数组\" class=\"headerlink\" title=\"创建数组\"></a>创建数组</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">20</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> colors = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>]; <span class=\"comment\">// 创建一个包含3 个字符串的数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> names = []; <span class=\"comment\">// 创建一个空数组</span></div></pre></td></tr></table></figure>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"length\"><a href=\"#length\" class=\"headerlink\" title=\"length\"></a>length</h3><ol>\n<li><p>该属性不是只读的, 可以设置该属性移除或添加数组项</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>];</div><div class=\"line\">colors[<span class=\"number\">99</span>] = <span class=\"string\">\"black\"</span>;</div><div class=\"line\">alert(colors.length); <span class=\"comment\">// 100</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>在数组中，数组越界一般不会出错，都是undefined</strong></p>\n</li>\n</ol>\n<h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"Array-isArray\"><a href=\"#Array-isArray\" class=\"headerlink\" title=\"Array.isArray()\"></a>Array.isArray()</h3><p>和instanceof 操作符类似但更好使用</p>\n<h3 id=\"toString-和-join\"><a href=\"#toString-和-join\" class=\"headerlink\" title=\"toString() 和 join()\"></a>toString() 和 join()</h3><h3 id=\"push-和-pop\"><a href=\"#push-和-pop\" class=\"headerlink\" title=\"push() 和 pop()\"></a>push() 和 pop()</h3><h3 id=\"shift-和-unshift\"><a href=\"#shift-和-unshift\" class=\"headerlink\" title=\"shift() 和 unshift()\"></a>shift() 和 unshift()</h3><h3 id=\"reverse-和-sort\"><a href=\"#reverse-和-sort\" class=\"headerlink\" title=\"reverse() 和 sort()\"></a>reverse() 和 sort()</h3><ol>\n<li>sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数</li>\n</ol>\n<h3 id=\"concat-slice-和-splice\"><a href=\"#concat-slice-和-splice\" class=\"headerlink\" title=\"concat(), slice() 和 splice()\"></a>concat(), slice() 和 splice()</h3><p><strong>js中的截取操作都是含头不含尾的</strong></p>\n<ol>\n<li>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</li>\n<li>slice()能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下, slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数,该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意, slice() 方法不会影响原始数组。注意, slice() 方法不会影响原始数组。</li>\n<li>splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下3种。<ul>\n<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。</li>\n<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。</li>\n<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。</li>\n</ul>\n</li>\n</ol>\n<p><strong>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。</strong></p>\n<h3 id=\"indexOf-和-lastIndexOf\"><a href=\"#indexOf-和-lastIndexOf\" class=\"headerlink\" title=\"indexOf() 和 lastIndexOf()\"></a>indexOf() 和 lastIndexOf()</h3><p>这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。</p>\n<h3 id=\"every-filter-forEach-map-some\"><a href=\"#every-filter-forEach-map-some\" class=\"headerlink\" title=\"every(), filter(), forEach(), map(), some()\"></a>every(), filter(), forEach(), map(), some()</h3><ol>\n<li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回 true。</li>\n<li>filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li>\n<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</li>\n<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>\n<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</li>\n</ol>\n<p>==以上方法都不会修改数组中的包含的值。==</p>\n<h3 id=\"reduce-和-reduceRight\"><a href=\"#reduce-和-reduceRight\" class=\"headerlink\" title=\"reduce() 和 reduceRight()\"></a>reduce() 和 reduceRight()</h3><p>两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p>\n<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收 4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。<br>    <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> sum = values.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur, index, array</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> prev + cur;</div><div class=\"line\">&#125;);</div><div class=\"line\">alert(sum); <span class=\"comment\">//15</span></div><div class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</div></pre></td></tr></table></figure></p>\n<h3 id=\"Array-from-es6\"><a href=\"#Array-from-es6\" class=\"headerlink\" title=\"Array.from() (es6)\"></a>Array.from() (es6)</h3><p>用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）</p>\n<ol>\n<li>Array.from方法可以将函数的arguments对象，转为数组。</li>\n<li>任何有length属性的对象，都可以通过Array.from方法转为数组。</li>\n<li>Array.from()还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理。</li>\n<li>Array.from()的一个应用是，将字符串转为数组，然后返回字符串的长度。</li>\n</ol>\n<h3 id=\"Array-of-es6\"><a href=\"#Array-of-es6\" class=\"headerlink\" title=\"Array.of() (es6)\"></a>Array.of() (es6)</h3><p>用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。Array(3) // [undefined, undefined, undefined]</p>\n<h3 id=\"find-和-findIndex-es6\"><a href=\"#find-和-findIndex-es6\" class=\"headerlink\" title=\"find() 和 findIndex() (es6)\"></a>find() 和 findIndex() (es6)</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>\n<ol>\n<li><p>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>\n</li>\n<li><p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>\n</li>\n<li><p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>\n</li>\n</ol>\n<h3 id=\"fill-es6\"><a href=\"#fill-es6\" class=\"headerlink\" title=\"fill() (es6)\"></a>fill() (es6)</h3><p>使用给定值，填充一个数组。fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>\n<h3 id=\"entries-，keys-和-values-es6\"><a href=\"#entries-，keys-和-values-es6\" class=\"headerlink\" title=\"entries()，keys() 和 values() (es6)\"></a>entries()，keys() 和 values() (es6)</h3><p>用于遍历数组。它们都返回一个既实现了Iterable又实现了Iterator接口的对象，且该对象Symbol.iterator方法返回其自身，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>\n<h3 id=\"includes-es7\"><a href=\"#includes-es7\" class=\"headerlink\" title=\"includes() (es7)\"></a>includes() (es7)</h3><p>返回一个布尔值，表示某个数组是否包含给定的值。该方法属于ES7。该方法的第二个参数表示搜索的起始位置，默认为0。</p>\n<h3 id=\"Array-observe-，Array-unobserve-es7\"><a href=\"#Array-observe-，Array-unobserve-es7\" class=\"headerlink\" title=\"Array.observe()，Array.unobserve() (es7)\"></a>Array.observe()，Array.unobserve() (es7)</h3><p>这两个方法用于监听（取消监听）数组的变化，指定回调函数。</p>\n<p>它们的用法与Object.observe和Object.unobserve方法完全一致，也属于ES7的一部分，唯一的区别是，对象可监听的变化一共有六种，而数组只有四种：add、update、delete、splice（数组的length属性发生变化）</p>\n<h2 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h2><p>JavaScript有五种方法可以确定一个值到底是什么类型，分别是typeof运算符，constructor法，instanceof运算符，Object.prototype.toString方法以及Array.isArray法.</p>\n<ol>\n<li>instanceof运算符可以用来判断某个构造函数的prototype属性所指向的對象是否存在于另外一个要检测对象的原型链上。<br>console.log(a instanceof Array);//true</li>\n<li>实例化的数组拥有一个constructor属性，这个属性指向生成这个数组的方法。<br>console.log(a.constructor);//function Array(){ [native code] }</li>\n<li>Object的toString方法判断<br>Object.prototype.toString.call(a);//“[object Array]”</li>\n<li>Array对象的isArray方法判断</li>\n</ol>\n<h1 id=\"Date-类型\"><a href=\"#Date-类型\" class=\"headerlink\" title=\"Date 类型\"></a>Date 类型</h1><ol>\n<li>在调用Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象,必须传入表示该日期的毫秒数(即从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数)。</li>\n</ol>\n<h2 id=\"创建日期\"><a href=\"#创建日期\" class=\"headerlink\" title=\"创建日期\"></a>创建日期</h2><p>var date=new Date(‘yyyy/MM/dd hh:mm’)</p>\n<h2 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"Date-parse\"><a href=\"#Date-parse\" class=\"headerlink\" title=\"Date.parse()\"></a>Date.parse()</h3><p>接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。</p>\n<h3 id=\"Date-UTC\"><a href=\"#Date-UTC\" class=\"headerlink\" title=\"Date.UTC()\"></a>Date.UTC()</h3><p>同样也返回表示日期的毫秒数，但它与 Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于 0的月份（一月是 0，二月是 1，以此类推）、月中的哪一天（1到 31）、小时数（0到 23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。</p>\n<h3 id=\"Data-now\"><a href=\"#Data-now\" class=\"headerlink\" title=\"Data.now()\"></a>Data.now()</h3><p>返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Data对象分析代码的工作。</p>\n<h3 id=\"toLocaleString-toString-valueOf\"><a href=\"#toLocaleString-toString-valueOf\" class=\"headerlink\" title=\"toLocaleString(), toString(), valueOf()\"></a>toLocaleString(), toString(), valueOf()</h3><p>Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。</p>\n<p>至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。</p>\n<h3 id=\"日期格式化方法\"><a href=\"#日期格式化方法\" class=\"headerlink\" title=\"日期格式化方法\"></a>日期格式化方法</h3><ol>\n<li>Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。<ul>\n<li>toDateString()——以特定于实现的格式显示星期几、月、日和年；</li>\n<li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li>\n<li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；</li>\n<li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒；</li>\n<li>toUTCString()——以特定于实现的格式完整的UTC日期。</li>\n</ul>\n</li>\n</ol>\n<p>与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。</p>\n<h3 id=\"日期-时间组件方法\"><a href=\"#日期-时间组件方法\" class=\"headerlink\" title=\"日期/时间组件方法\"></a>日期/时间组件方法</h3><ol>\n<li>每个分量都有一对get/set方法</li>\n<li>数值范围：只有date从1~31（都是有效），其余都是从0~进制-1结束（只有month修正）</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getTime()</td>\n<td>返回表示日期的毫秒数;与 valueOf() 方法返回的值相同</td>\n</tr>\n<tr>\n<td>setTime( 毫秒 )</td>\n<td>以毫秒数设置日期,会改变整个日期</td>\n</tr>\n<tr>\n<td>getFullYear()</td>\n<td>取得4位数的年份(如2007而非仅07)</td>\n</tr>\n<tr>\n<td>getUTCFullYear()</td>\n<td>返回UTC日期的4位数年份</td>\n</tr>\n<tr>\n<td>setFullYear( 年 )</td>\n<td>设置日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td>\n</tr>\n<tr>\n<td>setUTCFullYear( 年 )</td>\n<td>设置UTC日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td>\n</tr>\n<tr>\n<td>getMonth()</td>\n<td>返回日期中的月份,其中0表示一月,11表示十二月</td>\n</tr>\n<tr>\n<td>getUTCMonth()</td>\n<td>返回UTC日期中的月份,其中0表示一月,11表示十二月</td>\n</tr>\n<tr>\n<td>setMonth( 月 )</td>\n<td>设置日期的月份。传入的月份值必须大于0,超过11则增加年份</td>\n</tr>\n<tr>\n<td>setUTCMonth( 月 )</td>\n<td>设置UTC日期的月份。传入的月份值必须大于0,超过11则增加年份</td>\n</tr>\n<tr>\n<td>getDate()</td>\n<td>返回日期月份中的天数(1到31)</td>\n</tr>\n<tr>\n<td>getUTCDate()</td>\n<td>返回UTC日期月份中的天数(1到31)</td>\n</tr>\n<tr>\n<td>setDate( 日 )</td>\n<td>设置日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td>\n</tr>\n<tr>\n<td>setUTCDate( 日 )</td>\n<td>设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td>\n</tr>\n<tr>\n<td>getDay()</td>\n<td>返回日期中星期的星期几(其中0表示星期日,6表示星期六)</td>\n</tr>\n<tr>\n<td>getUTCDay()</td>\n<td>返回UTC日期中星期的星期几(其中0表示星期日,6表示星期六)</td>\n</tr>\n<tr>\n<td>getHours()</td>\n<td>返回日期中的小时数(0到23)</td>\n</tr>\n<tr>\n<td>getUTCHours()</td>\n<td>返回UTC日期中的小时数(0到23)</td>\n</tr>\n<tr>\n<td>setHours( 时 )</td>\n<td>设置日期中的小时数。传入的值超过了23则增加月份中的天数</td>\n</tr>\n<tr>\n<td>setUTCHours( 时 )</td>\n<td>设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数</td>\n</tr>\n<tr>\n<td>getMinutes()</td>\n<td>返回日期中的分钟数(0到59)</td>\n</tr>\n<tr>\n<td>getUTCMinutes()</td>\n<td>返回UTC日期中的分钟数(0到59)</td>\n</tr>\n<tr>\n<td>setMinutes( 分 )</td>\n<td>设置日期中的分钟数。传入的值超过59则增加小时数</td>\n</tr>\n<tr>\n<td>setUTCMinutes( 分 )</td>\n<td>设置UTC日期中的分钟数。传入的值超过59则增加小时数</td>\n</tr>\n<tr>\n<td>getSeconds()</td>\n<td>返回日期中的秒数(0到59)</td>\n</tr>\n<tr>\n<td>getUTCSeconds()</td>\n<td>返回UTC日期中的秒数(0到59)</td>\n</tr>\n<tr>\n<td>setSeconds( 秒 )</td>\n<td>设置日期中的秒数。传入的值超过了59会增加分钟数</td>\n</tr>\n<tr>\n<td>setUTCSeconds( 秒 )</td>\n<td>设置UTC日期中的秒数。传入的值超过了59会增加分钟数</td>\n</tr>\n<tr>\n<td>getMilliseconds()</td>\n<td>返回日期中的毫秒数</td>\n</tr>\n<tr>\n<td>getUTCMilliseconds()</td>\n<td>返回UTC日期中的毫秒数</td>\n</tr>\n<tr>\n<td>setMilliseconds( 毫秒 )</td>\n<td>设置日期中的毫秒数</td>\n</tr>\n<tr>\n<td>setUTCMilliseconds( 毫秒 )</td>\n<td>设置UTC日期中的毫秒数</td>\n</tr>\n<tr>\n<td>getTimezoneOffset()</td>\n<td>返回本地时间与UTC时间相差的分钟数。例如,美国东部标准时间返回300。在某地进入夏令时的情况下,这个值会有所变化</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"RegExp-类型\"><a href=\"#RegExp-类型\" class=\"headerlink\" title=\"RegExp 类型\"></a>RegExp 类型</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;,不区分大小写</div><div class=\"line\">var pattern1 = /[bc]at/i;</div><div class=\"line\">// 与 pattern1 相同,只不过是使用构造函数创建的</div><div class=\"line\">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</div></pre></td></tr></table></figure>\n<ol>\n<li>模式中使用的所有元字符都必须转义。正则表达式中的元字符包括： ( [ { \\ ^ $ | ) ? * + .]}</li>\n<li>由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\\n（字符\\在字符串中通常被转义为\\，而在正则表达式字符串中就会变成\\\\）。</li>\n<li>==正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。==</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var re = null, i;</div><div class=\"line\">for (i=0; i &lt; 10; i++)&#123;</div><div class=\"line\">  re = /cat/g;</div><div class=\"line\">  re.test(&quot;catastrophe&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>循环中,即使是循环体中指定的,但实际上只为 /cat/ 创建了一个 RegExp 实例。由于实例属性(下一节介绍实例属性)不会重置,所以在循环中再次调用 test() 方法会失败。这是因为第一次调用 test() 找到了 “cat” ,但第二次调用是从索引为 3 的字符(上一次匹配的末尾)开始的,所以就找不到它了。由于会测试到字符串末尾,所以下一次再调用 test() 就又从开头开始了。</p>\n<p>ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例</p>\n<h2 id=\"正则字符\"><a href=\"#正则字符\" class=\"headerlink\" title=\"正则字符\"></a>正则字符</h2><ol>\n<li><p>[]： 一个[]中，仅匹配其中一个字符；每次必须从[]中选一个匹配，不能不选<br> 例如：我[去草][去草],可以匹配我去去，我去草，我草草，我草去，但不能匹配’我去草草‘，也不能匹配’我去‘</p>\n</li>\n<li><p>-：如果备选字符集是连续的，可用-简写<br> 例如：[0-9]; [A-Z]; [a-z]; 不要写[A-z]，最好写成[a-zA-Z0-9_]，因为A-z之间包含了一些其他字符；[a-zA-Z0-9];匹配所有字母或数字</p>\n</li>\n<li><p>^：[^要排除的字符]，必须放在方括号内首位<br> 例如：房间号：[^47]</p>\n</li>\n<li><p>预定义字符集</p>\n<ul>\n<li>\\d  [0-9]</li>\n<li>\\D  [^0-9]非数字</li>\n<li>\\w  [0-9a-zA-Z_] 数字字母或下划线</li>\n<li>\\W  [^0-9a-zA-Z_]</li>\n<li>\\s  [\\n\\r\\v\\t\\f] 匹配所有空字符集：制表符，空格，换行等</li>\n<li>\\S  匹配一个非空白字符</li>\n<li>.   [^\\n\\r]匹配除了回车和换行外的任何单个字符</li>\n</ul>\n</li>\n<li><p>数量词：规定前一个相邻字符集出现的次数</p>\n<ul>\n<li>{x,y}:字符集最少出现x次，最多y次  \\d{6,8}：6-8位数字</li>\n<li>{x,} 大于等于x次</li>\n<li>{x}  等于x次</li>\n<li>+    一次或多次</li>\n<li>*    零次或多次</li>\n<li><p>？   零次或一次<br>例如：身份证号：\\d{15}(\\d{2}[xX0-9]){0,1} </p>\n<p><strong>贪婪模式和非贪婪模式：都是建立在匹配结果符合的基础之上</strong><br>javascript中默认使用贪婪模式（尽可能多的匹配），加？表示非贪婪模式（尽可能少的匹配，只要匹配结果符合，就结束匹配）<br>贪婪模式的原因：正则表达式中使用了(.*) (.+)<br>改成非贪婪模式：把(.*) (.+)改成(.*?) (.+?)</p>\n</li>\n</ul>\n</li>\n<li><p>选择和分组：（exp）表示分组，一个圆括号表示一组<br> 其作用是，在完整的模式中定义子模式 （/[a-z]+(\\d+)/） 这样可以从检索的匹配中，抽取与圆括号中的子模式相匹配的部分</p>\n</li>\n<li><p>指定匹配位置</p>\n<ul>\n<li>^表达式:表示必须以表达式匹配的内容开头</li>\n<li>表达式$：表示必须以表达式匹配的内容结尾</li>\n<li>^表达式$：必须和表达式完全匹配<br><strong>只要在程序中执行验证，都要前加^后加$</strong></li>\n<li>^表达式1|表达式2$：匹配以表达式开头的部分，或匹配以表达式2结尾的部分<br><strong>^\\s+|\\s+$:匹配字符串开头或结尾的空字符</strong></li>\n<li>\\b 匹配边界单词   /\\bhis\\b/：</li>\n<li>\\B 匹配非边界单词 /\\Bhis\\B/</li>\n<li>?=x:匹配其后紧接x的字符串  /do(?=not)/</li>\n<li><p>?!x 匹配其后没有紧接x的字符串  /do(?!not)/</p>\n<p>例如：/\\bJava\\b/  仅匹配Java，不匹配sJava，也不匹配Javas<br>/\\B[Ss]cript/ 匹配javascript和postscript，但不匹配script和Scripting</p>\n</li>\n</ul>\n</li>\n<li><p>运算优先级</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/</td>\n<td>转义符</td>\n</tr>\n<tr>\n<td>(), (?:), (?=), []</td>\n<td>圆括号和方括号</td>\n</tr>\n<tr>\n<td>*, +, ?, {n}, {n,}, {n,m}</td>\n<td>限定符</td>\n</tr>\n<tr>\n<td>^, $, /anymetacharacter</td>\n<td>位置和顺序</td>\n</tr>\n<tr>\n<td>竖线</td>\n<td>“或”操作</td>\n</tr>\n</tbody>\n</table>\n<p>例子：用户名6位以上，必须以字母开头，至少包含一位数字，以及一位大写字母，正则是(?![a-zA-Z]+$)(?![0-9a-z]+$)[a-zA-Z][0-9a-zA-Z]{5,}</p>\n<h2 id=\"模式flags\"><a href=\"#模式flags\" class=\"headerlink\" title=\"模式flags\"></a>模式flags</h2><ul>\n<li>g :表示全局(global)模式,即模式将被应用于所有字符串,而非在发现第一个匹配项时立即停止;</li>\n<li>i :表示不区分大小写(case-insensitive)模式,即在确定匹配项时忽略模式与字符串的大小写;</li>\n<li>m :表示多行(multiline)模式,即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。<br>ES6中新增两个标志</li>\n<li>u :表示“Unicode模式”，用来正确处理大于\\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</li>\n<li>y :表示“粘连”（sticky）模式。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</li>\n</ul>\n<h3 id=\"y修饰符\"><a href=\"#y修饰符\" class=\"headerlink\" title=\"y修饰符\"></a>y修饰符</h3><ol>\n<li><p>y修饰符号隐含了头部匹配的标志ˆ。y修饰符的设计本意，就是让头部匹配的标志ˆ在全局匹配中都有效。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var s = &quot;aaa_aa_a&quot;;</div><div class=\"line\">var r1 = /a+/g;</div><div class=\"line\">var r2 = /a+/y;</div><div class=\"line\">r1.exec(s) // [&quot;aaa&quot;]</div><div class=\"line\">r2.exec(s) // [&quot;aaa&quot;]</div><div class=\"line\">r1.exec(s) // [&quot;aa&quot;]</div><div class=\"line\">//和g一样都是从_aa_a开始，但是y标志要求必须以a开头，所以返回null</div><div class=\"line\">r2.exec(s) // null</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果同时使用g修饰符和y修饰符，则y修饰符覆盖g修饰符。</p>\n</li>\n</ol>\n<h2 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h2><ul>\n<li>global：布尔值，表示是否设置了g标志。</li>\n<li>ignoreCase：布尔值，表示是否设置了i标志。</li>\n<li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li>\n<li>multiline：布尔值，表示是否设置了m标志。</li>\n<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。  </li>\n</ul>\n<p>ES6新增属性</p>\n<ul>\n<li>sticky:布尔值，表示是否设置了y标志。</li>\n<li>flags: 字符串，表示正则表达式的标志</li>\n</ul>\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><ol>\n<li>RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关</li>\n<li>正则表达式的valueOf()方法返回正则表达式本身。</li>\n</ol>\n<h3 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a>exec()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var text = &quot;mom and dad and baby&quot;;</div><div class=\"line\">var pattern = /mom( and dad( and baby)?)?/gi;</div><div class=\"line\">var matches = pattern.exec(text);</div><div class=\"line\">alert(matches.index); // 0</div><div class=\"line\">alert(matches.input); // &quot;mom and dad and baby&quot;</div><div class=\"line\">alert(matches[0]); // &quot;mom and dad and baby&quot;</div><div class=\"line\">alert(matches[1]); // &quot; and dad and baby&quot;</div><div class=\"line\">alert(matches[2]); // &quot; and baby&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test()\"></a>test()</h3><p>接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回 false</p>\n<h2 id=\"构造函数属性\"><a href=\"#构造函数属性\" class=\"headerlink\" title=\"构造函数属性\"></a>构造函数属性</h2><table>\n<thead>\n<tr>\n<th>长属性名</th>\n<th>短属性名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>input</td>\n<td>$_</td>\n<td>最近一次要匹配的字符串。Opera未实现此属性</td>\n</tr>\n<tr>\n<td>lastMatch</td>\n<td>$&amp;</td>\n<td>最近一次的匹配项。Opera未实现此属性</td>\n</tr>\n<tr>\n<td>lastParen</td>\n<td>$+</td>\n<td>最近一次匹配的捕获组。Opera未实现此属性</td>\n</tr>\n<tr>\n<td>leftContext</td>\n<td>$`</td>\n<td>input字符串中lastMatch之前的文本</td>\n</tr>\n<tr>\n<td>multiline</td>\n<td>$*</td>\n<td>布尔值,表示是否所有表达式都使用多行模式。IE和Opera未实现此属性</td>\n</tr>\n<tr>\n<td>rightContext</td>\n<td>$’</td>\n<td>Input字符串中lastMatch之后的文本</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var text = &quot;this has been a short summer&quot;;</div><div class=\"line\">var pattern = /(.)hort/g;</div><div class=\"line\"></div><div class=\"line\">if (pattern.test(text))&#123;</div><div class=\"line\">  alert(RegExp.input); // this has been a short summer</div><div class=\"line\">  alert(RegExp.leftContext); // this has been a</div><div class=\"line\">  alert(RegExp.rightContext); // summer</div><div class=\"line\">  alert(RegExp.lastMatch); // short</div><div class=\"line\">  alert(RegExp.lastParen); // s</div><div class=\"line\">  alert(RegExp.multiline); // false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>RegExp构造函数的各个属性返回了下列值：</p>\n<ul>\n<li>input属性返回了原始字符串；</li>\n<li>leftContext属性返回了单词short之前的字符串，而rightContext属性则返回了short之后的字符串；</li>\n<li>lastMatch属性返回最近一次与整个正则表达式匹配的字符串，即short；</li>\n<li>lastParen 属性返回最近一次匹配的捕获组,即例子中的s</li>\n</ul>\n</li>\n<li><p>RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。</p>\n</li>\n</ol>\n<h1 id=\"Function-类型\"><a href=\"#Function-类型\" class=\"headerlink\" title=\"Function 类型\"></a>Function 类型</h1><p><strong>函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</strong></p>\n<h2 id=\"声明函数\"><a href=\"#声明函数\" class=\"headerlink\" title=\"声明函数\"></a>声明函数</h2><ol>\n<li>function函数直接声明</li>\n<li>函数表达式</li>\n<li>new Function构造函数声明</li>\n</ol>\n<h2 id=\"函数内部属性\"><a href=\"#函数内部属性\" class=\"headerlink\" title=\"函数内部属性\"></a>函数内部属性</h2><h3 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h3><p>arguments是一个类数组对象，包含着传入函数中的所有参数。<br>虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3><p>this引用的是函数据以执行的环境对象</p>\n<h3 id=\"caller\"><a href=\"#caller\" class=\"headerlink\" title=\"caller\"></a>caller</h3><p>这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。</p>\n<h2 id=\"函数属性\"><a href=\"#函数属性\" class=\"headerlink\" title=\"函数属性\"></a>函数属性</h2><h3 id=\"length-1\"><a href=\"#length-1\" class=\"headerlink\" title=\"length\"></a>length</h3><p>length 属性表示函数希望接收的命名参数（形参）的个数</p>\n<h3 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h3><p>prototype属性是不可枚举的，因此使用for-in无法发现。</p>\n<h2 id=\"函数方法\"><a href=\"#函数方法\" class=\"headerlink\" title=\"函数方法\"></a>函数方法</h2><h3 id=\"apply-和-call-bind\"><a href=\"#apply-和-call-bind\" class=\"headerlink\" title=\"apply() 和 call(), bind()\"></a>apply() 和 call(), bind()</h3><ol>\n<li><p>在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个数数组。其中，第二个参数可以是 Array 的实例，也可以是arguments对象</p>\n</li>\n<li><p>call() 方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时,传递给函数的参数必须逐个列举出来</p>\n</li>\n<li><p>它们真正强大的地方是能够扩充函数赖以运行的作用域。使用call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系</p>\n</li>\n<li><p>bind方法会创建一个函数的实例，其 this 值会被绑定到传给bind()函数的值</p>\n</li>\n</ol>\n<h2 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetch</span>(<span class=\"params\">url, &#123; method = <span class=\"string\">'GET'</span> &#125; = &#123;&#125;</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(method);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>设置双重默认值。上面代码中，调用函数fetch时，如果不含第二个参数，则默认值为一个空对象；如果包含第二个参数，则它的method属性默认值为GET。</p>\n<ol>\n<li>定义了默认值的参数，必须是函数的尾部参数，其后不能再有其他无默认值的参数。</li>\n<li>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</li>\n<li>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。</li>\n<li>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</li>\n<li><p>参数默认值所处的作用域，不是全局作用域，而是函数作用域。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(y);</div><div class=\"line\">&#125;</div><div class=\"line\">foo(<span class=\"number\">2</span>) <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>参数默认值可以与解构赋值，联合起来使用。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">&#123;x, y = <span class=\"number\">5</span>&#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(&#123;&#125;) <span class=\"comment\">// undefined, 5</span></div><div class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;) <span class=\"comment\">// 1, 5</span></div><div class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;) <span class=\"comment\">// 1, 2</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h2><p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。（和Java的变长参数类似）</p>\n<h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><p>扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于函数调用。</p>\n<ol>\n<li>将一个数组拷贝进另一个数组的便捷方法。</li>\n<li>扩展运算符也可以与解构赋值结合起来，用于生成数组。</li>\n<li>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</li>\n<li>任何类似数组的对象，都可以用扩展运算符转为真正的数组。</li>\n<li>扩展运算符内部调用的是数据结构的Iterable接口，因此只要具有Iterable接口的对象，都可以使用扩展运算符，比如Map结构。</li>\n</ol>\n<h1 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h1><p>为了便于操作基本类型值，ECMAScript提供了3个特殊的引用类型：Boolean、Number和String。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">1</span> .toString(); <span class=\"comment\">//注意空格，否则会被当浮点数解析，然后抛错，还可以写为(1).toString()  1..toString()</span></div></pre></td></tr></table></figure>\n<p>上例中实际执行了三步：1. 创建Number类型的一个实例 2. 在实例上调用指定方法 3. 销毁这个实例</p>\n<p>==引用类型与基本包装类型的主要区别就是对象的生存期。== 自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法</p>\n<p>Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(<span class=\"string\">\"some text\"</span>);</div><div class=\"line\">alert(obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span>); <span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<h2 id=\"Boolean-类型\"><a href=\"#Boolean-类型\" class=\"headerlink\" title=\"Boolean 类型\"></a>Boolean 类型</h2><p>基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。</p>\n<h2 id=\"Number-类型\"><a href=\"#Number-类型\" class=\"headerlink\" title=\"Number 类型\"></a>Number 类型</h2><ol>\n<li>toFixed()方法会按照指定的小数位返回数值的字符串表示。J如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入</li>\n<li>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</li>\n<li>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。Number.isInteger(25.0) // true</li>\n<li>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。Number.isInteger(25.0) // true</li>\n</ol>\n<h2 id=\"String-类型\"><a href=\"#String-类型\" class=\"headerlink\" title=\"String 类型\"></a>String 类型</h2><p><strong>所有String API都不修改原变量，都必须用变量接住调用结果</strong></p>\n<h3 id=\"length-2\"><a href=\"#length-2\" class=\"headerlink\" title=\"length\"></a>length</h3><p>String类型的每个实例都有一个length属性，表示字符串中包含多个字符。应该注意的是，即使字符串中包含双字节字符（不是占一个字节的ASCII字符），每个字符也仍然算一个字符。</p>\n<h3 id=\"charAt-和-charCodeAt\"><a href=\"#charAt-和-charCodeAt\" class=\"headerlink\" title=\"charAt()和 charCodeAt()\"></a>charAt()和 charCodeAt()</h3><p>这两个方法都接收一个参数，即基于 0 的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符</p>\n<h3 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h3><h3 id=\"slice-、substr-和substring\"><a href=\"#slice-、substr-和substring\" class=\"headerlink\" title=\"slice()、substr()和substring()\"></a>slice()、substr()和substring()</h3><ul>\n<li>substring只能接受正数</li>\n<li>substr接受的第二个参数为返回的个数<h3 id=\"indexOf-和lastIndexOf\"><a href=\"#indexOf-和lastIndexOf\" class=\"headerlink\" title=\"indexOf()和lastIndexOf()\"></a>indexOf()和lastIndexOf()</h3><h3 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\"trim()\"></a>trim()</h3><h3 id=\"toLowerCase-、toLocaleLowerCase-、toUpperCase-和toLocaleUpperCase-。\"><a href=\"#toLowerCase-、toLocaleLowerCase-、toUpperCase-和toLocaleUpperCase-。\" class=\"headerlink\" title=\"toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。\"></a>toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。</h3><h3 id=\"match-search-replace\"><a href=\"#match-search-replace\" class=\"headerlink\" title=\"match(), search(), replace()\"></a>match(), search(), replace()</h3></li>\n</ul>\n<ol>\n<li>match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象<ul>\n<li>默认查找第一个匹配关键字的内容和位置</li>\n<li>加g之后，仅查找所有关键字的内容，返回一个数组</li>\n</ul>\n</li>\n<li>search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。正则后缀加g无效果（因为只找第一个）</li>\n<li>replace()接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志</li>\n<li>replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。</li>\n</ol>\n<h3 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h3><p>基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。</p>\n<p><strong>ES6将match()、replace()、search()和split()这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</strong></p>\n<h3 id=\"localeCompare\"><a href=\"#localeCompare\" class=\"headerlink\" title=\"localeCompare()\"></a>localeCompare()</h3><h3 id=\"fromCharCode\"><a href=\"#fromCharCode\" class=\"headerlink\" title=\"fromCharCode()\"></a>fromCharCode()</h3><h3 id=\"es6方法\"><a href=\"#es6方法\" class=\"headerlink\" title=\"es6方法\"></a>es6方法</h3><ol>\n<li>String.fromCodePoint</li>\n<li>String.codePointAt</li>\n<li>ES7提供了字符串实例的at方法</li>\n</ol>\n<h3 id=\"includes-startsWith-endsWith\"><a href=\"#includes-startsWith-endsWith\" class=\"headerlink\" title=\"includes(), startsWith(), endsWith()\"></a>includes(), startsWith(), endsWith()</h3><ul>\n<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>\n<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>\n<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>\n</ul>\n<h3 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat()\"></a>repeat()</h3><p>返回一个新字符串，表示将原字符串重复n次。</p>\n<h3 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h3><ol>\n<li>用反引号（`）标识, 可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量，需要将变量名写在${}之中。</li>\n<li>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。模板字符串之中还能调用函数</li>\n<li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</li>\n<li>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</li>\n<li><p>标签模板</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</div><div class=\"line\">tag<span class=\"string\">`Hello <span class=\"subst\">$&#123; a + b &#125;</span> world <span class=\"subst\">$&#123; a * b &#125;</span>`</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tag</span>(<span class=\"params\">stringArr, ...values</span>)</span>&#123; <span class=\"comment\">// ...  &#125;</span></div></pre></td></tr></table></figure>\n<p> tag函数所有参数的实际值如下。<br> 第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]<br> 第二个参数: 15<br> 第三个参数：50  </p>\n<ul>\n<li>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</li>\n<li>标签模板的另一个应用，就是多语言转换（国际化处理）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"String-raw\"><a href=\"#String-raw\" class=\"headerlink\" title=\"String.raw()\"></a>String.raw()</h3><ol>\n<li>String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</li>\n<li>String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</li>\n</ol>\n<h1 id=\"单体内置对象\"><a href=\"#单体内置对象\" class=\"headerlink\" title=\"单体内置对象\"></a>单体内置对象</h1><h2 id=\"Global对象\"><a href=\"#Global对象\" class=\"headerlink\" title=\"Global对象\"></a>Global对象</h2><p>所有在全局作用域中定义的属性和函数，都是Global对象的属性。诸如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat() ,实际上全都是 Global 对象的方法。</p>\n<ol>\n<li>URI 编码方法<ul>\n<li>编码：encodeURI(),encodeURIComponent()</li>\n<li>解码：decodeURI(),decodeURIComponent()</li>\n</ul>\n</li>\n<li>eval()方法</li>\n<li>Global 对象的属性<br> 特殊的值undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，像Object和Function，也都是Global对象的属性。下表列出了Global对象的所有属性。</li>\n</ol>\n<h2 id=\"Math-对象\"><a href=\"#Math-对象\" class=\"headerlink\" title=\"Math 对象\"></a>Math 对象</h2><h3 id=\"Math-PI\"><a href=\"#Math-PI\" class=\"headerlink\" title=\"Math.PI\"></a>Math.PI</h3><h3 id=\"min-和-max-方法\"><a href=\"#min-和-max-方法\" class=\"headerlink\" title=\"min() 和 max() 方法\"></a>min() 和 max() 方法</h3><p>从数组中取最大最小值的技巧：<br>Math.max.apply(Math,arr);Math.min.apply(Math,arr)</p>\n<h3 id=\"Math-ceil-Math-floor-Math-round\"><a href=\"#Math-ceil-Math-floor-Math-round\" class=\"headerlink\" title=\"Math.ceil(), Math.floor(), Math.round()\"></a>Math.ceil(), Math.floor(), Math.round()</h3><ol>\n<li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；</li>\n<li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</li>\n<li>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</li>\n</ol>\n<p>Math.random():返回0-1之间的一个随机数（0&lt;=Math.random()&lt;1）<br><strong>Math.floor(Math.random()*(max-min+1)+min)</strong></p>\n<h3 id=\"Math-random\"><a href=\"#Math-random\" class=\"headerlink\" title=\"Math.random()\"></a>Math.random()</h3><h1 id=\"键集合类型\"><a href=\"#键集合类型\" class=\"headerlink\" title=\"键集合类型\"></a>键集合类型</h1><h2 id=\"Map-类型\"><a href=\"#Map-类型\" class=\"headerlink\" title=\"Map 类型\"></a>Map 类型</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([ [<span class=\"string\">\"name\"</span>, <span class=\"string\">\"张三\"</span>], [<span class=\"string\">\"title\"</span>, <span class=\"string\">\"Author\"</span>]]);</div><div class=\"line\"></div><div class=\"line\">map.size <span class=\"comment\">// 2</span></div><div class=\"line\">map.has(<span class=\"string\">\"name\"</span>) <span class=\"comment\">// true</span></div><div class=\"line\">map.get(<span class=\"string\">\"name\"</span>) <span class=\"comment\">// \"张三\"</span></div><div class=\"line\">map.has(<span class=\"string\">\"title\"</span>) <span class=\"comment\">// true</span></div><div class=\"line\">map.get(<span class=\"string\">\"title\"</span>) <span class=\"comment\">// \"Author\"</span></div></pre></td></tr></table></figure>\n<ol>\n<li>只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</li>\n<li>同样的值的两个实例，在Map结构中被视为两个键。 <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">map.set([<span class=\"string\">'a'</span>], <span class=\"number\">555</span>);</div><div class=\"line\">map.get([<span class=\"string\">'a'</span>]) <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"实例属性和方法\"><a href=\"#实例属性和方法\" class=\"headerlink\" title=\"实例属性和方法\"></a>实例属性和方法</h3><ul>\n<li>size：返回成员总数。</li>\n<li>set(key, value)：设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>\n<li>get(key)：读取key对应的键值，如果找不到key，返回undefined。</li>\n<li>has(key)：返回一个布尔值，表示某个键是否在Map数据结构中。</li>\n<li>delete(key)：删除某个键，返回true。如果删除失败，返回false。</li>\n<li>clear()：清除所有成员，没有返回值。</li>\n</ul>\n<p>set()方法返回的是Map本身，因此可以采用链式写法。</p>\n<h3 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h3><ul>\n<li>keys()：返回键名的Iterable对象。</li>\n<li>values()：返回键值的Iterable对象。</li>\n<li>entries()：返回所有成员的Iterable对象。</li>\n</ul>\n<h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><ol>\n<li>Map转为数组<br>前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</li>\n<li>数组转为Map<br>将数组转入Map构造函数，就可以转为Map。</li>\n<li>Map转为对象<br>如果所有Map的键都是字符串，通过遍历，它可以转为对象。</li>\n<li>对象转为Map<br>通过遍历Object.keys(obj)，调用map.set方法添加键值对</li>\n<li>Map转为JSON<br>Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。JSON.stringify(strMapToObj(strMap));<br>另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。 JSON.stringify([…map]);</li>\n<li>JSON转为Map<br>JSON转为Map，正常情况下，所有键名都是字符串。JSON.parse(jsonStr)先转为对象，再把对象转为Map<br>但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。new Map(JSON.parse(jsonStr));</li>\n</ol>\n<h2 id=\"WeakMap-类型\"><a href=\"#WeakMap-类型\" class=\"headerlink\" title=\"WeakMap 类型\"></a>WeakMap 类型</h2><p>WeakMap结构与Map结构基本类似，唯一的区别是<strong>它只接受对象作为键名（null除外），不接受原始类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</strong></p>\n<p>WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p>\n<p>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>\n<p>WeakMap的另一个用处是部署私有属性。例如: Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>\n<h2 id=\"Set-类型\"><a href=\"#Set-类型\" class=\"headerlink\" title=\"Set 类型\"></a>Set 类型</h2><h3 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set函数可以接受一个数组作为参数，用来初始化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>]);</div><div class=\"line\">items.size <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和方法\"><a href=\"#实例的属性和方法\" class=\"headerlink\" title=\"实例的属性和方法\"></a>实例的属性和方法</h3><ol>\n<li><p>Set结构的实例有以下属性。</p>\n<ul>\n<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>\n<li>Set.prototype.size：返回Set实例的成员总数。</li>\n</ul>\n</li>\n<li><p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>\n<ul>\n<li>add(value)：添加某个值，返回Set结构本身。</li>\n<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>\n<li>clear()：清除所有成员，没有返回值。</li>\n</ul>\n</li>\n<li><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>\n<ul>\n<li>keys()：返回一个键名的Iterable对象</li>\n<li>values()：返回一个键值的Iterable对象</li>\n<li>entries()：返回一个键值对的Iterable对象</li>\n<li>forEach()：使用回调函数遍历每个成员</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"WeakSet-类型\"><a href=\"#WeakSet-类型\" class=\"headerlink\" title=\"WeakSet 类型\"></a>WeakSet 类型</h2><p>首先，WeakSet的成员只能是对象，而不能是其他类型的值。</p>\n<p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>\n<ol>\n<li>WeakSet结构有以下三个方法。<ul>\n<li>WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。</li>\n<li>WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。</li>\n<li>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。</li>\n<li>WeakSet没有size属性，没有办法遍历它的成员。</li>\n</ul>\n</li>\n</ol>\n<p>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<h1 id=\"反射类型\"><a href=\"#反射类型\" class=\"headerlink\" title=\"反射类型\"></a>反射类型</h1><h2 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h2><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>\n<p>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。（与Java中动态代理类似）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler)</div></pre></td></tr></table></figure>\n<p>Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>\n<ol>\n<li>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。<br>一个技巧是将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> object = &#123; <span class=\"attr\">proxy</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler) &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>Proxy实例也可以作为其他对象的原型对象。</li>\n<li><p>Proxy支持的拦截操作一览。</p>\n<ul>\n<li>get(target, propKey, receiver)<br>拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]，返回类型不限。最后一个参数receiver可选，当target对象设置了propKey属性的get函数时，receiver对象会绑定get函数的this对象。</li>\n<li>set(target, propKey, value, receiver)<br>拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>\n<li>has(target, propKey)<br>拦截propKey in proxy的操作，返回一个布尔值。</li>\n<li>deleteProperty(target, propKey)<br>拦截delete proxy[propKey]的操作，返回一个布尔值。</li>\n<li>enumerate(target)<br>拦截for (var x in proxy)，返回一个Iterable对象。</li>\n<li>hasOwn(target, propKey)<br>拦截proxy.hasOwnProperty(‘foo’)，返回一个布尔值。</li>\n<li>ownKeys(target)<br>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。</li>\n<li>getOwnPropertyDescriptor(target, propKey)<br>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>\n<li>defineProperty(target, propKey, propDesc)<br>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>\n<li>preventExtensions(target)<br>拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>\n<li>getPrototypeOf(target)<br>拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>\n<li>isExtensible(target)<br>拦截Object.isExtensible(proxy)，返回一个布尔值。</li>\n<li><p>setPrototypeOf(target, proto)<br>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</p>\n<p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p>\n</li>\n<li>apply(target, object, args)<br>拦截Proxy实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>\n<li>construct(target, args, proxy)<br>拦截Proxy实例作为构造函数调用的操作，比如new proxy(…args)。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h2><p>Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。</p>\n<ul>\n<li>将Object对象的一些明显属于语言层面的方法，放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。</li>\n<li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li>\n<li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>\n<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</li>\n</ul>\n<p>Reflect对象的方法清单如下。</p>\n<ul>\n<li>Reflect.getOwnPropertyDescriptor(target,name)</li>\n<li>Reflect.defineProperty(target,name,desc)</li>\n<li>Reflect.getOwnPropertyNames(target)</li>\n<li>Reflect.getPrototypeOf(target) 读取对象的<strong>proto</strong>属性，等同于Object.getPrototypeOf(obj)。</li>\n<li>Reflect.setPrototypeOf(obj, newProto) 设置对象的<strong>proto</strong>属性，注意，Object对象没有对应这个方法的方法。</li>\n<li>Reflect.deleteProperty(target,name) 等同于delete obj[name]。</li>\n<li>Reflect.enumerate(target)</li>\n<li>Reflect.freeze(target)</li>\n<li>Reflect.seal(target)</li>\n<li>Reflect.preventExtensions(target)</li>\n<li>Reflect.isFrozen(target)</li>\n<li>Reflect.isSealed(target)</li>\n<li>Reflect.isExtensible(target)</li>\n<li>Reflect.has(target,name) 等同于name in obj。</li>\n<li>Reflect.hasOwn(target,name)</li>\n<li>Reflect.keys(target)</li>\n<li>Reflect.get(target,name,receiver) 查找并返回target对象的name属性，如果没有该属性，则返回undefined。如果name属性部署了读取函数，则读取函数的this绑定receiver。</li>\n<li>Reflect.set(target,name,value,receiver) 设置target对象的name属性等于value。如果name属性设置了赋值函数，则赋值函数的this绑定receiver。</li>\n<li>Reflect.apply(target,thisArg,args) 等同于Function.prototype.apply.call(fun,thisArg,args)。一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。</li>\n<li>Reflect.construct(target,args) 等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。</li>\n</ul>\n<p>注意，Reflect.set()、Reflect.defineProperty()、Reflect.freeze()、Reflect.seal()和Reflect.preventExtensions()返回一个布尔值，表示操作是否成功。它们对应的Object方法，失败时都会抛出错误。</p>\n<h1 id=\"控制抽象类型\"><a href=\"#控制抽象类型\" class=\"headerlink\" title=\"控制抽象类型\"></a>控制抽象类型</h1><h2 id=\"Iteration-接口\"><a href=\"#Iteration-接口\" class=\"headerlink\" title=\"Iteration 接口\"></a>Iteration 接口</h2><p>ECMAScript 中一个接口是一组键值对属性，这些属性的键所对应的值符合特定的规范。如果一个对象提供了一个接口描述的所有属性，那么这个对象就实现了这个接口。一个接口并不是被单独的一个对象表示。可能有很多单独的对象实现符合某个接口，一个单独的对象可能实现多个接口。</p>\n<p>通过统一的接口机制，可以使用for-of来遍历不同的数据结构。</p>\n<h2 id=\"Iterable-接口\"><a href=\"#Iterable-接口\" class=\"headerlink\" title=\"Iterable 接口\"></a>Iterable 接口</h2><p>这个接口只有一个属性，即Symbol.iterator，它是一个函数，这个函数返回一个实现了Iterator接口的对象。</p>\n<p>在ES6中，有些数据结构原生实现了这个接口（比如数组），不用任何处理，就可以被for…of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有。凡是部署了Symbol.iterator属性的数据结构，就称为实现了Iterable接口。调用这个接口，就会返回一个Iterator对象。</p>\n<h2 id=\"Iterator-接口\"><a href=\"#Iterator-接口\" class=\"headerlink\" title=\"Iterator 接口\"></a>Iterator 接口</h2><p>这个接口有一个属性，next，这个属性是一个函数，它返回一个实现了IteratorResult接口的对象。如果上一步调用next返回的对象的done属性已经是true了，那么之后调用next函数也要返回一个done属性为true的IteratorResult对象。这个要求并不是强制的。</p>\n<p>该接口还有两个可选的属性return 和 throw。这两个属性都是方法，并且方法返回值都是IteratorResult对象。</p>\n<p>done为true，即遍历结束时，如果存在return方法，value的值会被设置为return方法。这并不是强制要求的。</p>\n<h2 id=\"IteratorResult-接口\"><a href=\"#IteratorResult-接口\" class=\"headerlink\" title=\"IteratorResult 接口\"></a>IteratorResult 接口</h2><p>包含value和done两个属性的对象。其中，value属性是当前成员的值，如果iterator提供了return方法的花，done为true时，这个value应该是iterator的return属性的值即return函数，否则done为true时value就是undefined，这种情况下可以没有value属性；done属性是一个布尔值，表示遍历是否结束，如果不存在done，就认为done属性为false。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Obj</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">  <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Obj.prototype[<span class=\"built_in\">Symbol</span>.iterator] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> iterator = &#123;</div><div class=\"line\">    next: next,</div><div class=\"line\">    <span class=\"keyword\">return</span>: returnFn</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (current)&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> value = current.value;</div><div class=\"line\">      <span class=\"keyword\">var</span> done = current === <span class=\"literal\">null</span>;</div><div class=\"line\">      current = current.next;</div><div class=\"line\">      <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        done: done,</div><div class=\"line\">        value: value</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        value: iterator.return,</div><div class=\"line\">        done: <span class=\"literal\">true</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">returnFn</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      done: <span class=\"literal\">true</span>,</div><div class=\"line\">      value: <span class=\"string\">'return'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> iterator;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> one = <span class=\"keyword\">new</span> Obj(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> two = <span class=\"keyword\">new</span> Obj(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> three = <span class=\"keyword\">new</span> Obj(<span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\">one.next = two;</div><div class=\"line\">two.next = three;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> it = one[<span class=\"built_in\">Symbol</span>.iterator]();</div><div class=\"line\">it.next();</div><div class=\"line\">it.next();</div><div class=\"line\">it.next();</div><div class=\"line\">it.next().value();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> a <span class=\"keyword\">of</span> one)&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码首先在构造函数的原型链上部署Symbol.iterator方法，调用该方法会返回遍Iterator对象，调用该对象的next方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p>\n<h2 id=\"默认实现Iterable接口的数据结构\"><a href=\"#默认实现Iterable接口的数据结构\" class=\"headerlink\" title=\"默认实现Iterable接口的数据结构\"></a>默认实现Iterable接口的数据结构</h2><p>Iterable接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环（详见下文）。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterable接口。</p>\n<p>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。也就是说，调用Symbol.iterator方法，就会得到当前数据结构的默认Iterator对象。Symbol.iterator本身是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内。</p>\n<p>在ES6中，有三类数据结构原生具备Iterable接口：数组、某些类似数组的对象、Set和Map结构。</p>\n<p>一个对象如果要有可被for…of循环调用的Iterable接口，就必须有Symbol.iterator方法（原型链上的对象具有该方法也可）。</p>\n<h2 id=\"Iterable接口默认的应用场合\"><a href=\"#Iterable接口默认的应用场合\" class=\"headerlink\" title=\"Iterable接口默认的应用场合\"></a>Iterable接口默认的应用场合</h2><ol>\n<li>for…of循环</li>\n<li>解构赋值</li>\n<li>扩展运算符</li>\n<li>yield*</li>\n<li>Array.from()</li>\n<li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li>\n<li>Promise.all()</li>\n<li>Promise.race()</li>\n</ol>\n<h2 id=\"原生具备Iterable接口的数据结构\"><a href=\"#原生具备Iterable接口的数据结构\" class=\"headerlink\" title=\"原生具备Iterable接口的数据结构\"></a>原生具备Iterable接口的数据结构</h2><ol>\n<li>ES6对数组提供entries()、keys()和values()三个方法，就是返回三个Iterable对象。4</li>\n<li>字符串是一个类似数组的对象，也原生具有Iterable接口。</li>\n</ol>\n<h2 id=\"Iterable接口与Generator函数\"><a href=\"#Iterable接口与Generator函数\" class=\"headerlink\" title=\"Iterable接口与Generator函数\"></a>Iterable接口与Generator函数</h2><p>Symbol.iterator方法的最简单实现，还是使用后面要介绍的Generator函数。</p>\n<h1 id=\"Promise-类型\"><a href=\"#Promise-类型\" class=\"headerlink\" title=\"Promise 类型\"></a>Promise 类型</h1><h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><ol>\n<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>\n<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>\n</ol>\n<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<p>如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。</p>\n<h2 id=\"基本用法-2\"><a href=\"#基本用法-2\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ... some code</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</div><div class=\"line\">    resolve(value);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    reject(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p>\n<p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。<br>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>\n<h2 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h2><p>then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p>\n<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcA</span>(<span class=\"params\">comments</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Resolved: \"</span>, comments);</div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcB</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Rejected: \"</span>, err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。</p>\n<h2 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h2><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 处理前一个回调函数运行时发生的错误</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误！'</span>, error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。</p>\n<p>需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。</p>\n<p>catch方法之中，还能再抛出错误。</p>\n<h2 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h2><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.all([p1,p2,p3]);</div></pre></td></tr></table></figure>\n<p>p的状态由p1、p2、p3决定，分成两种情况。</p>\n<p>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>\n<h2 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.race([p1,p2,p3]);</div></pre></td></tr></table></figure>\n<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p>\n<h2 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h2><ol>\n<li>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsPromise = <span class=\"built_in\">Promise</span>.resolve($.ajax(<span class=\"string\">'/whatever.json'</span>));</div></pre></td></tr></table></figure>\n<ol>\n<li>如果Promise.resolve方法的参数，不是具有then方法的对象（又称thenable对象），则返回一个新的Promise对象，且它的状态为Resolved。</li>\n<li>Promise.resolve方法允许调用时不带参数。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</li>\n<li>如果Promise.resolve方法的参数是一个Promise实例，则会被原封不动地返回。</li>\n</ol>\n<h2 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h2><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p>\n<h2 id=\"Generator函数与Promise的结合\"><a href=\"#Generator函数与Promise的结合\" class=\"headerlink\" title=\"Generator函数与Promise的结合\"></a>Generator函数与Promise的结合</h2><p>使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFoo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)</span>&#123;</div><div class=\"line\">    resolve(<span class=\"string\">'foo'</span>);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"keyword\">yield</span> getFoo();</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(foo);</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(e);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">generator</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> it = generator();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (result.done) <span class=\"keyword\">return</span> result.value;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> result.value.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> go(it.next(value));</div><div class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> go(it.throw(value));</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  go(it.next());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">run(g);</div></pre></td></tr></table></figure>\n<h2 id=\"async函数\"><a href=\"#async函数\" class=\"headerlink\" title=\"async函数\"></a>async函数</h2><p>async函数与Promise、Generator函数一样，是用来取代回调函数、解决异步操作的一种方法。它本质上是Generator函数的语法糖。async函数并不属于ES6，而是被列入了ES7，</p>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"CSS","url":"http://yoursite.com/2017/09/09/CSS/","content":"<h1 id=\"基础部分\"><a href=\"#基础部分\" class=\"headerlink\" title=\"基础部分\"></a>基础部分</h1><h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><h3 id=\"id，class，element\"><a href=\"#id，class，element\" class=\"headerlink\" title=\"id，class，element\"></a>id，class，element</h3><p>CSS是通过选择器的权重来决定样式的优先级。其中id权重为100，class为10，element为1。  </p>\n<p> #id，.class和element分别可以选中HTML元素</p>\n<h3 id=\"后代选择器\"><a href=\"#后代选择器\" class=\"headerlink\" title=\"后代选择器\"></a>后代选择器</h3><p>后代选择器有三种</p>\n<ol>\n<li>div p：选中div的所有为p的子元素</li>\n<li>div + p：选中div之后的第一个兄弟元素p</li>\n<li>div ~ p：选中div之后所有为p的兄弟元素</li>\n</ol>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><ol>\n<li>[id]</li>\n<li>p[id]</li>\n<li>p[id][class]:有id属性有class属性的p</li>\n<li>p[id=”sum”]：id值为sum的p</li>\n<li>p[class^=”b”]：属性值以b开头的p元素</li>\n<li>p[class*=”b”]：属性值中含b的所有p元素</li>\n<li>p[class$=”b”]：属性值以b结尾的p元素</li>\n<li>p[class~=”myClass”]:class值有多个、其中一个值是myClass(必须是一个独立的单词)的p元素  </li>\n<li>否定伪类：选择器:not([条件])<br> p:not([id=”sum”])：id不为sum的p元素（用的不多，有兼容性问题）</li>\n</ol>\n<h3 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h3><ol>\n<li>目标伪类: target 选择当前正在被跳转到的锚点元素<br> 例如: <a href=\"#news1\">跳转到新闻1</a><br>   <div id=\"news1\">新闻1</div><br> 样式：div:target{color:red;},表示点击a时，div的字体颜色会变成红色;<br> 点击其他元素时，div会变回原样（所以只能选择一个）<br> 特点一：仅选择一个<br> 特点二：通过点击，触发其他元素样式变化的变化</li>\n<li>元素状态伪类<ul>\n<li>:enabled 匹配每个可用的元素（表单）</li>\n<li>:disabled 匹配每个禁用的元素（表单）</li>\n<li>:checked 匹配每个被选中的元素（单选框和多选框）</li>\n</ul>\n</li>\n<li>结构伪类<ul>\n<li>子元素:first-child 匹配属于其父元素的首个子元素(例：p必须是“body的第一个子元素”才能被选中)</li>\n<li>子元素:last-child 匹配属于其父元素的最后一个子元素</li>\n<li>子元素:only-child 匹配属于其父元素的唯一子元素</li>\n<li>子元素:nth-child(2) 匹配属于其父元素的第二个子元素，仅括号内为变量，表示第几个</li>\n<li>父元素:empty 匹配没有子节点的每个元素（不能有空格，空格也是节点）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"伪元素选择器\"><a href=\"#伪元素选择器\" class=\"headerlink\" title=\"伪元素选择器\"></a>伪元素选择器</h3><ol>\n<li>p:first-letter 首字</li>\n<li>p:first-line   首行</li>\n<li>p::section 匹配被用户选中的部分（只能应用color和background-color样式）</li>\n</ol>\n<h3 id=\"内容生成\"><a href=\"#内容生成\" class=\"headerlink\" title=\"内容生成\"></a>内容生成</h3><ol>\n<li>选择器:before{content:”要插入的内容”}</li>\n<li>选择器:after{content:”要插入的内容”}</li>\n<li>计数器示例: css的取号机，一般和内容生成一起使用,分三步  <ol>\n<li>父元素上定义一个计数器属性<br> 父元素{counter-reset:计数器名 开始值}  </li>\n<li>需要生成序号的元素上定义计数器的步进<br> 需要生成序号的选择器{counter-increment:计数器名 步进数}</li>\n<li>在伪元素选择器中使用内容生成，生成序号<br> 选择器:before{content:”第”counter(计数器名)”章 “}</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"基础属性\"><a href=\"#基础属性\" class=\"headerlink\" title=\"基础属性\"></a>基础属性</h2><h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><ul>\n<li>list-style-type:disc（实心圆）/square（实心方块）/circle（空心圆）/none—–无序列表</li>\n<li>list-style-type:decimal(默认为数字)/lower-roman/upper-roman/none</li>\n<li>list-style-image:url();</li>\n<li>list-style-position:outside/inside—–列表标记是否显示在文本内</li>\n</ul>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><ul>\n<li>vertical-align:top/middle/bottom(单元格内内容的对齐方式)</li>\n<li>border-collapse：separate/collapse（相邻td的边框合并）—–table的属性</li>\n<li>border-spacing：水平间距 垂直间距（设置相邻td边框的间距）—–table的属性<br>  仅在border-collapse：separate的情况下生效</li>\n<li>caption-side:top/bottom</li>\n<li>table-layout:auto（自动表格布局，列宽由单元格内容设定）/fixed（表格列宽强制为某个值，不因内容而改变）</li>\n</ul>\n<h3 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h3><ul>\n<li>white-space:normal/nowrap(不换行)</li>\n<li>text-overflow:clip（裁剪）/ellipsis（后面出现….）<br>  此属性必须先设置overflw:hidden和white-space:nowrap才会看到效果</li>\n<li>word-wrap:normal/break-word—–长单词换行</li>\n<li>word-break:normal/break-all/keep-all—–文本换行</li>\n</ul>\n<h3 id=\"边框\"><a href=\"#边框\" class=\"headerlink\" title=\"边框\"></a>边框</h3><ul>\n<li>border-color：transparent（透明的）/hidden</li>\n<li>border-style</li>\n<li>border-width</li>\n<li>border-radius：<ul>\n<li>border-top-left-radius</li>\n<li>border-top-right-radius</li>\n<li>border-bottom-right-radius</li>\n<li>border-bottom-left-radius</li>\n</ul>\n</li>\n<li>border-shadow(水平偏移 垂直偏移 阴影模糊值 阴影外延值 阴影颜色 outset/inset) 阴影颜色默认与框内文字颜色一致</li>\n<li>border-image:source width repeat;</li>\n<li>outline(轮廓) width style color</li>\n</ul>\n<h3 id=\"内外边距\"><a href=\"#内外边距\" class=\"headerlink\" title=\"内外边距\"></a>内外边距</h3><ol>\n<li>padding</li>\n<li>margin</li>\n</ol>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><ul>\n<li>background: color image repeat attachment position</li>\n<li>background-color:</li>\n<li>background-image：</li>\n<li>background-repeat：repeat/repeat-x/repeat-y/no-repeat</li>\n<li>background-size: 宽度，高度—-（设置一个值只会赋给宽度，高度按比例显示）<ul>\n<li>如果宽高都是百分之百，那么图像的四边贴近边框的四边，但可能图像不是很和比例</li>\n<li>如果是cover，图像长短边都会放大，短边放大到和边框一样大，长边会比边框长，所以图像有些内容会溢出并隐藏</li>\n<li>如果是contain，图像长短边都会放大，长边放大到和边框一样大，所以两个短边和一个长边会贴近边框</li>\n</ul>\n</li>\n<li>background-attachment：fixed/scroll（图片随着容器或父元素一起滚动）/local（图片随着子元素或文本内容一起滚动）</li>\n<li>background-position：x y （px /% / left/right/bottom/top/center）先水平偏移，后垂直偏移;<br>  给小图留位置：使用padding-left;或者使用空格</li>\n<li>background-clip：border-box(默认值)/padding-box/content-box——–背景色的裁剪</li>\n<li>background-orign：border-box/padding-box(默认值)/content-box——-背景图的裁剪</li>\n</ul>\n<h3 id=\"渐变\"><a href=\"#渐变\" class=\"headerlink\" title=\"渐变\"></a>渐变</h3><ul>\n<li>background-image：渐变方式（angel，color-1，color-2）<ul>\n<li>渐变方式: <ol>\n<li>线性渐变：linear-gradient</li>\n<li>径向渐变：radial-gradient</li>\n<li>重复渐变：<br> repeating-linear-gradient 重复线性渐变<br> repeating-radial-gradient重复径向渐变</li>\n</ol>\n</li>\n<li>angel: to-top(对应0deg) to-right(90deg) to-bottom(180edg) to-left(270deg)</li>\n</ul>\n</li>\n<li>示例<ul>\n<li>background-image:linear-gradient(180deg,#f00 50%,#0f0 70%,#fff 100%);  表示渐变角度以及各颜色所在的位置</li>\n<li>background-image:radial-gradient(100px at 30px 90px,#f00 20%,#0f0 50%,#fff 100%);<br>表示半径100px，表示水平方向距离左侧30px，垂直方向距离顶端90px；如果不定义position则默认居中</li>\n<li>background-image:repeating-linear-gradient(to bottom,#f00 0%,#0f0 20%);</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h1><h2 id=\"布局属性\"><a href=\"#布局属性\" class=\"headerlink\" title=\"布局属性\"></a>布局属性</h2><h3 id=\"显示\"><a href=\"#显示\" class=\"headerlink\" title=\"显示\"></a>显示</h3><ul>\n<li>display:none（不显示不占据空间）/block/inline/inline-blcok(行内块元素，例如input，img可以设置宽高)</li>\n<li>visibility:visible/hidden(不可见但会占据空间)/collapse（用在删除表格的某行某列，但不影响表格布局）</li>\n<li>opacity：0~1取值（默认为1）—–透明属性</li>\n<li>vertical-align:baseline（父元素基线上）/top/bottom/middle—–用于设置单元格或行内块元素的垂直对齐方式<br>给行内最高的那个元素设置属性会对行内其他元素产生影响</li>\n<li>cursor：default/pointer（小手）/crosshair（十字）/text（I字形）/wait（转圈）/help（带问号）</li>\n</ul>\n<h3 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h3><ul>\n<li>float:none/left/right<br>浮动流和普通流同时存在，框与框之间因为浮动可以重叠，但是内容不会重叠，普通流内容会位于浮动元素的后面</li>\n<li>clear：left/right/both;</li>\n<li>overflow：hidden<br>父元素下如果都是浮动流，如果父元素没有定义高度，那么父元素的高度将不会随着子元素浮动流而扩展，因为子元素都是浮动流，跳出普通块了，应设置overflow:hidden</li>\n</ul>\n<h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><ul>\n<li>position:可取值如下<ul>\n<li>static/relative(相对于原来的位置、所占空间不变)</li>\n<li>absolute（相对于定位（最好是relative）的父元素或者定位的祖父元素或body、所占空间移除）<br><strong>拥有absolute的元素无法居中对齐</strong></li>\n<li>fixed（相对于浏览器窗口不变、所占空间完全移除）</li>\n</ul>\n</li>\n<li>偏移属性：top bottom right left属性，用于定位元素框的偏移位置</li>\n<li>z-index：堆叠顺序（要求元素已定位）</li>\n</ul>\n<h2 id=\"布局方式\"><a href=\"#布局方式\" class=\"headerlink\" title=\"布局方式\"></a>布局方式</h2><h3 id=\"响应式\"><a href=\"#响应式\" class=\"headerlink\" title=\"响应式\"></a>响应式</h3><p>三步实现响应式布局</p>\n<ol>\n<li>meta标签设置viewport</li>\n</ol>\n<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></p>\n<ol>\n<li>CSS media query  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@media screen and (max-width:980px)&#123;</div><div class=\"line\">      #pagewrap &#123;</div><div class=\"line\">        width: 94%;</div><div class=\"line\">      &#125;</div><div class=\"line\">      #content &#123;</div><div class=\"line\">        width: 65%;</div><div class=\"line\">      &#125;</div><div class=\"line\">      #sidebar &#123;</div><div class=\"line\">        width: 30%;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h3><h4 id=\"flex布局概念\"><a href=\"#flex布局概念\" class=\"headerlink\" title=\"flex布局概念\"></a>flex布局概念</h4><ol>\n<li><p>任何容器都可以指定为flex布局</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">a. 块级元素flex布局</div><div class=\"line\">.box&#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div><div class=\"line\">b. 行内元素flex布局</div><div class=\"line\">.box&#123;</div><div class=\"line\">  display: inline-flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>容器设定了flex布局之后， 子元素的float， clear和vertical-align将失效</p>\n</li>\n<li>采用flex布局的元素为flex容器， 所有子元素自动成为容器成员， 为flex item</li>\n<li>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br> 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</li>\n</ol>\n<h4 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h4><ol>\n<li><p>flex-direction<br> 决定主轴的方向（即项目的排列方向）。<br> flex-direction: row | row-reverse | column | column-reverse;</p>\n</li>\n<li><p>flex-wrap<br> 定义，如果一条轴线排不下，如何换行。<br> flex-wrap: nowrap | wrap | wrap-reverse;</p>\n</li>\n<li><p>flex-flow<br> 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>\n</li>\n<li><p>justify-content<br> 定义了项目在主轴上的对齐方式。<br> justify-content: flex-start | flex-end | center | space-between | space-around;</p>\n</li>\n<li><p>align-items<br> 定义项目在交叉轴上如何对齐。<br> align-items: stretch | flex-start | flex-end | center | baseline ;</p>\n</li>\n<li><p>align-content<br> 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br> align-content: stretch | flex-start | flex-end | center | space-between | space-around ;</p>\n</li>\n</ol>\n<h4 id=\"项目的属性\"><a href=\"#项目的属性\" class=\"headerlink\" title=\"项目的属性\"></a>项目的属性</h4><ol>\n<li><p>order<br> 定义项目的排列顺序。数值越小，排列越靠前，默认为0。可以为负值</p>\n</li>\n<li><p>flex-grow<br> 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br> 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>\n</li>\n<li><p>flex-shrink<br> 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br> 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n</li>\n<li><p>flex-basis<br> 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br> 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>\n</li>\n<li><p>flex<br> flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br> 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n</li>\n<li><p>align-self<br> align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br> align-self: auto | flex-start | flex-end | center | baseline | stretch;</p>\n</li>\n</ol>\n<h3 id=\"grid\"><a href=\"#grid\" class=\"headerlink\" title=\"grid\"></a>grid</h3><p>grid兼容性不是很好，暂不学习</p>\n<h1 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h1><h2 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h2><p>变形发生时，不会挤压周围元素，但有可能会覆盖（给父元素设置overflow：hidden即可）<br>旋转：rotate()  位移：translate()  缩放：scale()  倾斜：skew()<br>常用写法：transform:rotate()translate()sca()skew();</p>\n<ol>\n<li>旋转：围绕一个<em>参照原点</em>旋转<em>指定角度</em> （注：坐标原点在左上角；参照原点默认在中心）<ul>\n<li>参照原点：transform-origin:100% 100%;//transform-origin:right bottom;//transform-origin:x坐标 y坐标;<strong>要设置参照原点时，需放在其他属性之前；</strong></li>\n<li>旋转角度：transform:rotate(ndeg);<br>  位移：transform:translate(x,y);//translateX();//translateY();</li>\n<li>缩放：transform:scale(x,y);取一个值时是等比例缩放，取两值表示x、y方向上的缩放比例//scaleX();//scaleY();<strong>缩放也会受参照原点的影响，参照原点的位置在变形中永远不变</strong></li>\n<li>倾斜：transform:skew(ndeg,ndeg);//skewX();//skewY();</li>\n</ul>\n</li>\n<li>3d变形：<ul>\n<li>perspective属性：假定的人眼位置到投影平面（网页）的距离</li>\n<li>如何使用：在3d变换元素的父元素上定义perspective属性</li>\n</ul>\n</li>\n<li>3d位移：transform:translateZ();//translate3d(x,y,z)  <strong>注意：沿Z轴位移会导致其他坐标轴刻度缩小或放大</strong></li>\n<li>3d旋转：特指沿任意一个坐标轴旋转  <ul>\n<li>transform:rotateX(ndeg);n&gt;0向后倒 反之前倾  </li>\n<li>rotateY(ndeg);n&gt;0向右转，反之向左  </li>\n<li>rotateZ(ndeg);==transform:rotate(ndeg);  </li>\n<li>rotate3d(x,y,z,ndeg);<br>其中x,y,z取1（正向）或-1（反向）</li>\n</ul>\n</li>\n<li>3d缩放：transform:scaleZ();//scale3d(x,y,z)<br> 将对应坐标轴上的坐标*相应倍数（先缩放后位移，那么位移值会按缩放比例变化）</li>\n</ol>\n<blockquote>\n<p>注：transform属性后可以同时使用多种变化函数，浏览器会从左至右依次变化；<br>如果变化函数放在多个transform属性中，后面的transform会覆盖之前的.<br>rotate函数原理：旋转整个坐标轴，所以rotate()最好写在最后面（HTML5 canvas的旋转也是一样的原理）</p>\n</blockquote>\n<p>transform:translateX(100px) rotate(30deg)<br>transform:rotate(30deg) translateX(100px)<br>上下两个语句效果不一样</p>\n<h2 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h2><p>transition 从<em>开始样式</em> 经过<em>指定时间</em>后，缓慢过渡到<em>结束样式</em><br>transition:需要过渡的属性 过渡所需时间 过渡函数 经过多长时间过渡开始;<br>强调：和开始样式写在一起；在结束样式中，和开始样式属性值不一致的属性名会发生渐变.<br>如果要设置参照原点样式也要放在开始样式中（表示开始和结束的参照原点一样）<br>多个属性同时过渡可简写为(也可以写后面分别设置属性、时间、函数和延迟的方法)：</p>\n<ol>\n<li>transition:属性1 时长 变化类型 [延迟],<br> 属性2 时长 变化类型 [延迟],<br> 属性3 时长 变化类型 [延迟];</li>\n<li>transition-property:属性名1 属性名2 属性名3。。。。</li>\n<li>transition-duration:ns/nms ns/nms ns/nms 。。。。</li>\n<li>transition-timing-function:。。。。。。。<br> 可以有以下几个值：<br> ease(先加速后减速)<br> linear：匀速<br> ease-in：加速<br> ease-out：减速<br> ease-in-out：先加速后减速</li>\n<li>transition-delay:ns/nms。。。。。</li>\n</ol>\n<h2 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h2><p>关键帧：动画运行过程中的关键样式状态<br>关键帧动画：动画在多个关键帧之间顺序变化</p>\n<p>如何实现：2步</p>\n<ol>\n<li><p>定义动画，设计动画中的关键帧  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@keyframes 动画名&#123;</div><div class=\"line\">from&#123;动画初始状态&#125;</div><div class=\"line\">n%&#123;动画运行到n%位置时的状态&#125;</div><div class=\"line\">... ... </div><div class=\"line\">to&#123;动画结束状态&#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>需要出发动画的位置，触发动画<br> animation:动画名 动画持续时间 动画的类型 … </p>\n</li>\n</ol>\n<p>动画子属性：</p>\n<ul>\n<li>animation-name:</li>\n<li>animation-duration:</li>\n<li>animation-timing-function:</li>\n<li>animation-fill-mode:none/forwards/backwards/both;</li>\n<li>animation-delay:</li>\n<li>animation-iteration-count:n/infinite(无限次)</li>\n<li>animation-direction:normal(默认)/alternate（轮流播放，即单数次正常播放，偶数次反向播放）</li>\n<li>animation-play-state:paused（暂停）/running（运行）<br>  注：animation-play-state不能简写到一起，需单独写在hover里面才会生效</li>\n</ul>\n","categories":["前端"],"tags":["CSS"]},{"title":"HTML-常用API","url":"http://yoursite.com/2017/08/12/HTML-常用API/","content":"<h1 id=\"Web-Storage\"><a href=\"#Web-Storage\" class=\"headerlink\" title=\"Web Storage\"></a>Web Storage</h1><h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><ol>\n<li>sessionStorage 会话存储（关闭当前窗口或浏览器即清除）</li>\n<li>localStorage 本地存储（永久存储在当前浏览器）</li>\n</ol>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ol>\n<li>length：只读，返回存储在 Storage 对象中的数据项数量。</li>\n</ol>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ol>\n<li>key()：接受一个数值 n 作为参数，并返回存储中的第 n 个键名</li>\n<li>getItem()：该方法接受一个键名作为参数，返回键名对应的值。</li>\n<li>setItem()：该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</li>\n<li>removeItem()：该方法接受一个键名作为参数，并把该键名从存储中删除。</li>\n<li>clear()：调用该方法会清空存储中的所有键名。</li>\n</ol>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>当值发生改变或者clear时，会发生storage事件（sessionStorage没有该事件）</p>\n<p>通过storage事件可以获取以下几个属性</p>\n<ol>\n<li>storageArea: 表示存储类型（Session或Local）</li>\n<li>key:发生改变项的key</li>\n<li>oldValue: key的原值</li>\n<li>newValue: key的新值</li>\n<li>url*: key改变发生的URL</li>\n</ol>\n<h2 id=\"与cookie的区别\"><a href=\"#与cookie的区别\" class=\"headerlink\" title=\"与cookie的区别\"></a>与cookie的区别</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Cookie</th>\n<th>localStorage</th>\n<th>sessionStorage</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据的生命期</td>\n<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n<td>除非被清除，否则永久保存</td>\n<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n</tr>\n<tr>\n<td>存放数据大小</td>\n<td>4K左右</td>\n<td>一般为5MB</td>\n<td>同左</td>\n</tr>\n<tr>\n<td>与服务器端通信</td>\n<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n<td>同左</td>\n</tr>\n<tr>\n<td>易用性</td>\n<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n<td>同左</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"indexedDB\"><a href=\"#indexedDB\" class=\"headerlink\" title=\"indexedDB\"></a>indexedDB</h1><p>该数据库是一种存储在客户端本地的 NoSQL 数据库，它可以存储大量的数据。相对于storage存取简单数据，indexedDB适用于存取大量结构化数据。</p>\n<p>由于没使用过，更多请参考<a href=\"https://github.com/lin-xin/blog/issues/12\" target=\"_blank\" rel=\"external\">HTML5 进阶系列：indexedDB 数据库</a></p>\n<h1 id=\"Web-Drag\"><a href=\"#Web-Drag\" class=\"headerlink\" title=\"Web Drag\"></a>Web Drag</h1><p>该api实现了拖拽的事件，在这以前主要是通过mousedown、mousemove和mouseup来实现拖拽；</p>\n<h2 id=\"drag事件\"><a href=\"#drag事件\" class=\"headerlink\" title=\"drag事件\"></a>drag事件</h2><ol>\n<li>拖放源元素：dragSource<ul>\n<li>dragStart:拖拽开始事件</li>\n<li>drag：拖拽事件</li>\n<li>dragEnd：拖拽结束事件</li>\n</ul>\n</li>\n<li>拖放目标元素：dragTarget<ul>\n<li>dragEnter：拖拽进入目标事件</li>\n<li>dragOver：在目标元素上移动时触发的事件</li>\n<li>drop：在目标元素上释放事件</li>\n<li>dragleave：拖拽离开事件</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"drag时传递数据\"><a href=\"#drag时传递数据\" class=\"headerlink\" title=\"drag时传递数据\"></a>drag时传递数据</h2><p>拖拽时源元素和目标元素之间的数据传递需要使用拖拽事件的dataTransfer对象</p>\n<ol>\n<li>获取方式：e.dataTransfer</li>\n<li>设置值：e.dataTransfer.setData(key,value)</li>\n<li>获取值：e.dataTransfer.getData(key)</li>\n<li>删除值：e.dataTransfer.clearData(key)</li>\n<li>e.dataTransfer.setDragImage(img,x,y)在拖放过程中，修改鼠标指针所指向的图像</li>\n</ol>\n<p><strong>利用dataTransfer来传递数据，目标阶段必须要在dragEnter、dragOver、drop事件中调用e.preventDefault(),这样才能正常完成拖放动作。</strong></p>\n<h1 id=\"Web-Socket\"><a href=\"#Web-Socket\" class=\"headerlink\" title=\"Web Socket\"></a>Web Socket</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>客户端与服务器端之间非http的通信机制</p>\n<ol>\n<li>全双工连接类型的网络协议</li>\n<li>特点是实时、高效，永久</li>\n<li>使用场景：聊天室、即时游戏</li>\n</ol>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>readyState：代表当前连接的状态</p>\n<p>用法：WebSocket.CONNECTING</p>\n<ol>\n<li>CONNECTING:值0，正在连接中</li>\n<li>OPEN:1,已连接</li>\n<li>CLOSING：2，正在断开连接</li>\n<li>CLOSED:3，已断开连接</li>\n</ol>\n<h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ol>\n<li>send(‘msg’) : 给服务器发消息</li>\n<li>close() ：关闭连接</li>\n</ol>\n<h2 id=\"事件-1\"><a href=\"#事件-1\" class=\"headerlink\" title=\"事件\"></a>事件</h2><ol>\n<li>open：打开连接，创建连接</li>\n<li>close：关闭连接</li>\n<li>message：来消息</li>\n<li>error：错误事件</li>\n</ol>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>使用node.js + faye-websocket-node</p>\n<ol>\n<li><p>服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//执行以下命令</div><div class=\"line\">mkdir nodejs-faye-websocket</div><div class=\"line\">cd nodejs-faye-websocket</div><div class=\"line\">npm install faye-websocket</div><div class=\"line\">app.js</div><div class=\"line\">node app.js</div></pre></td></tr></table></figure>\n</li>\n<li><p>客户端</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">function checkBrowser()&#123;</div><div class=\"line\">    if(window.WebSocket)&#123;</div><div class=\"line\">    \tlog(&apos;该浏览器支持WebSocket！&apos;)</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">    \tlog(&apos;该浏览器不支持WebSocket！&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建并设置websocket</div><div class=\"line\">function setup()&#123;</div><div class=\"line\">\t//创建websocket</div><div class=\"line\">\tvar ws = new WebSocket(&apos;ws://localhost:3001&apos;);</div><div class=\"line\">\t</div><div class=\"line\">\t//通过4个事件做响应处理</div><div class=\"line\">\t//通过2个方法发送消息send或关闭连接close</div><div class=\"line\">\t//通过readyState属性判断连接状态</div><div class=\"line\">\tws.onopen = function(e)&#123;</div><div class=\"line\">\t\t//连接成功</div><div class=\"line\">\t\tlog(&apos;连接到服务器成功！&apos;,e);</div><div class=\"line\">\t\tsendMessage(&apos;hello,websocket&apos;);//发送消息给服务器</div><div class=\"line\">\t\tconsole.log(ws.readyState);//输出当前连接状态</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//接收消息事件</div><div class=\"line\">\tws.onmessage = function(e)&#123;</div><div class=\"line\">\t\tlog(&apos;RECEIVE:&apos;+e.data,e);</div><div class=\"line\">\t\tws.close();//关闭连接方法</div><div class=\"line\">\t\tconsole.log(ws.readyState);//输出当前连接状态</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//连接关闭事件</div><div class=\"line\">\tws.onclose = function(e)&#123;</div><div class=\"line\">\t\tlog(&apos;Disconnected:&apos;,e);</div><div class=\"line\">\t\tconsole.log(ws.readyState);//输出当前连接状态</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//错误事件</div><div class=\"line\">\tws.onerror = function(e)&#123;</div><div class=\"line\">\t\tlog(&apos;Error&apos;,e);</div><div class=\"line\">\t\tconsole.log(ws.readyState);//输出当前连接状态</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t//给服务器发送消息方法</div><div class=\"line\">\tvar sendMessage = function (msg)&#123;</div><div class=\"line\">\t\tws.send(msg);//发送消息给服务器</div><div class=\"line\">\t\tlog(&apos;SEND:&apos;+msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;\t\t</div><div class=\"line\"></div><div class=\"line\">//输入信息log函数:第一个参数代表消息，第二个参数代表相关事件</div><div class=\"line\">function log(s,e)&#123;</div><div class=\"line\">\t//获取output元素</div><div class=\"line\">\tvar output = document.getElementById(&apos;output&apos;);</div><div class=\"line\">\tvar p = document.createElement(&apos;p&apos;);//创建段落</div><div class=\"line\">\tp.style.wordWrap = &apos;break-word&apos;;//自动换行</div><div class=\"line\">\tp.style.padding = &apos;10px&apos;;//边距</div><div class=\"line\">\tp.style.background = &apos;#eee&apos;;//背景色</div><div class=\"line\">\tp.innerHTML = s;//设置文本信息</div><div class=\"line\">\toutput.appendChild(p);//追加到output中</div><div class=\"line\">\tconsole.log(s,e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">checkBrowser();//检测兼容性</div><div class=\"line\">setup();//创建websocket连接</div></pre></td></tr></table></figure>\n<h1 id=\"Web-Worker\"><a href=\"#Web-Worker\" class=\"headerlink\" title=\"Web Worker\"></a>Web Worker</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>web worker是模拟多线程的一个概念；它有以下几个优缺点：</p>\n<ol>\n<li>能实现js里面的多线程</li>\n<li>提高页面性能（不影响页面的性能）</li>\n<li>防止页面发生假死行为</li>\n<li>充分利用多核cpu的优势</li>\n<li>不能访问web页面、DOM API、全局变量</li>\n<li>可以使用setTimeout以及XMLHttpRequest通信</li>\n</ol>\n<p>另外Web workers可分为两种类型：专用线程dedicated web worker，以及共享线程shared web worker。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>通过主线程和子线程之间信息的相互传递，来达到主线程负责页面效果实现，子线程（worker）负责复杂的运算，从而实现多线程（充分利用cpu，防页面假死）</p>\n<ol>\n<li>主线程postMessage，让worker做复杂的运算</li>\n<li>子线程onmessage，做运算并将运算的结果postMessage给主线程</li>\n<li>主线程onmessage接收结果，然后实现</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 创建 var woker = new Worker(&apos;myworker.js&apos;);</div><div class=\"line\">   注意：myworker.js必须是单独js文件</div><div class=\"line\">2. 主线程和worker之间通信 worker.postMessage(msg);</div><div class=\"line\">3. 监听消息事件 worker.onmessage = function(e)&#123;....&#125;</div><div class=\"line\">4. 停止 worker: worker.terminate()</div></pre></td></tr></table></figure>\n<h1 id=\"Web-Geolocation\"><a href=\"#Web-Geolocation\" class=\"headerlink\" title=\"Web Geolocation\"></a>Web Geolocation</h1><h2 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>使用navigator.geolocation来获取当前地理对象；使用此api经常用来引入百度或者谷歌地图。</p>\n<h2 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ol>\n<li>navigator.geolocation.getCurrentPosition(success,error);查看当前定位</li>\n<li>navigator.geolocation.watchPosition(success,error);监控当前位置</li>\n<li>navigator.geolocation.clearWatch()清除当前监控</li>\n</ol>\n<h1 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h1><h2 id=\"方法-3\"><a href=\"#方法-3\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ol>\n<li>abort():void    终止文件读取操作</li>\n<li>readAsArrayBuffer(file):void 异步按字节读取文件内容，结果用ArrayBuffer对象表示</li>\n<li>readAsBinaryString(file):void 异步按字节读取文件内容，结果为文件的二进制串</li>\n<li>readAsDataURL(file):void    异步读取文件内容，结果用data:url的字符串形式表示</li>\n<li>readAsText(file,encoding):void 异步按字符读取文件内容，结果用字符串形式表示</li>\n</ol>\n<h2 id=\"事件-2\"><a href=\"#事件-2\" class=\"headerlink\" title=\"事件\"></a>事件</h2><ul>\n<li>onabort    当读取操作被中止时调用</li>\n<li>onerror    当读取操作发生错误时调用</li>\n<li>onload    当读取操作成功完成时调用</li>\n<li>onloadend    当读取操作完成时调用,不管是成功还是失败</li>\n<li>onloadstart    当读取操作将要开始之前调用</li>\n<li>onprogress    在读取数据过程中周期性调用</li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ol>\n<li>在线预览本地文件<br> 通过FileReader的readAsDataURL方法，将图片转换成base64编码，直接将其显示在页面上。</li>\n<li>二进制数据上传<br> HTML5基于xhr2可以直接上传下载二进制数据，无需像以往一样通过form标签由后端拉取二进制内容。<br> FileReader的readAsArrayBuffer方法将File对象转换为ArrayBuffer，然后通过xhr.sendAsBinary直接将文件的ArrayBuffer内容装填至post body后发送。</li>\n</ol>\n<h1 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h1><h2 id=\"form属性\"><a href=\"#form属性\" class=\"headerlink\" title=\"form属性\"></a>form属性</h2><ol>\n<li>method：请求方法post/get</li>\n<li>action：请求路径login.php</li>\n<li>enctype：编码方式，值为以下三种<ul>\n<li>默认为application/x-www-form-urlencoded;（此属性表示表单编码方式的设置）</li>\n<li>multipart/form-data </li>\n<li>text/plain </li>\n</ul>\n</li>\n</ol>\n<h2 id=\"表单元素\"><a href=\"#表单元素\" class=\"headerlink\" title=\"表单元素\"></a>表单元素</h2><ol>\n<li>input：（type=）<ul>\n<li>text 文本</li>\n<li>password 密码框</li>\n<li>checkbox 多选</li>\n<li>radio 单选</li>\n<li>file 文件选择</li>\n<li>hidden 隐藏</li>\n<li>submit 提交</li>\n<li>reset 重置</li>\n<li>button 按钮</li>\n<li>email：校验时：@前后有字符即可</li>\n<li>number：属性有min，max，step；校验时必须在最大最小之间</li>\n<li>url：校验时：含http: .com即可</li>\n<li>tel：无校验</li>\n<li>color：value值为#000000；为string类型</li>\n<li>search：搜索框，目的是提供语义功能</li>\n<li>range：范围，滑动条；默认min=’1’ max=’100’ step=’1’ value=’50’</li>\n<li>date：设置可选日期范围min=’2015-09-08’ max=’2015-09-15’</li>\n<li>week：</li>\n<li>month：</li>\n<li>datetime：datetime兼容性不好，建议使用datetime-local</li>\n<li>datetime-local：</li>\n</ul>\n</li>\n<li>textarea 多行文本框</li>\n<li>select 下拉框</li>\n<li>datalist 不可见的数据列表</li>\n<li>progress 进度条</li>\n<li>meter 丈量元素</li>\n<li>output 可输出表单元素处理的结果</li>\n</ol>\n<h2 id=\"表单元素属性\"><a href=\"#表单元素属性\" class=\"headerlink\" title=\"表单元素属性\"></a>表单元素属性</h2><ol>\n<li>placeholder 占位符</li>\n<li>multiple 表示是否可以在input中输入多个值，值之间用逗号分隔即可</li>\n<li>autofocus 表示是否自动获取焦点</li>\n<li>form 表示当前标签属于哪个form</li>\n</ol>\n<h2 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h2><h3 id=\"触发验证（点击触发）\"><a href=\"#触发验证（点击触发）\" class=\"headerlink\" title=\"触发验证（点击触发）\"></a>触发验证（点击触发）</h3><ol>\n<li><code>&lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&gt;</code></li>\n<li><code>&lt;button&gt;button&lt;/button&gt;</code></li>\n</ol>\n<h3 id=\"元素验证属性\"><a href=\"#元素验证属性\" class=\"headerlink\" title=\"元素验证属性\"></a>元素验证属性</h3><ul>\n<li>required：布尔值属性</li>\n<li>pattern：值为字符串格式的正则表达式<br>  注意：该校验不会检测内容必填，如果用户没有填写内容，校验不会进行。（所以最好和required组合使用）</li>\n<li>min/max/step：用于包含number、date、range等的input的验证约束</li>\n<li>minlength/maxlength：验证input的输入字符串的长度<br>  注意：minlength/maxlength是HTML5新属性，chrome较新版本才有该属性（和validity.tooShort，validity.tooLong一样）<ul>\n<li>minlength不是标准的w3c属性（未对外公布），但是却可以使用，校验信息提示的是英文，慎用。</li>\n<li>如果用编程方式给input赋值超过了规定范围，校验不会被触发，可以认为是个bug，注意。</li>\n</ul>\n</li>\n<li>validity：自定义校验的核心属性，可以通过该属性获得一个ValidityState对象，该对象有很多属性可以获得相应的校验通过的状态。<br>  注意事项：<ul>\n<li>该属性只有表单元素才有，表单没有</li>\n<li>有些浏览器没有validity.tooShort属性，导致minlength校验不能触发。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"元素禁用验证\"><a href=\"#元素禁用验证\" class=\"headerlink\" title=\"元素禁用验证\"></a>元素禁用验证</h3><ol>\n<li>novalidate：布尔值属性，form元素的属性，提交表单时不会验证</li>\n<li>formnovalidate：布尔值属性，submit类型input的属性</li>\n</ol>\n<p>注意：以上两个表面上一样的功能，实际上有区别，第二个仅用于测试，第一个是有实际用途的，比如我们要使用其他校验框架。</p>\n<h3 id=\"元素验证事件\"><a href=\"#元素验证事件\" class=\"headerlink\" title=\"元素验证事件\"></a>元素验证事件</h3><p>invalid事件</p>\n<ol>\n<li>如果加在表单元素上，则如果该元素校验未通过，会触发该事件。如果有多个元素都添加该事件，只有那些校验未通过的才能触发事件。</li>\n<li>invalid事件默认在捕获阶段和目标阶段结束后，不进行冒泡；所以目标的父元素form想要绑定事件的话，必须在捕获阶段</li>\n<li>让chrome的默认提示信息不显示event.preventDefault()</li>\n<li>使用场景：<ul>\n<li>你关心错误的那些组件事件</li>\n<li>你不关心具体什么错误</li>\n</ul>\n</li>\n<li>invalid事件的局限性：<ul>\n<li>只能找到校验错误的对象</li>\n<li>不能精确判断错误类型</li>\n</ul>\n</li>\n<li>属性：<ul>\n<li>target：验证不通过的元素</li>\n<li>type：事件类型</li>\n<li>bubbles：该事件是否为冒泡</li>\n<li>cancelable：是否可以取消该事件</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"验证对象\"><a href=\"#验证对象\" class=\"headerlink\" title=\"验证对象\"></a>验证对象</h3><p>元素的validity属性===ValidityState对象</p>\n<p>通过表单元素的validity属性获得ValidityState对象，该对象有很多属性，这些属性能够精确判断错误类型：</p>\n<h3 id=\"验证对象的属性\"><a href=\"#验证对象的属性\" class=\"headerlink\" title=\"验证对象的属性\"></a>验证对象的属性</h3><ul>\n<li>valid：合法的，该属性指出元素是否验证通过，它为true说明校验通过，否则不通过。<strong>该属性是总开关，总阀门。</strong></li>\n<li>valueMissing：未填写必填项，相应的校验属性是required</li>\n<li>patternMismatch：模式匹配错误，相对应的验证属性pattern</li>\n<li>typeMismatch：类型是否错误，典型的是email和url</li>\n<li>tooLong：对应maxlength，暂时触发不了（陷阱1，由于chrome版本低）</li>\n<li>tooShort：对应minlength，校验字符太短</li>\n<li>rangeOverflow：对应属性max</li>\n<li>rangeUnderflow:对应属性min</li>\n<li>stepMismatch：对应属性step，和step设置的值不匹配（比如值有小数点）</li>\n<li>badInput：类型转换错误，比如number里面输入字符串</li>\n<li>customError：当使用setCustomValidity方法设置自定义错误提示信息以后，该值为true，因此如果不把setCustomValidity重置为空，则验证永远无法通过。（陷阱2）</li>\n</ul>\n<h3 id=\"验证对象的方法\"><a href=\"#验证对象的方法\" class=\"headerlink\" title=\"验证对象的方法\"></a>验证对象的方法</h3><ol>\n<li>setCustomValidity(str)：该方法可以设置自定义错误提示信息<ul>\n<li>注意：只是修改chrome表单提交时默认的提示内容</li>\n<li>使用它时，务必在输入合法时把他设置为空，否则验证永远无法通过</li>\n<li>输入合法性判断千万不能用checkValidity()，也不能用elem.validity.valid</li>\n</ul>\n</li>\n<li>checkValidity()<br>该方法可以返回调用者校验结果，如果是元素就是元素的校验结果，如果是表单，则整个表单内部所有校验结果(相当于点击submit)。</li>\n</ol>\n<p>//调用checkValidity（）可以手动检查校验结果，等同于elem.validity.valid<br>//elem.checkValidity()  == elem.validity.valid</p>\n<h3 id=\"自定义验证\"><a href=\"#自定义验证\" class=\"headerlink\" title=\"自定义验证\"></a>自定义验证</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//$表示jQuery</div><div class=\"line\">$(&apos;input:eq(0)&apos;).bind(&#123;</div><div class=\"line\">    blur:function()&#123;</div><div class=\"line\">\t\tif(!this.validity.valid)&#123;</div><div class=\"line\">\t\t  $(this).next().css(&apos;color&apos;,&apos;#f00&apos;);</div><div class=\"line\">\t\t\tif(this.validity.valueMissing)&#123;</div><div class=\"line\">\t\t\t\t$(this).next().html(&apos;*用户名不能为空&apos;);</div><div class=\"line\">\t\t\t&#125;else if(this.validity.tooShort)&#123;</div><div class=\"line\">\t\t\t\t$(this).next().html(&apos;用户名太短&apos;);</div><div class=\"line\">\t\t\t&#125;else if(this.validity.tooLong)&#123;</div><div class=\"line\">\t\t\t\t$(this).next().html(&apos;用户名太长&apos;);</div><div class=\"line\">\t\t\t&#125;else if(this.validity.patternMismatch)&#123;</div><div class=\"line\">\t\t\t\t$(this).next().html(&apos;用户名格式错误&apos;);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tfocus:function()&#123;\t</div><div class=\"line\">\t\t$(this).next().html(&apos;请输入用户名，数字5~10位&apos;).css(&apos;color&apos;,&apos;#333&apos;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h1 id=\"video\"><a href=\"#video\" class=\"headerlink\" title=\"video\"></a>video</h1><h2 id=\"用法-1\"><a href=\"#用法-1\" class=\"headerlink\" title=\"用法\"></a>用法</h2><ol>\n<li>相比较flash，浏览器原生支持，且性能比较好</li>\n<li>支持的视频格式： mp4，ogv和webm（网页唯一超高清的视频格式）</li>\n<li>使用</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;video src=&apos;../data/oceans-clip.mp4&apos; controls poster=&apos;Koala.jpg&apos;&gt;</div><div class=\"line\">    &lt;!-- 多个视频源（以防浏览器不支持某种格式） --&gt;</div><div class=\"line\">    &lt;source src=&apos;../data/oceans-clip.mp4&apos;&gt;  </div><div class=\"line\">    &lt;source src=&apos;../data/oceans-clip.ogv&apos;&gt;</div><div class=\"line\">    &lt;source src=&apos;../data/oceans-clip.webm&apos;&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;!-- 视频无法播放时显示的内容 --&gt;</div><div class=\"line\">    可能由于浏览器的不支持，导致视频无法播放，请升级您的浏览器</div><div class=\"line\">&lt;/video&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"标签属性\"><a href=\"#标签属性\" class=\"headerlink\" title=\"标签属性\"></a>标签属性</h2><ol>\n<li>src：视频源</li>\n<li>width：定义宽</li>\n<li>height：定义高</li>\n<li>autoplay：只需属性名，无需属性值；用于设置是否自动播放</li>\n<li>controls：是否显示控件</li>\n<li>loop：是否重复播放</li>\n<li>autobuffer：是否自动缓冲</li>\n<li>poster：其值为一张图片的url；表示在播放视频之前，显示一张图片（高宽需和视频一致）</li>\n<li>preload：<ul>\n<li>auto，要求浏览器尽快下载当前视频</li>\n<li>none，不缓存视频（某些教育网站的视频不让缓存在本地）</li>\n<li>metadata，播放前只加载视频的高宽及其他信息</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"video事件\"><a href=\"#video事件\" class=\"headerlink\" title=\"video事件\"></a>video事件</h2><ol>\n<li>play：当播放当前视频时触发</li>\n<li>pause：当暂停当前视频时触发</li>\n<li>ended：当当前视频结束播放时触发</li>\n<li>error：当当前视频播放出错时触发</li>\n<li>canplay：当播放视频，同时下载视频（当前视频可以播放）</li>\n<li>canplaythrough：整个视频可以顺利播放（下载完毕）</li>\n<li>progess：用于更新媒体的下载进度，会周期性的触发</li>\n</ol>\n<h2 id=\"video对象方法\"><a href=\"#video对象方法\" class=\"headerlink\" title=\"video对象方法\"></a>video对象方法</h2><ol>\n<li>play()：用于播放当前视频（自定义控件时很有用）</li>\n<li>pause()：用于暂停当前视频（自定义控件时很有用）</li>\n<li>load()：用于加载视频文件</li>\n<li>canplayType()：判断浏览器是否支持某些视频格式</li>\n</ol>\n<h2 id=\"video对象属性\"><a href=\"#video对象属性\" class=\"headerlink\" title=\"video对象属性\"></a>video对象属性</h2><ol>\n<li>paused：返回布尔值，表示当前视频是否为暂停状态</li>\n<li>play：返回布尔值，表示当前视频是否为播放状态</li>\n<li>ended：返回布尔值，播放结束为true</li>\n<li>duration：返回当前视频的时长，单位为秒</li>\n<li>currentTime：返回播放视频的当前位置</li>\n</ol>\n<h2 id=\"做一个自定义视频插件\"><a href=\"#做一个自定义视频插件\" class=\"headerlink\" title=\"做一个自定义视频插件\"></a>做一个自定义视频插件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1. 获取播放视频的button按钮</div><div class=\"line\">var btn = document.getElementById(&quot;play&quot;);</div><div class=\"line\">// 2. 获取&lt;video&gt;元素</div><div class=\"line\">var mmedia = document.getElementById(&quot;mmedia&quot;);</div><div class=\"line\">// 3. 为button按钮绑定事件</div><div class=\"line\">btn.onclick = function()&#123;</div><div class=\"line\">\t// 判断当前视频是播放状态还是暂停状态</div><div class=\"line\">\tif(mmedia.paused &amp;&amp; !mmedia.ended)&#123; // 当前是暂停状态</div><div class=\"line\">\t\t// 实现播放视频功能</div><div class=\"line\">\t\tmmedia.play();</div><div class=\"line\">\t\t// 修改button显示内容</div><div class=\"line\">\t\tbtn.innerHTML = &quot;Pause&quot;;</div><div class=\"line\">\t\t// 动态控制进度条</div><div class=\"line\">\t\tt = setInterval(&quot;changeStatus();&quot;,1000);</div><div class=\"line\">\t&#125;else&#123;\t// 当前是播放状态</div><div class=\"line\">\t\tmmedia.pause();</div><div class=\"line\">\t\tbtn.innerHTML = &quot;Play&quot;;</div><div class=\"line\">\t\tclearInterval(t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 定义进度条的总宽度</div><div class=\"line\">var maxwidth = 600;</div><div class=\"line\">// 获取进度条元素</div><div class=\"line\">var progress = document.getElementById(&quot;progress&quot;);</div><div class=\"line\">// 该函数用于动态控制进度条</div><div class=\"line\">function changeStatus()&#123;</div><div class=\"line\">\t// 判断当前视频是否播放完毕</div><div class=\"line\">\tif(!mmedia.ended)&#123;</div><div class=\"line\">\t\t// 1. 获取当前视频时长对应的宽度</div><div class=\"line\">\t\tvar size = mmedia.currentTime*maxwidth/mmedia.duration;</div><div class=\"line\">\t\t// 2. 将HTML页面表示进度条的元素的width设置为计算的结果</div><div class=\"line\">\t\tprogress.style.width = size + &quot;px&quot;;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t// 清除setInterval()定时器</div><div class=\"line\">\t\tclearInterval(t);</div><div class=\"line\">\t\t// 将页面进度条的样式清空</div><div class=\"line\">\t\tprogress.style.width = 0 + &quot;px&quot;;</div><div class=\"line\">\t\t// 将button按钮的文本修改为Play</div><div class=\"line\">\t\tbtn.innerHTML = &quot;Play&quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"audio\"><a href=\"#audio\" class=\"headerlink\" title=\"audio\"></a>audio</h1><p>audio支持mp3，ogg，wav三种音频格式，其他用法（标签属性，事件，对象方法，对象属性，包括自定义控件）与video完全一致。</p>\n<h1 id=\"canvas，svg和webGL\"><a href=\"#canvas，svg和webGL\" class=\"headerlink\" title=\"canvas，svg和webGL\"></a>canvas，svg和webGL</h1><p>canvas和svg都是HTML中用于图形技术；但两者又有明显的用途区分：</p>\n<ol>\n<li>canvas基于像素，只能脚本驱动，适合像素处理，动态渲染和大数据量绘制（多用于游戏）；</li>\n<li>svg基于矢量，适合静态图片展示，高保真文档查看和打印的应用场景；</li>\n<li>webGL常用于实现3D效果；<br>因为本人没有使用过，所以不做概述。</li>\n</ol>\n","categories":["前端"],"tags":["HTML"]},{"title":"HTML-常用标签","url":"http://yoursite.com/2017/08/06/HTML-常用标签/","content":"<p><strong>使用HTML标签最重要的一点就是语义化</strong></p>\n<h1 id=\"语义化\"><a href=\"#语义化\" class=\"headerlink\" title=\"语义化\"></a>语义化</h1><ol>\n<li>语义化目的：<ol>\n<li>让机器（搜索引擎）易于理解，利于SEO；</li>\n<li>阅读代码的人能够很容易理解网页各个模块并维护；</li>\n</ol>\n</li>\n<li>语义化姿势：<ol>\n<li>尽量使用含语义信息的标签，例如header,nav,aside,section；</li>\n<li>标题、段落、列表等标签严格区分，不要滥用；</li>\n<li>内容结构化，去掉css也具有清晰可读的结构；</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"文档标签\"><a href=\"#文档标签\" class=\"headerlink\" title=\"文档标签\"></a>文档标签</h1><ol>\n<li>html lang属性声明语言</li>\n<li>head<ul>\n<li>meta</li>\n<li>title</li>\n<li>link</li>\n<li>style</li>\n<li>base</li>\n</ul>\n</li>\n<li>body<ul>\n<li>script</li>\n<li>noscript</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"布局标签\"><a href=\"#布局标签\" class=\"headerlink\" title=\"布局标签\"></a>布局标签</h1><ol>\n<li>div, span</li>\n<li>main, header, footer, section, nav</li>\n<li>article, aside</li>\n</ol>\n<h1 id=\"表格标签\"><a href=\"#表格标签\" class=\"headerlink\" title=\"表格标签\"></a>表格标签</h1><ol>\n<li>table</li>\n<li>thead, tbody, tfoot</li>\n<li>caption, col, th, tr, td</li>\n</ol>\n<h1 id=\"表单标签\"><a href=\"#表单标签\" class=\"headerlink\" title=\"表单标签\"></a>表单标签</h1><ol>\n<li>form</li>\n<li>input</li>\n<li>fieldset, legend, label,</li>\n<li>textarea, select</li>\n<li>optgroup, option</li>\n<li>button</li>\n<li>datalist, meter, output, progress</li>\n</ol>\n<h1 id=\"列表标签\"><a href=\"#列表标签\" class=\"headerlink\" title=\"列表标签\"></a>列表标签</h1><ol>\n<li>ul, ol, li</li>\n<li>dl, dt, dd</li>\n</ol>\n<h1 id=\"图像链接音频视频\"><a href=\"#图像链接音频视频\" class=\"headerlink\" title=\"图像链接音频视频\"></a>图像链接音频视频</h1><ol>\n<li>img, a, figure, figcaption</li>\n<li>video, audio</li>\n</ol>\n<h1 id=\"内嵌标签\"><a href=\"#内嵌标签\" class=\"headerlink\" title=\"内嵌标签\"></a>内嵌标签</h1><ol>\n<li>iframe 唯一可用的框架标签</li>\n<li>embed, object, source</li>\n</ol>\n<h1 id=\"文本格式标签\"><a href=\"#文本格式标签\" class=\"headerlink\" title=\"文本格式标签\"></a>文本格式标签</h1><ol>\n<li>h1-h6, p</li>\n<li>br, hr</li>\n<li>strong, i</li>\n<li>pre, sup, sub, blockquote</li>\n<li>time, data, mark</li>\n</ol>\n","categories":["前端"],"tags":["HTML"]},{"title":"HTML-文档定义","url":"http://yoursite.com/2017/08/06/HTML-文档定义/","content":"<h1 id=\"doctype\"><a href=\"#doctype\" class=\"headerlink\" title=\"doctype\"></a>doctype</h1><p>&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。</html></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div></pre></td></tr></table></figure>\n<p>Html5没有严格模式和混杂模式的区分，它相对宽松的语法已经最大实现了向后兼容。</p>\n<h1 id=\"meta\"><a href=\"#meta\" class=\"headerlink\" title=\"meta\"></a>meta</h1><p>meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。</p>\n<p>meta标签按照属性来分，一般可以分成常用的三种：charset、name和http-equiv</p>\n<h2 id=\"charset\"><a href=\"#charset\" class=\"headerlink\" title=\"charset\"></a>charset</h2><p>此特性声明当前文档所使用的字符编码，但该声明可以被任何一个元素的 lang 特性的值覆盖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;meta charset=&quot;UTF-8&quot;&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h2><p>name属性主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;。</div></pre></td></tr></table></figure>\n<p>常用有以下几种参数</p>\n<ol>\n<li><p>keywords 用于告诉搜索引擎，你网页的关键字。<br><code>&lt;meta name=&quot;keywords&quot; content=&quot;博客，前端&quot;&gt;</code></p>\n</li>\n<li><p>description 用于告诉搜索引擎，你网站的主要内容。<br><code>&lt;meta name=&quot;description&quot; content=&quot;热爱前端与编程，这是我的个人前端博客&quot;&gt;</code></p>\n</li>\n<li><p>viewport 常用于设计移动端网页<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</code></p>\n</li>\n<li><p>robots 告诉爬虫哪些页面需要索引，哪些页面不需要索引。<br><code>&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt;</code></p>\n</li>\n<li><p>author 用于标注网页作者<br><code>&lt;meta name=&quot;author&quot; content=&quot;Robin&quot;&gt;</code></p>\n</li>\n<li><p>generator 用于标明网页是什么软件做的<br><code>&lt;meta name=&quot;generator&quot; content=&quot;Sublime Text3&quot;&gt;</code></p>\n</li>\n<li><p>copyright 用于标注版权信息<br><code>&lt;meta name=&quot;copyright&quot; content=&quot;个人版权所有&quot;&gt;</code></p>\n</li>\n<li><p>revisit-after 搜索引擎爬虫重访时间<br><code>&lt;meta name=&quot;revisit-after&quot; content=&quot;7 days&quot; &gt;</code></p>\n</li>\n<li><p>renderer 双核浏览器渲染方式<br><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; //默认webkit内核</code></p>\n</li>\n</ol>\n<h2 id=\"http-equiv\"><a href=\"#http-equiv\" class=\"headerlink\" title=\"http-equiv\"></a>http-equiv</h2><p>这个枚举属性定义了能改变服务器和用户引擎行为的编译。这个编译值使用content 来定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;</div></pre></td></tr></table></figure>\n<p>常用的参数如下</p>\n<ol>\n<li>content-Type 用于设定网页字符集，便于浏览器解析与渲染页面</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;  //旧的HTML，不推荐</div><div class=\"line\">&lt;meta charset=&quot;utf-8&quot;&gt; //HTML5设定网页字符集的方式，推荐使用UTF-8</div></pre></td></tr></table></figure>\n<ol>\n<li><p>X-UA-Compatible 浏览器采取何种版本渲染当前页面<br><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; //指定IE和Chrome使用最新版本渲染当前页面</code></p>\n</li>\n<li><p>refresh 网页将在设定的时间内，自动刷新并调向设定的网址。<br><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2；URL=https://www.github.com/&quot;&gt; //意思是2秒后跳转向Github</code></p>\n</li>\n<li><p>Set-Cookie 如果网页过期。那么这个网页存在本地的cookies也会被自动删除。<br><code>&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;User=Robin; path=/; expires=Sunday, 10-Jan-17 10:00:00 GMT&quot;&gt;</code></p>\n</li>\n<li><p>expires 用于设定网页的到期时间，过期后网页必须到服务器上重新传输。<br><code>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Sunday 26 June 2017 01:00 GMT&quot; /&gt;</code></p>\n</li>\n<li><p>cache-control 指定请求和响应遵循的缓存机制（http 1.1）<br><code>&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</code><br>这表示先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</p>\n</li>\n<li><p>pragma 也是一个缓存机制属性，是http 1.0的<br><code>&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;</code></p>\n</li>\n</ol>\n<p><strong>http-equiv非常重要的一个用途是用来做http缓存控制，cache-control、expires配合last-modify等以及etag使用</strong>，这里不做赘述</p>\n<h1 id=\"语法与属性\"><a href=\"#语法与属性\" class=\"headerlink\" title=\"语法与属性\"></a>语法与属性</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><ol>\n<li>标签大小写皆可；</li>\n<li>布尔值属性若为true只需要写属性即可，例如checked=‘true’不需要写成checked=’checked’，可以写成checked；</li>\n<li>属性可以省略引号，但若属性中有空格则必须加上引号；<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2></li>\n<li>script的defer、async属性；</li>\n<li>内部作用域样式；</li>\n<li>data-key自定义属性；</li>\n<li>tabindex表示tab键的先后顺序；</li>\n<li>contenteditable页面内容是否可以编辑；</li>\n<li>designMode，写在script中的js属性，值为on时，表示整个页面内容皆可编辑；</li>\n</ol>\n","categories":["前端"],"tags":["HTML"]},{"title":"前端基础知识大纲","url":"http://yoursite.com/2017/07/28/前端基础知识大纲/","content":"<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><p><img src=\"/images/HTML.png\" alt=\"HTML知识总结\"></p>\n<h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1><p><img src=\"/images/CSS.png\" alt=\"CSS知识总结\"></p>\n<h1 id=\"ECMAScript\"><a href=\"#ECMAScript\" class=\"headerlink\" title=\"ECMAScript\"></a>ECMAScript</h1><p><img src=\"/images/ECMAScript.png\" alt=\"ECMAScript知识总结\"></p>\n<h1 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h1><p><img src=\"/images/DOM.png\" alt=\"DOM知识点\"></p>\n<h1 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h1><p><img src=\"/images/BOM.png\" alt=\"BOM知识点\"></p>\n","categories":["前端"],"tags":["知识体系"]},{"title":"","url":"http://yoursite.com/css/fexo-personal.css","content":"\n/* 修改字体大小和颜色 */\n.article-content p, .article-content ul, .article-content ol {\n\tfont-size: 16px;\n\tcolor: #2f2f2f;\n}\n.article-content h1, .article-content h2, .article-content h3, .article-content h4, .article-content h5, .article-content h6 {\n\tmargin-left: -50px;\n\tfont-weight: bold;\n}\n/* 修改段落样式 */\n.article-content p {\n\tmargin: 1em 0 0 0;\n\tline-height: 1.8em;\n}\n.article-content li > p {\n\tmargin-top: 0;\n}\n\n/* p后面紧跟列表 */\n.article-content p + ol, .article-content p + ul {\n\tmargin-top: 0;\n}\n\n/* 设置一级列表的行高 */\nli{\n\tline-height: 1.8em;\n}\n/* 设置二级列表的行高 */\nli li {\n\tline-height: 1.5em;\n}\n\n/* 修改list-style 小圆点 颜色*/\n.article-content ul li:before {\n\tbackground-color: #555;\n}\n\n/*toc 样式*/\n/*.toc-level-1 > a {\n\t\n\tfont-size: 18px;\n}\n.toc-level-2 > a {\n\tfont-size: 16px;\n}\n.toc-level-3 > a {\n\tfont-size: 14px;\n}\n.toc-level-4 > a {\n\tfont-size: 12px;\n}*/\n.toc-article ol {\n\tpadding-left: 20px;\n}\n\n\n","categories":[],"tags":[]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://yoursite.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"tags","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]}]