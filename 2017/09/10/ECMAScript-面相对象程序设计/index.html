<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>ECMAScript-面向对象程序设计 | Robin的技术博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="JavaScript," />
  

  <meta name="description" content="对象的属性数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。  [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript-面向对象程序设计">
<meta property="og:url" content="http://yoursite.com/2017/09/10/ECMAScript-面相对象程序设计/index.html">
<meta property="og:site_name" content="Robin的技术博客">
<meta property="og:description" content="对象的属性数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。  [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/prototype.png">
<meta property="og:image" content="http://yoursite.com/images/组合继承.png">
<meta property="og:image" content="http://yoursite.com/images/ES5继承.png">
<meta property="og:image" content="http://yoursite.com/images/ES6继承.png">
<meta property="og:image" content="http://yoursite.com/images/闭包.png">
<meta property="og:updated_time" content="2017-09-12T07:30:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ECMAScript-面向对象程序设计">
<meta name="twitter:description" content="对象的属性数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。  [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像">
<meta name="twitter:image" content="http://yoursite.com/images/prototype.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/fexo-personal.css">
  

  

  

  


  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archive/"
            rel="noopener noreferrer"
            target="_self"
            >
            归档
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#对象的属性"><span class="toc-text">对象的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据属性"><span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问器属性"><span class="toc-text">访问器属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义多个属性"><span class="toc-text">定义多个属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读取属性的特性"><span class="toc-text">读取属性的特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建对象"><span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂模式"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数模式"><span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型模式"><span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合使用构造函数模式和原型模式"><span class="toc-text">组合使用构造函数模式和原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态原型模式"><span class="toc-text">动态原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寄生构造函数模式"><span class="toc-text">寄生构造函数模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#稳妥构造函数模式"><span class="toc-text">稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class"><span class="toc-text">Class</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#class基本含义"><span class="toc-text">class基本含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructor方法"><span class="toc-text">constructor方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class不存在变量提升"><span class="toc-text">Class不存在变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class表达式"><span class="toc-text">class表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建私有方法"><span class="toc-text">创建私有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this的指向"><span class="toc-text">this的指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class的静态方法，静态属性和实例属性"><span class="toc-text">class的静态方法，静态属性和实例属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原型"><span class="toc-text">原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为对象扩展属性"><span class="toc-text">为对象扩展属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测自有属性和原型属性"><span class="toc-text">检测自有属性和原型属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获得对象的原型"><span class="toc-text">获得对象的原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测原型"><span class="toc-text">检测原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改对象的原型"><span class="toc-text">修改对象的原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型链"><span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#借用构造函数"><span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合继承"><span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型式继承"><span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寄生式继承"><span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寄生组合式继承"><span class="toc-text">寄生组合式继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class继承"><span class="toc-text">class继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用super"><span class="toc-text">使用super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的prototype属性和proto属性"><span class="toc-text">类的prototype属性和proto属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解ES5和ES6继承的不同"><span class="toc-text">图解ES5和ES6继承的不同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数表达式"><span class="toc-text">函数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#含义"><span class="toc-text">含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包详解"><span class="toc-text">闭包详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包的应用"><span class="toc-text">闭包的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步操作"><span class="toc-text">异步操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator"><span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Async"><span class="toc-text">Async</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-ECMAScript-面相对象程序设计" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">ECMAScript-面向对象程序设计</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.09.10</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Robin He</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/category/前端/">前端</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="https://www.github.com/helongbin/2017/09/10/ECMAScript-面相对象程序设计/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h1><h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。</li>
</ul>
<p>像例子中那样直接在对象上定义的属性,它们的 [[Configurable]] 、 [[Enumerable]] 和 [[Writable]] 特性都被设置为 true ,而 [[Value]] 特性被设置为”Nicholas”。例如: var person = { name: “Nicholas” };</p>
<ol>
<li>要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改对应的特性值。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">  writable: <span class="literal">false</span>,</div><div class="line">  value: <span class="string">"Nicholas"</span></div><div class="line">&#125;);</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div><div class="line">person.name = <span class="string">"Greg"</span>;</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为undefined。</li>
<li>[[Set]]：在写入属性时调用的函数。默认值为undefined。</li>
</ul>
<p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">  _year: <span class="number">2004</span>,</div><div class="line">  edition: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">  &#125;,</div><div class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">      <span class="keyword">this</span>._year = newValue;</div><div class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>要创建访问器属性，一般都使用两个非标准的方法：defineGetter()和defineSetter()。<br>在不支持 Object.defineProperty() 方法的浏览器中不能修改 [[Configurable]] 和 [[Enumerable]] 。</p>
<h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>
<h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get 和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value</p>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>用函数来封装以特定接口创建对象的细节<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"> o.name = name;</div><div class="line"> o.age = age;</div><div class="line"> o.job = job;</div><div class="line"> o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   alert(<span class="keyword">this</span>.name);</div><div class="line"> &#125;;</div><div class="line"> <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure></p>
<p>可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。<br><strong>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</strong></p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"> <span class="keyword">this</span>.name = name;</div><div class="line"> <span class="keyword">this</span>.age = age;</div><div class="line"> <span class="keyword">this</span>.job = job;</div><div class="line"> <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   alert(<span class="keyword">this</span>.name);</div><div class="line"> &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>以上相对于工厂模式有三个不同之处</p>
<ul>
<li>没有显式地创建对象；</li>
<li>直接将属性和方法赋给了this对象；</li>
<li>没有return语句。</li>
</ul>
<p>以这种方式调用构造函数实际上会经历以下 4个步骤： </p>
<ul>
<li>创建一个新对象； </li>
<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； </li>
<li>执行构造函数中的代码（为这个新对象添加属性）； </li>
<li>返回新对象。</li>
</ul>
<p><strong>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍</strong></p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h2><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="keyword">constructor</span> : Person,</div><div class="line">  sayName : function()&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="comment">//方法</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</div><div class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><p>工厂模式的变种，少用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  o.name = name;</div><div class="line">  o.age = age;</div><div class="line">  o.job = job;</div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div></pre></td></tr></table></figure>
<h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><p>稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  <span class="comment">//可以在这里定义私有变量和函数</span></div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div></pre></td></tr></table></figure>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><h2 id="class基本含义"><a href="#class基本含义" class="headerlink" title="class基本含义"></a>class基本含义</h2><p>类就是构造函数，可以使用new命令， 类的方法都定义在类的protopyte属性上，<br>prototype对象的constructor属性指向类本身，类内部定义的所有方法都是不可枚举的（和ES5不一致）</p>
<p>定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<h2 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h2><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<p>constructor方法默认返回实例对象（即this）</p>
<p><strong>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line">point.toString() <span class="comment">// (2, 3)</span></div><div class="line">point.hasOwnProperty(<span class="string">'x'</span>) <span class="comment">// true</span></div><div class="line">point.hasOwnProperty(<span class="string">'y'</span>) <span class="comment">// true</span></div><div class="line">point.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></div><div class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。</p>
<p>可以通过实例的<strong>proto</strong>属性为Class添加方法。</p>
<h2 id="Class不存在变量提升"><a href="#Class不存在变量提升" class="headerlink" title="Class不存在变量提升"></a>Class不存在变量提升</h2><h2 id="class表达式"><a href="#class表达式" class="headerlink" title="class表达式"></a>class表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</div><div class="line">  getClassName() &#123;</div><div class="line">    <span class="keyword">return</span> Me.name;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p>
<h2 id="创建私有方法"><a href="#创建私有方法" class="headerlink" title="创建私有方法"></a>创建私有方法</h2><ul>
<li><p>将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">  foo (baz) &#123;</div><div class="line">    bar.call(<span class="keyword">this</span>, baz);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p>
<ul>
<li>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</li>
</ul>
<h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</div><div class="line">  printName(name = <span class="string">'there'</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</div><div class="line">  &#125;</div><div class="line">  print(text) &#123;</div><div class="line">    <span class="built_in">console</span>.log(text);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</div><div class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</div><div class="line">printName(); <span class="comment">// TypeError: Cannot read property 'print' of undefined</span></div></pre></td></tr></table></figure>
<p>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p>
<p><strong>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。如下</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种解决方法是使用箭头函数。<br>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</p>
<h2 id="class的静态方法，静态属性和实例属性"><a href="#class的静态方法，静态属性和实例属性" class="headerlink" title="class的静态方法，静态属性和实例属性"></a>class的静态方法，静态属性和实例属性</h2><ol>
<li>在一个方法前加上static关键字 ，表示该方法不会被实例继承，而是通过类来调用</li>
<li>父类的静态方法可以被子类继承</li>
<li>静态方法也是可以从super对象上调用的</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"> <span class="keyword">static</span> classMethod() &#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"> <span class="keyword">static</span> classMethod() &#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + <span class="string">', too'</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">Bar.classMethod();</div></pre></td></tr></table></figure>
<ol>
<li>类的静态属性只要在实例属性写法前面，加上static关键字就可以了。如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line"> static myStaticProp = 42;</div><div class="line">    </div><div class="line"> constructor() &#123;</div><div class="line">   console.log(MyClass.myProp); // 42</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="为对象扩展属性"><a href="#为对象扩展属性" class="headerlink" title="为对象扩展属性"></a>为对象扩展属性</h3><ol>
<li>自有属性：通过对象的引用添加的属性，其他对象无法访问</li>
<li>原型属性：通过原型对象添加的属性（也叫共有属性）</li>
</ol>
<h3 id="检测自有属性和原型属性"><a href="#检测自有属性和原型属性" class="headerlink" title="检测自有属性和原型属性"></a>检测自有属性和原型属性</h3><ol>
<li>先检查在整个原型关系上是否存在某个属性<br> var bool=“属性名” in 对象<br> 返回true则表示属性名包含在对象中或包含在原型对象中</li>
<li>检查自有属性<br> var bool=obj.hasOwnProperty(“属性名”);<br> 返回true:说明对象中包含指定属性名<br> 返回false：仅说明对象中没有，不代表原型对象中没有</li>
</ol>
<h3 id="获得对象的原型"><a href="#获得对象的原型" class="headerlink" title="获得对象的原型"></a>获得对象的原型</h3><ol>
<li>1通过构造函数的prototype属性获得</li>
<li>通过Object.getPrototypeOf(obj)获得</li>
</ol>
<h3 id="检测原型"><a href="#检测原型" class="headerlink" title="检测原型"></a>检测原型</h3><p>父对象.isPrototypeOf(子对象)</p>
<h3 id="修改对象的原型"><a href="#修改对象的原型" class="headerlink" title="修改对象的原型"></a>修改对象的原型</h3><p>将父对象设为子对象的原型</p>
<ol>
<li>Object.setPrototypeOf(子对象，父对象)</li>
<li>构造函数.prototype=父对象<br> 为之后构造函数创建的所有子对象，自动继承父对象，但必须在创建对象之前修改</li>
</ol>
<p><img src="/images/prototype.png" alt="原型示意图"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>继承是通过原型链实现的，而原型链是通过对象的<strong>proto</strong>属性实现的</strong><br>原型对象等于另一个类型的实例, 层层递进，就构成了实例与原型的链条。</p>
<p>问题：</p>
<ol>
<li>将实例赋值给另一个原型之后，那么该实例上的引用类型就会被另一个原型的所有实例共享</li>
<li>在创建子类型的实例时，不能向超类型的构造函数中传递参数</li>
</ol>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function SubType()&#123;SuperType.call(this)&#125;</div></pre></td></tr></table></figure>
<p>Subtype继承SuperType<br>函数不过是在特定环境中执行代码的对象，于是这样，SubType的实例就不会共享SuperType的引用类型了，而且在this后面子类型可以向超类型传参</p>
<p>但是，仍然把脱不了构造函数的问题：</p>
<ol>
<li>所有子类型都只能使用构造函数模式，那么每一个在子类型中创建的方法都不一样，无法做到函数复用</li>
<li>使用call无法做到子类型继承超类型的原型</li>
</ol>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>融合借用构造函数和原型链的优点，把需要实例继承的方法和属性定义在子类型或超类型的原型中，而需要实例独有的引用类型（数组或方法）和属性则定义在子类型和超类型的构造函数中；</p>
<p>实现了两种继承：</p>
<ol>
<li>call对象冒充，子类型的构造函数继承超类型的构造函数；这样，子类型的实例在创建时就使用了两个构造函数；</li>
<li><p>原型链继承，子类型继承超类型原型中的方法和属性</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">this.name=name;</div><div class="line">this.colors=[‘red’,’blue’,’green’];</div><div class="line">&#125;</div><div class="line">Person.prototype.sayName=function()&#123;</div><div class="line">console.log(this.name)</div><div class="line">&#125;;</div><div class="line">function Student(name,age)&#123;</div><div class="line">Person.call(this,name);</div><div class="line">//第一种继承：通过此方法可以让子类型Student的实例继承超类型Person，这样创建Student的实例时，同时会使用两个构造函数（Student和Person），</div><div class="line">//所以就算是未传参的colors数组也会在Student的实例上创建（构造函数中，创建实例时引用类型也是完全复制，而非仅仅复制地址）</div><div class="line">this.age=age;</div><div class="line">&#125;</div><div class="line">Student.prototype=new Person();//第二种继承</div><div class="line">Student.prototype.constructor=Student;</div><div class="line">Student.prototype.sayAge=function()&#123;</div><div class="line">console.log(this.age);</div><div class="line">&#125;;</div><div class="line">var s1=new Student(‘James’,29);</div><div class="line">s1.colors.push(‘black’);</div><div class="line">console.log(s1.colors);</div><div class="line">s1.sayName();</div><div class="line">s1.sayAge();</div><div class="line">var s2=new Student(‘Tom’,28);</div><div class="line">console.log(s2.colors);</div><div class="line">s2.sayName();</div><div class="line">s2.sayAge();</div><div class="line">console.log(s1.sayName===s2.sayName);//true Person的原型方法，继承且共享</div><div class="line">console.log(s1.sayAge===s2.sayAge);//true Student的原型方法，继承且共享</div><div class="line">console.log(Student.prototype.colors);//red blue green</div><div class="line">console.log(s2.colors);//red blue green</div><div class="line">console.log(Student.prototype.colors==s2.colors);//false 这三个语句说明实例中的引用类型colors不是继承原型的，而是构造函数创建的</div><div class="line">console.log(s1.colors===s2.colors);//false 通过构造函数Person.call(this,name)继承</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/images/组合继承.png" alt="组合继承"></p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">F.prototype=o;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES5的object.create()方法规范了原型式继承</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>因为组合式继承中SuperType.call(this,name)和SubType.prototype=new SuperType();都会调用超类型SuperType()，这样导致的结果就是：子类型SubType的原型中含有name，SubType的实例中也含有name，只不过实例中的name屏蔽了原型中的name；</p>
<p>但是调用了两次超类型，创建了两组name属性，浪费内存；</p>
<p>如果将组合式继承中的SubType.prototype=new SuperType();改为SubType.prototype=SuperType.prototype；那么这句话就不会调用超类型，仅仅是将超类型的原型赋给子类型的原型（此后超类型原型全等于子类型原型）；然后SubType.prototype.sayAge=function(){}；这样不仅子类型可以继承超类型原型，还能修改超类型原型，而且只调用了一次超类型</p>
<p>修改上面的组合式继承代码如下：<br>Person.call(this,name);<br>Student.prototype=Person.prototype;</p>
<h2 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h2><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承</p>
<h3 id="使用super"><a href="#使用super" class="headerlink" title="使用super"></a>使用super</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  &#125;</div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<ul>
<li>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</li>
<li>第二种情况，super作为对象时，指向父类的原型对象。</li>
</ul>
<h3 id="类的prototype属性和proto属性"><a href="#类的prototype属性和proto属性" class="headerlink" title="类的prototype属性和proto属性"></a>类的prototype属性和<strong>proto</strong>属性</h3><ol>
<li>子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</li>
<li>子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。</li>
</ol>
<h3 id="图解ES5和ES6继承的不同"><a href="#图解ES5和ES6继承的不同" class="headerlink" title="图解ES5和ES6继承的不同"></a>图解ES5和ES6继承的不同</h3><p><img src="/images/ES5继承.png" alt="ES5的继承"><br><img src="/images/ES6继承.png" alt="ES6的继承"></p>
<h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>之前说过可以递归时可以使用arguments.callee，但在严格模式下,不能通过脚本访问 arguments.callee ,访问这个属性会导致错误。不过,可以使用命名函数表达式来达成相同的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> num * f(num<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ol>
<li>为什么要用闭包：全局变量可共享，容易被污染<br> 局部变量虽然私有，但不可重用/共享</li>
<li>解决：3步：<ol>
<li>用大的方法将变量和操作变量的方法封装起来</li>
<li>在外层方法结尾，将操作变量的方法对象返回</li>
<li>在全局使用专门的方法名接住外层方法返回的函数对象 </li>
</ol>
</li>
<li>何时使用闭包：保护可共享可重用的局部变量</li>
<li>判断闭包：3特点<ol>
<li>一定是方法的嵌套</li>
<li>内层方法使用了外层方法的局部变量</li>
<li>内层方法被外层方法返回到外部，而且被反复调用</li>
</ol>
</li>
</ol>
<h3 id="闭包详解"><a href="#闭包详解" class="headerlink" title="闭包详解"></a>闭包详解</h3><ol>
<li><p>闭包的执行流程(如下图)</p>
<ol>
<li>声明提前，window中创建两个变量，fun为undefined，getCounter是个函数，在声明的同时会创建两个对象（函数体对象和函数作用域链对象），其中函数体对象中的作用域链属性指向了函数作用域链对象，函数作用域链对象中默认创建一个元素，该元素指向window </li>
<li><p>fun=getCounter()；  </p>
<p> 先执行右边，调用父函数，首先创建一个父函数的活动对象，并在其作用域链对象中推入一个新元素，该新元素指向了这个活动对象，并且活动对象中存入父函数的局部变量n；  </p>
<p> 父函数返回子函数，这表示在定义子函数，所以创建两个对象（子函数体对象和子函数作用域链对象），子函数体的作用域链属性指向子函数作用域链对象，并且子函数作用域链对象中默认创建两个元素，一个指向window，一个指向父函数的活动对象  </p>
<p> 父函数将子函数的引用地址赋值给fun，父函数调用结束，父函数的作用域链对象中弹出元素，结束对父函数活动对象的引用，但父函数活动对象不会被释放，因为子函数的作用域链对象中有元素正在引用父函数的活动对象</p>
</li>
<li><p>console.log(fun())，表示执行fun，此时将创建fun（子函数）的活动对象，并在子函数的作用域链中推入新元素，该元素指向这个活动对象；执行完毕后，子函数的作用域链对象弹出元素，结束对子函数活动对象的引用，子函数活动对象被释放</p>
</li>
<li>由此形成一条链，window全局变量fun指向子函数体，子函数体指向子函数作用域链，子函数作用域链指向window和父函数的活动对象，父函数活动对象中保存了局部变量n，只能通过fun访问该变量，所以闭包保护了可以共享的局部变量</li>
</ol>
</li>
<li><p>只要被window对象中全局变量引用的都不会被释放 （黑色箭头）<br>window全局对象中的变量fun引用了function(){return n++}，<br>function(){return n++}的作用域链属性引用着自己的作用域链对象，<br>该作用域链对象引用着getCounter的活动对象（）和window对象<br>==所以闭包占内存较大（多占了父函数的活动对象）==</p>
</li>
</ol>
<p><img src="/images/闭包.png" alt="闭包"></p>
<ol>
<li><p>父函数被引用多次的情况</p>
<ol>
<li>外层函数调用几次，就有几个受保护的局部变量<br>假如再var fun1=getCounter()，那么闭包的执行流程中第2步~第4步再执行一遍，两个子函数的地址不一样（因为匿名，所以再次执行的时候会再次分配一个地址存储函数体），所以会有两个子函数体对象，两个子函数作用域链对象，两个getCounter()活动对象，里面分别存储了1个n，所以共有2个受保护的局部变量</li>
<li><p>同一次外层函数调用返回的内层函数，都共享同一闭包中的局部变量。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> arr=[];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">			arr[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> i&#125;;	        <span class="comment">//arr[0],arr[1],arr[2]</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> arr;                        	  &#125;</div><div class="line"><span class="keyword">var</span> arr=fun1();                        </div><div class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]()); <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>]()); <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(arr[<span class="number">2</span>]()); <span class="comment">//3</span></div></pre></td></tr></table></figure>
<p>上面的函数有一个副作用，就是闭包只能取得包含函数中任何变量的最后一个值，可以通过再创建一个匿名函数，强制把自我及时执行的结果返回到数组中，如下代码：其实是闭包的嵌套；创建了3个闭包（每个闭包都包含一个匿名函数和一个变量m），每个闭包都有属于自己的一个变量m，自我及时执行的结果就是把i及时的赋给每一个m；从而3个m都不一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> arr=[];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">	arr[i]=<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> m</div><div class="line">		&#125;</div><div class="line">	&#125;(i);	<span class="comment">//强制把及时自我执行的结果返回到数组中</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> arr;  </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> arr=fun1();                        </div><div class="line">  <span class="built_in">console</span>.log(arr[<span class="number">0</span>]()); <span class="comment">//0</span></div><div class="line">  <span class="built_in">console</span>.log(arr[<span class="number">1</span>]()); <span class="comment">//1</span></div><div class="line">  <span class="built_in">console</span>.log(arr[<span class="number">2</span>]()); <span class="comment">//2</span></div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ol>
<li>内存泄露问题<br>在IE8中，闭包的作用域链中保存着一个HTML元素，那么最好是在不需要时将其值设为null，否则它占用的内存永远不会被回收</li>
<li>模仿块级作用域<br>一般在全局作用域，使用匿名函数(function(){var a;这里是私有作用域})()，既可以正常使用，又不怕内存占用和变量命名冲突，这样就创建了私有作用域，只要函数执行完毕，就可以立即销毁其作用域链了</li>
<li>私有变量？？？<br>如果在函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量，而利用这一点，就可以创建用于访问私有变量的公有方法：在构造函数中定义特权方法<ol>
<li>静态私有变量<br>通过在私有作用域中定义私有变量和函数，同样可以创建特权方法</li>
<li>模块模式<br>为以对象字面量定义的对象创建私有变量和特权方法</li>
<li>增强的模块模式</li>
</ol>
</li>
</ol>
<h1 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h1><p>==写的并不全, 简单记录了一下, 以后有时间再搞==</p>
<p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2>
    
  </div>
</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">觉得我的文章有帮助，可以支持一下</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/09/10/ECMAScript-引用类型/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/09/10/ECMAScript-基本语法/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archive/"
              rel="noopener noreferrer"
              target="_self"
              >
              归档
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://yoursite.com/2017/09/10/ECMAScript-面相对象程序设计/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
