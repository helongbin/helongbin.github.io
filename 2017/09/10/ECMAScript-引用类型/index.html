<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>ECMAScript-引用类型 | Robin的技术博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="JavaScript," />
  

  <meta name="description" content="Object类型创建对象的方式 new Object() 对象字面量var obj = {}; es6新方式ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 1234567var v = &apos;world&apos;;var obj = &amp;#123; v, method() &amp;#123;   return &apos;Hello!&apos;; &amp;#125;&amp;#125;;   访问对象的属性 点表示法 方括">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript-引用类型">
<meta property="og:url" content="http://yoursite.com/2017/09/10/ECMAScript-引用类型/index.html">
<meta property="og:site_name" content="Robin的技术博客">
<meta property="og:description" content="Object类型创建对象的方式 new Object() 对象字面量var obj = {}; es6新方式ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 1234567var v = &apos;world&apos;;var obj = &amp;#123; v, method() &amp;#123;   return &apos;Hello!&apos;; &amp;#125;&amp;#125;;   访问对象的属性 点表示法 方括">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-09-10T14:01:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ECMAScript-引用类型">
<meta name="twitter:description" content="Object类型创建对象的方式 new Object() 对象字面量var obj = {}; es6新方式ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 1234567var v = &apos;world&apos;;var obj = &amp;#123; v, method() &amp;#123;   return &apos;Hello!&apos;; &amp;#125;&amp;#125;;   访问对象的属性 点表示法 方括">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/fexo-personal.css">
  

  

  

  


  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archive/"
            rel="noopener noreferrer"
            target="_self"
            >
            归档
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Object类型"><span class="toc-text">Object类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象的方式"><span class="toc-text">创建对象的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问对象的属性"><span class="toc-text">访问对象的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性"><span class="toc-text">属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#name-对象方法的属性"><span class="toc-text">name(对象方法的属性)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proto属性"><span class="toc-text">proto属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hasOwnProperty-NaN"><span class="toc-text">hasOwnProperty()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isPrototypeOf-NaN"><span class="toc-text">isPrototypeOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#propertyIsEnumerable-NaN"><span class="toc-text">propertyIsEnumerable()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-keys"><span class="toc-text">Object.keys()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-getOwnPropertyNames"><span class="toc-text">Object.getOwnPropertyNames()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-preventExtensions"><span class="toc-text">Object.preventExtensions()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-isExtensible"><span class="toc-text">Object.isExtensible()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-seal"><span class="toc-text">Object.seal()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-isSealed"><span class="toc-text">Object.isSealed()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-freeze"><span class="toc-text">Object.freeze()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-isFrozen"><span class="toc-text">Object.isFrozen()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-getOwnPropertySymbols"><span class="toc-text">Object.getOwnPropertySymbols()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-create"><span class="toc-text">Object.create()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperty"><span class="toc-text">Object.defineProperty()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperties"><span class="toc-text">Object.defineProperties()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-getOwnPropertyDescriptor"><span class="toc-text">Object.getOwnPropertyDescriptor()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-is"><span class="toc-text">Object.is()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-assign"><span class="toc-text">Object.assign()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-setPrototypeOf"><span class="toc-text">Object.setPrototypeOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-getPrototypeOf"><span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-observe"><span class="toc-text">Object.observe()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-unobserve"><span class="toc-text">Object.unobserve()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rest参数-es7提案"><span class="toc-text">rest参数(es7提案)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展运算符（…）-es7提案"><span class="toc-text">扩展运算符（…）(es7提案)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断属性及原型"><span class="toc-text">判断属性及原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#判断自有属性"><span class="toc-text">判断自有属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断是否为原型"><span class="toc-text">判断是否为原型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Array-类型"><span class="toc-text">Array 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建数组"><span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性-1"><span class="toc-text">属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#length"><span class="toc-text">length</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法-1"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-isArray"><span class="toc-text">Array.isArray()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-和-join"><span class="toc-text">toString() 和 join()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push-和-pop"><span class="toc-text">push() 和 pop()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shift-和-unshift"><span class="toc-text">shift() 和 unshift()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverse-和-sort"><span class="toc-text">reverse() 和 sort()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concat-slice-和-splice"><span class="toc-text">concat(), slice() 和 splice()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexOf-和-lastIndexOf"><span class="toc-text">indexOf() 和 lastIndexOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#every-filter-forEach-map-some"><span class="toc-text">every(), filter(), forEach(), map(), some()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce-和-reduceRight"><span class="toc-text">reduce() 和 reduceRight()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-from-es6"><span class="toc-text">Array.from() (es6)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-of-es6"><span class="toc-text">Array.of() (es6)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-和-findIndex-es6"><span class="toc-text">find() 和 findIndex() (es6)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fill-es6"><span class="toc-text">fill() (es6)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#entries-，keys-和-values-es6"><span class="toc-text">entries()，keys() 和 values() (es6)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#includes-es7"><span class="toc-text">includes() (es7)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-observe-，Array-unobserve-es7"><span class="toc-text">Array.observe()，Array.unobserve() (es7)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检测数组"><span class="toc-text">检测数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Date-类型"><span class="toc-text">Date 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方法-2"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date-parse"><span class="toc-text">Date.parse()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date-UTC"><span class="toc-text">Date.UTC()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-now"><span class="toc-text">Data.now()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toLocaleString-toString-valueOf"><span class="toc-text">toLocaleString(), toString(), valueOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#日期格式化方法"><span class="toc-text">日期格式化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#日期-时间组件方法"><span class="toc-text">日期/时间组件方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RegExp-类型"><span class="toc-text">RegExp 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模式flags"><span class="toc-text">模式flags</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#y修饰符"><span class="toc-text">y修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例属性"><span class="toc-text">实例属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例方法"><span class="toc-text">实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exec"><span class="toc-text">exec()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#test"><span class="toc-text">test()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数属性"><span class="toc-text">构造函数属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Function-类型"><span class="toc-text">Function 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#声明函数"><span class="toc-text">声明函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数内部属性"><span class="toc-text">函数内部属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arguments"><span class="toc-text">arguments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#caller"><span class="toc-text">caller</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数属性"><span class="toc-text">函数属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#length-1"><span class="toc-text">length</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype"><span class="toc-text">prototype</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数方法"><span class="toc-text">函数方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#apply-和-call-bind"><span class="toc-text">apply() 和 call(), bind()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#默认参数"><span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rest参数"><span class="toc-text">rest参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展运算符"><span class="toc-text">扩展运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本包装类型"><span class="toc-text">基本包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Boolean-类型"><span class="toc-text">Boolean 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number-类型"><span class="toc-text">Number 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-类型"><span class="toc-text">String 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#length-2"><span class="toc-text">length</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#charAt-和-charCodeAt"><span class="toc-text">charAt()和 charCodeAt()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concat"><span class="toc-text">concat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice-、substr-和substring"><span class="toc-text">slice()、substr()和substring()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexOf-和lastIndexOf"><span class="toc-text">indexOf()和lastIndexOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trim"><span class="toc-text">trim()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toLowerCase-、toLocaleLowerCase-、toUpperCase-和toLocaleUpperCase-。"><span class="toc-text">toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#match-search-replace"><span class="toc-text">match(), search(), replace()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split"><span class="toc-text">split()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localeCompare"><span class="toc-text">localeCompare()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fromCharCode"><span class="toc-text">fromCharCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6方法"><span class="toc-text">es6方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#includes-startsWith-endsWith"><span class="toc-text">includes(), startsWith(), endsWith()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#repeat"><span class="toc-text">repeat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板字符串"><span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-raw"><span class="toc-text">String.raw()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单体内置对象"><span class="toc-text">单体内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Global对象"><span class="toc-text">Global对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math-对象"><span class="toc-text">Math 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-PI"><span class="toc-text">Math.PI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min-和-max-方法"><span class="toc-text">min() 和 max() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-ceil-Math-floor-Math-round"><span class="toc-text">Math.ceil(), Math.floor(), Math.round()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-random"><span class="toc-text">Math.random()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#键集合类型"><span class="toc-text">键集合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-类型"><span class="toc-text">Map 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例属性和方法"><span class="toc-text">实例属性和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历方法"><span class="toc-text">遍历方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与其他数据结构的互相转换"><span class="toc-text">与其他数据结构的互相转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakMap-类型"><span class="toc-text">WeakMap 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-类型"><span class="toc-text">Set 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法-1"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例的属性和方法"><span class="toc-text">实例的属性和方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakSet-类型"><span class="toc-text">WeakSet 类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反射类型"><span class="toc-text">反射类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflect"><span class="toc-text">Reflect</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#控制抽象类型"><span class="toc-text">控制抽象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Iteration-接口"><span class="toc-text">Iteration 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterable-接口"><span class="toc-text">Iterable 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-接口"><span class="toc-text">Iterator 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IteratorResult-接口"><span class="toc-text">IteratorResult 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例"><span class="toc-text">实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#默认实现Iterable接口的数据结构"><span class="toc-text">默认实现Iterable接口的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterable接口默认的应用场合"><span class="toc-text">Iterable接口默认的应用场合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原生具备Iterable接口的数据结构"><span class="toc-text">原生具备Iterable接口的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterable接口与Generator函数"><span class="toc-text">Iterable接口与Generator函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-类型"><span class="toc-text">Promise 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#含义"><span class="toc-text">含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本用法-2"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-prototype-then"><span class="toc-text">Promise.prototype.then()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-prototype-catch"><span class="toc-text">Promise.prototype.catch()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-all"><span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-race"><span class="toc-text">Promise.race()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-resolve"><span class="toc-text">Promise.resolve()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-reject"><span class="toc-text">Promise.reject()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator函数与Promise的结合"><span class="toc-text">Generator函数与Promise的结合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async函数"><span class="toc-text">async函数</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-ECMAScript-引用类型" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">ECMAScript-引用类型</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.09.10</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Robin He</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/category/前端/">前端</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="https://www.github.com/helongbin/2017/09/10/ECMAScript-引用类型/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h1><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><ol>
<li>new Object()</li>
<li>对象字面量var obj = {};</li>
<li>es6新方式<br>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v = <span class="string">'world'</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line"> v,</div><div class="line"> method() &#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">'Hello!'</span>;</div><div class="line"> &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="访问对象的属性"><a href="#访问对象的属性" class="headerlink" title="访问对象的属性"></a>访问对象的属性</h2><ol>
<li>点表示法</li>
<li>方括号<br> 相对于点表示法, 方括号有以下几个优点<ul>
<li>方括号内可以使用变量</li>
<li>如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法</li>
<li>ES6允许字面量定义对象时，把表达式放在方括号内作为属性名。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> lastWord = <span class="string">'last word'</span>;</div><div class="line">    </div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  <span class="string">'first word'</span>: <span class="string">'hello'</span>,</div><div class="line">  [lastWord]: <span class="string">'world'</span>,</div><div class="line">  [<span class="string">'h'</span>+<span class="string">'ello'</span>]() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="name-对象方法的属性"><a href="#name-对象方法的属性" class="headerlink" title="name(对象方法的属性)"></a>name(对象方法的属性)</h3><p>函数的name属性，返回函数名。ES6为对象方法也添加了name属性。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;,</div><div class="line">  get firstName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Nicholas"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">person.sayName.name   <span class="comment">// "sayName"</span></div><div class="line">person.firstName.name <span class="comment">// "get firstName"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，方法的name属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上get。如果是存值函数，方法名的前面会加上set。</p>
<p>有两种特殊情况：bind方法创造的函数，name属性返回“bound”加上原函数的名字；Function构造函数创造的函数，name属性返回“anonymous”。</p>
<h3 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a><strong>proto</strong>属性</h3><p>用来读取或设置当前对象的prototype对象。该属性一度被正式写入ES6草案，但后来又被移除。目前，所有浏览器（包括IE11）都部署了这个属性。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3><p>obj.hasOwnProperty(prop)方法用来判断某个对象是否含有指定的自身属性。</p>
<h3 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h3><p>prototype.isPrototypeOf(object)方法测试一个对象是否存在于另一个对象的原型链上。</p>
<h3 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable()"></a>propertyIsEnumerable()</h3><p>obj.propertyIsEnumerable(prop)方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性。</p>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。</p>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。</p>
<h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h3><p>方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</p>
<h3 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h3><p>方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</p>
<h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h3><p>方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。</p>
<h3 id="Object-isSealed"><a href="#Object-isSealed" class="headerlink" title="Object.isSealed()"></a>Object.isSealed()</h3><p>方法判断一个对象是否是密封的（sealed）。</p>
<h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h3><p>方法可以冻结一个对象。冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。</p>
<h3 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen()"></a>Object.isFrozen()</h3><p>方法判断一个对象是否被冻结（frozen）。</p>
<h3 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h3><p>方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键。</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>Object.create(Object.prototype, { a: { value: 1, writable: true, configurable: true } });<br>创建一个继承自Object.prototype的对象，有一个属性a，其可写，可配置，不可枚举，值为1。</p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>Object.defineProperty(obj, prop, descriptor)</p>
<h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h3><p>Object.defineProperties(obj, props)</p>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p>返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</p>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。只要有一个参数不是对象，就会抛出TypeError错误。</p>
<p><strong>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</strong></p>
<ol>
<li>assign方法有很多用处。  <ol>
<li>为对象添加属性和方法</li>
<li>克隆对象</li>
<li>合并多个对象</li>
<li>为属性指定默认值</li>
</ol>
</li>
</ol>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>Object.setPrototypeOf(object, prototype)<br>作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。</p>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>Object.getPrototypeOf(obj);<br>与setPrototypeOf方法配套，用于读取一个对象的prototype对象。</p>
<h3 id="Object-observe"><a href="#Object-observe" class="headerlink" title="Object.observe()"></a>Object.observe()</h3><p>监听对象（以及数组）的变化。一旦监听对象发生变化，就会触发回调函数。(es7)<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.observe(user, <span class="function"><span class="keyword">function</span>(<span class="params">changes</span>)</span>&#123;</div><div class="line">  changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change</span>) </span>&#123;</div><div class="line">    user.fullName = user.firstName+<span class="string">" "</span>+user.lastName;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">user.firstName = <span class="string">'Michael'</span>;</div><div class="line">user.lastName = <span class="string">'Jackson'</span>;</div><div class="line">user.fullName <span class="comment">// 'Michael Jackson'</span></div></pre></td></tr></table></figure></p>
<ol>
<li>changes <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var o = &#123;&#125;;</div><div class="line"></div><div class="line">function observer(changes)&#123;</div><div class="line">  changes.forEach(function(change) &#123;</div><div class="line">    console.log(&apos;发生变动的属性：&apos; + change.name);</div><div class="line">    console.log(&apos;变动前的值：&apos; + change.oldValue);</div><div class="line">    console.log(&apos;变动后的值：&apos; + change.object[change.name]);</div><div class="line">    console.log(&apos;变动类型：&apos; + change.type);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Object.observe(o, observer);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>参照上面代码，Object.observe方法指定的回调函数，接受一个数组（changes）作为参数。该数组的成员与对象的变化一一对应，也就是说，对象发生多少个变化，该数组就有多少个成员。每个成员是一个对象（change），它的name属性表示发生变化源对象的属性名，oldValue属性表示发生变化前的值，object属性指向变动后的源对象，type属性表示变化的种类。基本上，change对象是下面的样子。</p>
<ol>
<li>可以监听六种变化。<ul>
<li>add：添加属性</li>
<li>update：属性值的变化</li>
<li>delete：删除属性</li>
<li>setPrototype：设置原型</li>
<li>reconfigure：属性的attributes对象发生变化</li>
<li>preventExtensions：对象被禁止扩展（当一个对象变得不可扩展时，也就不必再监听了）</li>
</ul>
</li>
<li>可以有第三个参数<br>Object.observe(o, observer, [‘delete’]);<br>Object.observe方法还可以接受第三个参数，用来指定监听的事件种类。</li>
</ol>
<h3 id="Object-unobserve"><a href="#Object-unobserve" class="headerlink" title="Object.unobserve()"></a>Object.unobserve()</h3><p>Object.unobserve(o, observer);<br>用来取消监听。</p>
<h3 id="rest参数-es7提案"><a href="#rest参数-es7提案" class="headerlink" title="rest参数(es7提案)"></a>rest参数(es7提案)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div></pre></td></tr></table></figure>
<h3 id="扩展运算符（…）-es7提案"><a href="#扩展运算符（…）-es7提案" class="headerlink" title="扩展运算符（…）(es7提案)"></a>扩展运算符（…）(es7提案)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</div><div class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div></pre></td></tr></table></figure>
<ol>
<li><strong>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</strong></li>
<li>如果扩展运算符的参数是null或undefined，这个两个值会被忽略，不会报错。</li>
</ol>
<h2 id="判断属性及原型"><a href="#判断属性及原型" class="headerlink" title="判断属性及原型"></a>判断属性及原型</h2><h3 id="判断自有属性"><a href="#判断自有属性" class="headerlink" title="判断自有属性"></a>判断自有属性</h3><ol>
<li>使用in关键字判断对象的自有属性和继承来的属性是否存在</li>
<li>object.hasOwnProperty()判断是否为自有属性</li>
</ol>
<h3 id="判断是否为原型"><a href="#判断是否为原型" class="headerlink" title="判断是否为原型"></a>判断是否为原型</h3><ol>
<li><h1 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</div><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含3 个字符串的数组</span></div><div class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></div></pre></td></tr></table></figure>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><ol>
<li>该属性不是只读的, 可以设置该属性移除或添加数组项 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">colors[<span class="number">99</span>] = <span class="string">"black"</span>;</div><div class="line">alert(colors.length); <span class="comment">// 100</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p>和instanceof 操作符类似但更好使用</p>
<h3 id="toString-和-join"><a href="#toString-和-join" class="headerlink" title="toString() 和 join()"></a>toString() 和 join()</h3><h3 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push() 和 pop()"></a>push() 和 pop()</h3><h3 id="shift-和-unshift"><a href="#shift-和-unshift" class="headerlink" title="shift() 和 unshift()"></a>shift() 和 unshift()</h3><h3 id="reverse-和-sort"><a href="#reverse-和-sort" class="headerlink" title="reverse() 和 sort()"></a>reverse() 和 sort()</h3><ol>
<li>sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数</li>
</ol>
<h3 id="concat-slice-和-splice"><a href="#concat-slice-和-splice" class="headerlink" title="concat(), slice() 和 splice()"></a>concat(), slice() 和 splice()</h3><ol>
<li>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</li>
<li>slice()能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下, slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数,该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意, slice() 方法不会影响原始数组。注意, slice() 方法不会影响原始数组。</li>
<li>splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下3种。<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。</li>
</ul>
</li>
</ol>
<p><strong>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。</strong></p>
<h3 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf() 和 lastIndexOf()"></a>indexOf() 和 lastIndexOf()</h3><p>这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。</p>
<h3 id="every-filter-forEach-map-some"><a href="#every-filter-forEach-map-some" class="headerlink" title="every(), filter(), forEach(), map(), some()"></a>every(), filter(), forEach(), map(), some()</h3><ol>
<li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回 true。</li>
<li>filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</li>
</ol>
<p>==以上方法都不会修改数组中的包含的值。==</p>
<h3 id="reduce-和-reduceRight"><a href="#reduce-和-reduceRight" class="headerlink" title="reduce() 和 reduceRight()"></a>reduce() 和 reduceRight()</h3><p>两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收 4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum); <span class="comment">//15</span></div><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div></pre></td></tr></table></figure></p>
<h3 id="Array-from-es6"><a href="#Array-from-es6" class="headerlink" title="Array.from() (es6)"></a>Array.from() (es6)</h3><p>用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）</p>
<ol>
<li>Array.from方法可以将函数的arguments对象，转为数组。</li>
<li>任何有length属性的对象，都可以通过Array.from方法转为数组。</li>
<li>Array.from()还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理。</li>
<li>Array.from()的一个应用是，将字符串转为数组，然后返回字符串的长度。</li>
</ol>
<h3 id="Array-of-es6"><a href="#Array-of-es6" class="headerlink" title="Array.of() (es6)"></a>Array.of() (es6)</h3><p>用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。Array(3) // [undefined, undefined, undefined]</p>
<h3 id="find-和-findIndex-es6"><a href="#find-和-findIndex-es6" class="headerlink" title="find() 和 findIndex() (es6)"></a>find() 和 findIndex() (es6)</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<ol>
<li><p>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
</li>
<li><p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
</li>
<li><p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>
</li>
</ol>
<h3 id="fill-es6"><a href="#fill-es6" class="headerlink" title="fill() (es6)"></a>fill() (es6)</h3><p>使用给定值，填充一个数组。fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<h3 id="entries-，keys-和-values-es6"><a href="#entries-，keys-和-values-es6" class="headerlink" title="entries()，keys() 和 values() (es6)"></a>entries()，keys() 和 values() (es6)</h3><p>用于遍历数组。它们都返回一个既实现了Iterable又实现了Iterator接口的对象，且该对象Symbol.iterator方法返回其自身，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<h3 id="includes-es7"><a href="#includes-es7" class="headerlink" title="includes() (es7)"></a>includes() (es7)</h3><p>返回一个布尔值，表示某个数组是否包含给定的值。该方法属于ES7。该方法的第二个参数表示搜索的起始位置，默认为0。</p>
<h3 id="Array-observe-，Array-unobserve-es7"><a href="#Array-observe-，Array-unobserve-es7" class="headerlink" title="Array.observe()，Array.unobserve() (es7)"></a>Array.observe()，Array.unobserve() (es7)</h3><p>这两个方法用于监听（取消监听）数组的变化，指定回调函数。</p>
<p>它们的用法与Object.observe和Object.unobserve方法完全一致，也属于ES7的一部分，唯一的区别是，对象可监听的变化一共有六种，而数组只有四种：add、update、delete、splice（数组的length属性发生变化）</p>
<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>JavaScript有五种方法可以确定一个值到底是什么类型，分别是typeof运算符，constructor法，instanceof运算符，Object.prototype.toString方法以及Array.isArray法.</p>
<ol>
<li>instanceof运算符可以用来判断某个构造函数的prototype属性所指向的對象是否存在于另外一个要检测对象的原型链上。<br>console.log(a instanceof Array);//true</li>
<li>实例化的数组拥有一个constructor属性，这个属性指向生成这个数组的方法。<br>console.log(a.constructor);//function Array(){ [native code] }</li>
<li>Object的toString方法判断<br>Object.prototype.toString.call(a);//“[object Array]”</li>
<li>Array对象的isArray方法判断</li>
</ol>
<h1 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h1><ol>
<li>在调用Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象,必须传入表示该日期的毫秒数(即从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数)。</li>
</ol>
<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><h3 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h3><p>接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。</p>
<h3 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h3><p>同样也返回表示日期的毫秒数，但它与 Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于 0的月份（一月是 0，二月是 1，以此类推）、月中的哪一天（1到 31）、小时数（0到 23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。</p>
<h3 id="Data-now"><a href="#Data-now" class="headerlink" title="Data.now()"></a>Data.now()</h3><p>返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Data对象分析代码的工作。</p>
<h3 id="toLocaleString-toString-valueOf"><a href="#toLocaleString-toString-valueOf" class="headerlink" title="toLocaleString(), toString(), valueOf()"></a>toLocaleString(), toString(), valueOf()</h3><p>Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。</p>
<p>至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。</p>
<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><ol>
<li>Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。<ul>
<li>toDateString()——以特定于实现的格式显示星期几、月、日和年；</li>
<li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li>
<li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；</li>
<li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒；</li>
<li>toUTCString()——以特定于实现的格式完整的UTC日期。</li>
</ul>
</li>
</ol>
<p>与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。</p>
<h3 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getTime()</td>
<td>返回表示日期的毫秒数;与 valueOf() 方法返回的值相同</td>
</tr>
<tr>
<td>setTime( 毫秒 )</td>
<td>以毫秒数设置日期,会改变整个日期</td>
</tr>
<tr>
<td>getFullYear()</td>
<td>取得4位数的年份(如2007而非仅07)</td>
</tr>
<tr>
<td>getUTCFullYear()</td>
<td>返回UTC日期的4位数年份</td>
</tr>
<tr>
<td>setFullYear( 年 )</td>
<td>设置日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td>
</tr>
<tr>
<td>setUTCFullYear( 年 )</td>
<td>设置UTC日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>返回日期中的月份,其中0表示一月,11表示十二月</td>
</tr>
<tr>
<td>getUTCMonth()</td>
<td>返回UTC日期中的月份,其中0表示一月,11表示十二月</td>
</tr>
<tr>
<td>setMonth( 月 )</td>
<td>设置日期的月份。传入的月份值必须大于0,超过11则增加年份</td>
</tr>
<tr>
<td>setUTCMonth( 月 )</td>
<td>设置UTC日期的月份。传入的月份值必须大于0,超过11则增加年份</td>
</tr>
<tr>
<td>getDate()</td>
<td>返回日期月份中的天数(1到31)</td>
</tr>
<tr>
<td>getUTCDate()</td>
<td>返回UTC日期月份中的天数(1到31)</td>
</tr>
<tr>
<td>setDate( 日 )</td>
<td>设置日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td>
</tr>
<tr>
<td>setUTCDate( 日 )</td>
<td>设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td>
</tr>
<tr>
<td>getDay()</td>
<td>返回日期中星期的星期几(其中0表示星期日,6表示星期六)</td>
</tr>
<tr>
<td>getUTCDay()</td>
<td>返回UTC日期中星期的星期几(其中0表示星期日,6表示星期六)</td>
</tr>
<tr>
<td>getHours()</td>
<td>返回日期中的小时数(0到23)</td>
</tr>
<tr>
<td>getUTCHours()</td>
<td>返回UTC日期中的小时数(0到23)</td>
</tr>
<tr>
<td>setHours( 时 )</td>
<td>设置日期中的小时数。传入的值超过了23则增加月份中的天数</td>
</tr>
<tr>
<td>setUTCHours( 时 )</td>
<td>设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>返回日期中的分钟数(0到59)</td>
</tr>
<tr>
<td>getUTCMinutes()</td>
<td>返回UTC日期中的分钟数(0到59)</td>
</tr>
<tr>
<td>setMinutes( 分 )</td>
<td>设置日期中的分钟数。传入的值超过59则增加小时数</td>
</tr>
<tr>
<td>setUTCMinutes( 分 )</td>
<td>设置UTC日期中的分钟数。传入的值超过59则增加小时数</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>返回日期中的秒数(0到59)</td>
</tr>
<tr>
<td>getUTCSeconds()</td>
<td>返回UTC日期中的秒数(0到59)</td>
</tr>
<tr>
<td>setSeconds( 秒 )</td>
<td>设置日期中的秒数。传入的值超过了59会增加分钟数</td>
</tr>
<tr>
<td>setUTCSeconds( 秒 )</td>
<td>设置UTC日期中的秒数。传入的值超过了59会增加分钟数</td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>返回日期中的毫秒数</td>
</tr>
<tr>
<td>getUTCMilliseconds()</td>
<td>返回UTC日期中的毫秒数</td>
</tr>
<tr>
<td>setMilliseconds( 毫秒 )</td>
<td>设置日期中的毫秒数</td>
</tr>
<tr>
<td>setUTCMilliseconds( 毫秒 )</td>
<td>设置UTC日期中的毫秒数</td>
</tr>
<tr>
<td>getTimezoneOffset()</td>
<td>返回本地时间与UTC时间相差的分钟数。例如,美国东部标准时间返回300。在某地进入夏令时的情况下,这个值会有所变化</td>
</tr>
</tbody>
</table>
<h1 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;,不区分大小写</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line">// 与 pattern1 相同,只不过是使用构造函数创建的</div><div class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</div></pre></td></tr></table></figure>
<ol>
<li>模式中使用的所有元字符都必须转义。正则表达式中的元字符包括： ( [ { \ ^ $ | ) ? * + .]}</li>
<li>由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n（字符\在字符串中通常被转义为\，而在正则表达式字符串中就会变成\\）。</li>
<li>==正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。==</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var re = null, i;</div><div class="line">for (i=0; i &lt; 10; i++)&#123;</div><div class="line">  re = /cat/g;</div><div class="line">  re.test(&quot;catastrophe&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>循环中,即使是循环体中指定的,但实际上只为 /cat/ 创建了一个 RegExp 实例。由于实例属性(下一节介绍实例属性)不会重置,所以在循环中再次调用 test() 方法会失败。这是因为第一次调用 test() 找到了 “cat” ,但第二次调用是从索引为 3 的字符(上一次匹配的末尾)开始的,所以就找不到它了。由于会测试到字符串末尾,所以下一次再调用 test() 就又从开头开始了。</p>
<p>ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例</p>
<h2 id="模式flags"><a href="#模式flags" class="headerlink" title="模式flags"></a>模式flags</h2><ul>
<li>g :表示全局(global)模式,即模式将被应用于所有字符串,而非在发现第一个匹配项时立即停止;</li>
<li>i :表示不区分大小写(case-insensitive)模式,即在确定匹配项时忽略模式与字符串的大小写;</li>
<li>m :表示多行(multiline)模式,即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。<br>ES6中新增两个标志</li>
<li>u :表示“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</li>
<li>y :表示“粘连”（sticky）模式。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</li>
</ul>
<h3 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h3><ol>
<li><p>y修饰符号隐含了头部匹配的标志ˆ。y修饰符的设计本意，就是让头部匹配的标志ˆ在全局匹配中都有效。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var s = &quot;aaa_aa_a&quot;;</div><div class="line">var r1 = /a+/g;</div><div class="line">var r2 = /a+/y;</div><div class="line">r1.exec(s) // [&quot;aaa&quot;]</div><div class="line">r2.exec(s) // [&quot;aaa&quot;]</div><div class="line">r1.exec(s) // [&quot;aa&quot;]</div><div class="line">//和g一样都是从_aa_a开始，但是y标志要求必须以a开头，所以返回null</div><div class="line">r2.exec(s) // null</div></pre></td></tr></table></figure>
</li>
<li><p>如果同时使用g修饰符和y修饰符，则y修饰符覆盖g修饰符。</p>
</li>
</ol>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><ul>
<li>global：布尔值，表示是否设置了g标志。</li>
<li>ignoreCase：布尔值，表示是否设置了i标志。</li>
<li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li>
<li>multiline：布尔值，表示是否设置了m标志。</li>
<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。  </li>
</ul>
<p>ES6新增属性</p>
<ul>
<li>sticky:布尔值，表示是否设置了y标志。</li>
<li>flags: 字符串，表示正则表达式的标志</li>
</ul>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ol>
<li>RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关</li>
<li>正则表达式的valueOf()方法返回正则表达式本身。</li>
</ol>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var text = &quot;mom and dad and baby&quot;;</div><div class="line">var pattern = /mom( and dad( and baby)?)?/gi;</div><div class="line">var matches = pattern.exec(text);</div><div class="line">alert(matches.index); // 0</div><div class="line">alert(matches.input); // &quot;mom and dad and baby&quot;</div><div class="line">alert(matches[0]); // &quot;mom and dad and baby&quot;</div><div class="line">alert(matches[1]); // &quot; and dad and baby&quot;</div><div class="line">alert(matches[2]); // &quot; and baby&quot;</div></pre></td></tr></table></figure>
<h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><p>接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回 false</p>
<h2 id="构造函数属性"><a href="#构造函数属性" class="headerlink" title="构造函数属性"></a>构造函数属性</h2><table>
<thead>
<tr>
<th>长属性名</th>
<th>短属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>$_</td>
<td>最近一次要匹配的字符串。Opera未实现此属性</td>
</tr>
<tr>
<td>lastMatch</td>
<td>$&amp;</td>
<td>最近一次的匹配项。Opera未实现此属性</td>
</tr>
<tr>
<td>lastParen</td>
<td>$+</td>
<td>最近一次匹配的捕获组。Opera未实现此属性</td>
</tr>
<tr>
<td>leftContext</td>
<td>$`</td>
<td>input字符串中lastMatch之前的文本</td>
</tr>
<tr>
<td>multiline</td>
<td>$*</td>
<td>布尔值,表示是否所有表达式都使用多行模式。IE和Opera未实现此属性</td>
</tr>
<tr>
<td>rightContext</td>
<td>$’</td>
<td>Input字符串中lastMatch之后的文本</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var text = &quot;this has been a short summer&quot;;</div><div class="line">var pattern = /(.)hort/g;</div><div class="line"></div><div class="line">if (pattern.test(text))&#123;</div><div class="line">  alert(RegExp.input); // this has been a short summer</div><div class="line">  alert(RegExp.leftContext); // this has been a</div><div class="line">  alert(RegExp.rightContext); // summer</div><div class="line">  alert(RegExp.lastMatch); // short</div><div class="line">  alert(RegExp.lastParen); // s</div><div class="line">  alert(RegExp.multiline); // false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>RegExp构造函数的各个属性返回了下列值：</p>
<ul>
<li>input属性返回了原始字符串；</li>
<li>leftContext属性返回了单词short之前的字符串，而rightContext属性则返回了short之后的字符串；</li>
<li>lastMatch属性返回最近一次与整个正则表达式匹配的字符串，即short；</li>
<li>lastParen 属性返回最近一次匹配的捕获组,即例子中的s</li>
</ul>
</li>
<li><p>RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。</p>
</li>
</ol>
<h1 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h1><p><strong>函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</strong></p>
<h2 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h2><ol>
<li>function函数直接声明</li>
<li>函数表达式</li>
<li>new Function构造函数声明</li>
</ol>
<h2 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h2><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>arguments是一个类数组对象，包含着传入函数中的所有参数。<br>虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this引用的是函数据以执行的环境对象</p>
<h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><p>这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。</p>
<h2 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h2><h3 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h3><p>length 属性表示函数希望接收的命名参数（形参）的个数</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>prototype属性是不可枚举的，因此使用for-in无法发现。</p>
<h2 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h2><h3 id="apply-和-call-bind"><a href="#apply-和-call-bind" class="headerlink" title="apply() 和 call(), bind()"></a>apply() 和 call(), bind()</h3><ol>
<li><p>在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个数数组。其中，第二个参数可以是 Array 的实例，也可以是arguments对象</p>
</li>
<li><p>call() 方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时,传递给函数的参数必须逐个列举出来</p>
</li>
<li><p>它们真正强大的地方是能够扩充函数赖以运行的作用域。使用call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系</p>
</li>
<li><p>bind方法会创建一个函数的实例，其 this 值会被绑定到传给bind()函数的值</p>
</li>
</ol>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; method = <span class="string">'GET'</span> &#125; = &#123;&#125;</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(method);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置双重默认值。上面代码中，调用函数fetch时，如果不含第二个参数，则默认值为一个空对象；如果包含第二个参数，则它的method属性默认值为GET。</p>
<ol>
<li>定义了默认值的参数，必须是函数的尾部参数，其后不能再有其他无默认值的参数。</li>
<li>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</li>
<li>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。</li>
<li>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</li>
<li><p>参数默认值所处的作用域，不是全局作用域，而是函数作用域。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = x</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(y);</div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>) <span class="comment">// 2</span></div></pre></td></tr></table></figure>
</li>
<li><p>参数默认值可以与解构赋值，联合起来使用。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(&#123;&#125;) <span class="comment">// undefined, 5</span></div><div class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1, 5</span></div><div class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1, 2</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。（和Java的变长参数类似）</p>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于函数调用。</p>
<ol>
<li>将一个数组拷贝进另一个数组的便捷方法。</li>
<li>扩展运算符也可以与解构赋值结合起来，用于生成数组。</li>
<li>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</li>
<li>任何类似数组的对象，都可以用扩展运算符转为真正的数组。</li>
<li>扩展运算符内部调用的是数据结构的Iterable接口，因此只要具有Iterable接口的对象，都可以使用扩展运算符，比如Map结构。</li>
</ol>
<h1 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h1><p>为了便于操作基本类型值，ECMAScript提供了3个特殊的引用类型：Boolean、Number和String。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">1</span> .toString(); <span class="comment">//注意空格，否则会被当浮点数解析，然后抛错，还可以写为(1).toString()  1..toString()</span></div></pre></td></tr></table></figure>
<p>上例中实际执行了三步：1. 创建Number类型的一个实例 2. 在实例上调用指定方法 3. 销毁这个实例</p>
<p>==引用类型与基本包装类型的主要区别就是对象的生存期。== 自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法</p>
<p>Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);</div><div class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><p>基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。</p>
<h2 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h2><ol>
<li>toFixed()方法会按照指定的小数位返回数值的字符串表示。J如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入</li>
<li>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</li>
<li>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。Number.isInteger(25.0) // true</li>
<li>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。Number.isInteger(25.0) // true</li>
</ol>
<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><h3 id="length-2"><a href="#length-2" class="headerlink" title="length"></a>length</h3><p>String类型的每个实例都有一个length属性，表示字符串中包含多个字符。应该注意的是，即使字符串中包含双字节字符（不是占一个字节的ASCII字符），每个字符也仍然算一个字符。</p>
<h3 id="charAt-和-charCodeAt"><a href="#charAt-和-charCodeAt" class="headerlink" title="charAt()和 charCodeAt()"></a>charAt()和 charCodeAt()</h3><p>这两个方法都接收一个参数，即基于 0 的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><h3 id="slice-、substr-和substring"><a href="#slice-、substr-和substring" class="headerlink" title="slice()、substr()和substring()"></a>slice()、substr()和substring()</h3><ul>
<li>substring只能接受正数</li>
<li>substr接受的第二个参数为返回的个数<h3 id="indexOf-和lastIndexOf"><a href="#indexOf-和lastIndexOf" class="headerlink" title="indexOf()和lastIndexOf()"></a>indexOf()和lastIndexOf()</h3><h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><h3 id="toLowerCase-、toLocaleLowerCase-、toUpperCase-和toLocaleUpperCase-。"><a href="#toLowerCase-、toLocaleLowerCase-、toUpperCase-和toLocaleUpperCase-。" class="headerlink" title="toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。"></a>toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。</h3><h3 id="match-search-replace"><a href="#match-search-replace" class="headerlink" title="match(), search(), replace()"></a>match(), search(), replace()</h3></li>
</ul>
<ol>
<li>match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象</li>
<li>search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。</li>
<li>replace()接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志</li>
<li>replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。</li>
</ol>
<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。</p>
<p><strong>ES6将match()、replace()、search()和split()这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</strong></p>
<h3 id="localeCompare"><a href="#localeCompare" class="headerlink" title="localeCompare()"></a>localeCompare()</h3><h3 id="fromCharCode"><a href="#fromCharCode" class="headerlink" title="fromCharCode()"></a>fromCharCode()</h3><h3 id="es6方法"><a href="#es6方法" class="headerlink" title="es6方法"></a>es6方法</h3><ol>
<li>String.fromCodePoint</li>
<li>String.codePointAt</li>
<li>ES7提供了字符串实例的at方法</li>
</ol>
<h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>返回一个新字符串，表示将原字符串重复n次。</p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><ol>
<li>用反引号（`）标识, 可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量，需要将变量名写在${}之中。</li>
<li>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。模板字符串之中还能调用函数</li>
<li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</li>
<li>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</li>
<li><p>标签模板</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123; <span class="comment">// ...  &#125;</span></div></pre></td></tr></table></figure>
<p> tag函数所有参数的实际值如下。<br> 第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]<br> 第二个参数: 15<br> 第三个参数：50  </p>
<ul>
<li>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</li>
<li>标签模板的另一个应用，就是多语言转换（国际化处理）。</li>
</ul>
</li>
</ol>
<h3 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h3><ol>
<li>String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</li>
<li>String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</li>
</ol>
<h1 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h1><h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><p>所有在全局作用域中定义的属性和函数，都是Global对象的属性。诸如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat() ,实际上全都是 Global 对象的方法。</p>
<ol>
<li>URI 编码方法</li>
<li>eval()方法</li>
<li>Global 对象的属性<br> 特殊的值undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，像Object和Function，也都是Global对象的属性。下表列出了Global对象的所有属性。</li>
</ol>
<h2 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h2><h3 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h3><h3 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min() 和 max() 方法"></a>min() 和 max() 方法</h3><h3 id="Math-ceil-Math-floor-Math-round"><a href="#Math-ceil-Math-floor-Math-round" class="headerlink" title="Math.ceil(), Math.floor(), Math.round()"></a>Math.ceil(), Math.floor(), Math.round()</h3><ol>
<li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；</li>
<li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</li>
<li>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</li>
</ol>
<h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><h1 id="键集合类型"><a href="#键集合类型" class="headerlink" title="键集合类型"></a>键集合类型</h1><h2 id="Map-类型"><a href="#Map-类型" class="headerlink" title="Map 类型"></a>Map 类型</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [<span class="string">"name"</span>, <span class="string">"张三"</span>], [<span class="string">"title"</span>, <span class="string">"Author"</span>]]);</div><div class="line"></div><div class="line">map.size <span class="comment">// 2</span></div><div class="line">map.has(<span class="string">"name"</span>) <span class="comment">// true</span></div><div class="line">map.get(<span class="string">"name"</span>) <span class="comment">// "张三"</span></div><div class="line">map.has(<span class="string">"title"</span>) <span class="comment">// true</span></div><div class="line">map.get(<span class="string">"title"</span>) <span class="comment">// "Author"</span></div></pre></td></tr></table></figure>
<ol>
<li>只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</li>
<li>同样的值的两个实例，在Map结构中被视为两个键。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</div><div class="line">map.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="实例属性和方法"><a href="#实例属性和方法" class="headerlink" title="实例属性和方法"></a>实例属性和方法</h3><ul>
<li>size：返回成员总数。</li>
<li>set(key, value)：设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li>get(key)：读取key对应的键值，如果找不到key，返回undefined。</li>
<li>has(key)：返回一个布尔值，表示某个键是否在Map数据结构中。</li>
<li>delete(key)：删除某个键，返回true。如果删除失败，返回false。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
<p>set()方法返回的是Map本身，因此可以采用链式写法。</p>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><ul>
<li>keys()：返回键名的Iterable对象。</li>
<li>values()：返回键值的Iterable对象。</li>
<li>entries()：返回所有成员的Iterable对象。</li>
</ul>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><ol>
<li>Map转为数组<br>前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</li>
<li>数组转为Map<br>将数组转入Map构造函数，就可以转为Map。</li>
<li>Map转为对象<br>如果所有Map的键都是字符串，通过遍历，它可以转为对象。</li>
<li>对象转为Map<br>通过遍历Object.keys(obj)，调用map.set方法添加键值对</li>
<li>Map转为JSON<br>Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。JSON.stringify(strMapToObj(strMap));<br>另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。 JSON.stringify([…map]);</li>
<li>JSON转为Map<br>JSON转为Map，正常情况下，所有键名都是字符串。JSON.parse(jsonStr)先转为对象，再把对象转为Map<br>但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。new Map(JSON.parse(jsonStr));</li>
</ol>
<h2 id="WeakMap-类型"><a href="#WeakMap-类型" class="headerlink" title="WeakMap 类型"></a>WeakMap 类型</h2><p>WeakMap结构与Map结构基本类似，唯一的区别是<strong>它只接受对象作为键名（null除外），不接受原始类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</strong></p>
<p>WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p>
<p>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>
<p>WeakMap的另一个用处是部署私有属性。例如: Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
<h2 id="Set-类型"><a href="#Set-类型" class="headerlink" title="Set 类型"></a>Set 类型</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set函数可以接受一个数组作为参数，用来初始化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]);</div><div class="line">items.size <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<h3 id="实例的属性和方法"><a href="#实例的属性和方法" class="headerlink" title="实例的属性和方法"></a>实例的属性和方法</h3><ol>
<li><p>Set结构的实例有以下属性。</p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
</ul>
</li>
<li><p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li>add(value)：添加某个值，返回Set结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
</li>
<li><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li>keys()：返回一个键名的Iterable对象</li>
<li>values()：返回一个键值的Iterable对象</li>
<li>entries()：返回一个键值对的Iterable对象</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
</li>
</ol>
<h2 id="WeakSet-类型"><a href="#WeakSet-类型" class="headerlink" title="WeakSet 类型"></a>WeakSet 类型</h2><p>首先，WeakSet的成员只能是对象，而不能是其他类型的值。</p>
<p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>
<ol>
<li>WeakSet结构有以下三个方法。<ul>
<li>WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。</li>
<li>WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。</li>
<li>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。</li>
<li>WeakSet没有size属性，没有办法遍历它的成员。</li>
</ul>
</li>
</ol>
<p>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h1 id="反射类型"><a href="#反射类型" class="headerlink" title="反射类型"></a>反射类型</h1><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。（与Java中动态代理类似）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</div></pre></td></tr></table></figure>
<p>Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<ol>
<li>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。<br>一个技巧是将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> object = &#123; <span class="attr">proxy</span>: <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler) &#125;</div></pre></td></tr></table></figure>
<ol>
<li>Proxy实例也可以作为其他对象的原型对象。</li>
<li><p>Proxy支持的拦截操作一览。</p>
<ul>
<li>get(target, propKey, receiver)<br>拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]，返回类型不限。最后一个参数receiver可选，当target对象设置了propKey属性的get函数时，receiver对象会绑定get函数的this对象。</li>
<li>set(target, propKey, value, receiver)<br>拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
<li>has(target, propKey)<br>拦截propKey in proxy的操作，返回一个布尔值。</li>
<li>deleteProperty(target, propKey)<br>拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
<li>enumerate(target)<br>拦截for (var x in proxy)，返回一个Iterable对象。</li>
<li>hasOwn(target, propKey)<br>拦截proxy.hasOwnProperty(‘foo’)，返回一个布尔值。</li>
<li>ownKeys(target)<br>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。</li>
<li>getOwnPropertyDescriptor(target, propKey)<br>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc)<br>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)<br>拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)<br>拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>isExtensible(target)<br>拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li><p>setPrototypeOf(target, proto)<br>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</p>
<p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
</li>
<li>apply(target, object, args)<br>拦截Proxy实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>construct(target, args, proxy)<br>拦截Proxy实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ul>
</li>
</ol>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。</p>
<ul>
<li>将Object对象的一些明显属于语言层面的方法，放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。</li>
<li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li>
<li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</li>
</ul>
<p>Reflect对象的方法清单如下。</p>
<ul>
<li>Reflect.getOwnPropertyDescriptor(target,name)</li>
<li>Reflect.defineProperty(target,name,desc)</li>
<li>Reflect.getOwnPropertyNames(target)</li>
<li>Reflect.getPrototypeOf(target) 读取对象的<strong>proto</strong>属性，等同于Object.getPrototypeOf(obj)。</li>
<li>Reflect.setPrototypeOf(obj, newProto) 设置对象的<strong>proto</strong>属性，注意，Object对象没有对应这个方法的方法。</li>
<li>Reflect.deleteProperty(target,name) 等同于delete obj[name]。</li>
<li>Reflect.enumerate(target)</li>
<li>Reflect.freeze(target)</li>
<li>Reflect.seal(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.isFrozen(target)</li>
<li>Reflect.isSealed(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.has(target,name) 等同于name in obj。</li>
<li>Reflect.hasOwn(target,name)</li>
<li>Reflect.keys(target)</li>
<li>Reflect.get(target,name,receiver) 查找并返回target对象的name属性，如果没有该属性，则返回undefined。如果name属性部署了读取函数，则读取函数的this绑定receiver。</li>
<li>Reflect.set(target,name,value,receiver) 设置target对象的name属性等于value。如果name属性设置了赋值函数，则赋值函数的this绑定receiver。</li>
<li>Reflect.apply(target,thisArg,args) 等同于Function.prototype.apply.call(fun,thisArg,args)。一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。</li>
<li>Reflect.construct(target,args) 等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。</li>
</ul>
<p>注意，Reflect.set()、Reflect.defineProperty()、Reflect.freeze()、Reflect.seal()和Reflect.preventExtensions()返回一个布尔值，表示操作是否成功。它们对应的Object方法，失败时都会抛出错误。</p>
<h1 id="控制抽象类型"><a href="#控制抽象类型" class="headerlink" title="控制抽象类型"></a>控制抽象类型</h1><h2 id="Iteration-接口"><a href="#Iteration-接口" class="headerlink" title="Iteration 接口"></a>Iteration 接口</h2><p>ECMAScript 中一个接口是一组键值对属性，这些属性的键所对应的值符合特定的规范。如果一个对象提供了一个接口描述的所有属性，那么这个对象就实现了这个接口。一个接口并不是被单独的一个对象表示。可能有很多单独的对象实现符合某个接口，一个单独的对象可能实现多个接口。</p>
<p>通过统一的接口机制，可以使用for-of来遍历不同的数据结构。</p>
<h2 id="Iterable-接口"><a href="#Iterable-接口" class="headerlink" title="Iterable 接口"></a>Iterable 接口</h2><p>这个接口只有一个属性，即Symbol.iterator，它是一个函数，这个函数返回一个实现了Iterator接口的对象。</p>
<p>在ES6中，有些数据结构原生实现了这个接口（比如数组），不用任何处理，就可以被for…of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有。凡是部署了Symbol.iterator属性的数据结构，就称为实现了Iterable接口。调用这个接口，就会返回一个Iterator对象。</p>
<h2 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h2><p>这个接口有一个属性，next，这个属性是一个函数，它返回一个实现了IteratorResult接口的对象。如果上一步调用next返回的对象的done属性已经是true了，那么之后调用next函数也要返回一个done属性为true的IteratorResult对象。这个要求并不是强制的。</p>
<p>该接口还有两个可选的属性return 和 throw。这两个属性都是方法，并且方法返回值都是IteratorResult对象。</p>
<p>done为true，即遍历结束时，如果存在return方法，value的值会被设置为return方法。这并不是强制要求的。</p>
<h2 id="IteratorResult-接口"><a href="#IteratorResult-接口" class="headerlink" title="IteratorResult 接口"></a>IteratorResult 接口</h2><p>包含value和done两个属性的对象。其中，value属性是当前成员的值，如果iterator提供了return方法的花，done为true时，这个value应该是iterator的return属性的值即return函数，否则done为true时value就是undefined，这种情况下可以没有value属性；done属性是一个布尔值，表示遍历是否结束，如果不存在done，就认为done属性为false。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.value = value;</div><div class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Obj.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> iterator = &#123;</div><div class="line">    next: next,</div><div class="line">    <span class="keyword">return</span>: returnFn</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (current)&#123;</div><div class="line">      <span class="keyword">var</span> value = current.value;</div><div class="line">      <span class="keyword">var</span> done = current === <span class="literal">null</span>;</div><div class="line">      current = current.next;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        done: done,</div><div class="line">        value: value</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        value: iterator.return,</div><div class="line">        done: <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">returnFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      done: <span class="literal">true</span>,</div><div class="line">      value: <span class="string">'return'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> iterator;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Obj(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> Obj(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> Obj(<span class="number">3</span>);</div><div class="line"></div><div class="line">one.next = two;</div><div class="line">two.next = three;</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = one[<span class="built_in">Symbol</span>.iterator]();</div><div class="line">it.next();</div><div class="line">it.next();</div><div class="line">it.next();</div><div class="line">it.next().value();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> one)&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码首先在构造函数的原型链上部署Symbol.iterator方法，调用该方法会返回遍Iterator对象，调用该对象的next方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p>
<h2 id="默认实现Iterable接口的数据结构"><a href="#默认实现Iterable接口的数据结构" class="headerlink" title="默认实现Iterable接口的数据结构"></a>默认实现Iterable接口的数据结构</h2><p>Iterable接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环（详见下文）。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterable接口。</p>
<p>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。也就是说，调用Symbol.iterator方法，就会得到当前数据结构的默认Iterator对象。Symbol.iterator本身是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内。</p>
<p>在ES6中，有三类数据结构原生具备Iterable接口：数组、某些类似数组的对象、Set和Map结构。</p>
<p>一个对象如果要有可被for…of循环调用的Iterable接口，就必须有Symbol.iterator方法（原型链上的对象具有该方法也可）。</p>
<h2 id="Iterable接口默认的应用场合"><a href="#Iterable接口默认的应用场合" class="headerlink" title="Iterable接口默认的应用场合"></a>Iterable接口默认的应用场合</h2><ol>
<li>for…of循环</li>
<li>解构赋值</li>
<li>扩展运算符</li>
<li>yield*</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ol>
<h2 id="原生具备Iterable接口的数据结构"><a href="#原生具备Iterable接口的数据结构" class="headerlink" title="原生具备Iterable接口的数据结构"></a>原生具备Iterable接口的数据结构</h2><ol>
<li>ES6对数组提供entries()、keys()和values()三个方法，就是返回三个Iterable对象。4</li>
<li>字符串是一个类似数组的对象，也原生具有Iterable接口。</li>
</ol>
<h2 id="Iterable接口与Generator函数"><a href="#Iterable接口与Generator函数" class="headerlink" title="Iterable接口与Generator函数"></a>Iterable接口与Generator函数</h2><p>Symbol.iterator方法的最简单实现，还是使用后面要介绍的Generator函数。</p>
<h1 id="Promise-类型"><a href="#Promise-类型" class="headerlink" title="Promise 类型"></a>Promise 类型</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ol>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。</p>
<h2 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// ... some code</span></div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p>
<p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。<br>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">comments</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Resolved: "</span>, comments);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Rejected: "</span>, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。</p>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="comment">// 处理前一个回调函数运行时发生的错误</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。</p>
<p>需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。</p>
<p>catch方法之中，还能再抛出错误。</p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1,p2,p3]);</div></pre></td></tr></table></figure>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<p>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([p1,p2,p3]);</div></pre></td></tr></table></figure>
<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><ol>
<li>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</div></pre></td></tr></table></figure>
<ol>
<li>如果Promise.resolve方法的参数，不是具有then方法的对象（又称thenable对象），则返回一个新的Promise对象，且它的状态为Resolved。</li>
<li>Promise.resolve方法允许调用时不带参数。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</li>
<li>如果Promise.resolve方法的参数是一个Promise实例，则会被原封不动地返回。</li>
</ol>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p>
<h2 id="Generator函数与Promise的结合"><a href="#Generator函数与Promise的结合" class="headerlink" title="Generator函数与Promise的结合"></a>Generator函数与Promise的结合</h2><p>使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">    resolve(<span class="string">'foo'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">var</span> foo = <span class="keyword">yield</span> getFoo();</div><div class="line">    <span class="built_in">console</span>.log(foo);</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generator</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> it = generator();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> go(it.next(value));</div><div class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> go(it.throw(value));</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  go(it.next());</div><div class="line">&#125;</div><div class="line"></div><div class="line">run(g);</div></pre></td></tr></table></figure>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>async函数与Promise、Generator函数一样，是用来取代回调函数、解决异步操作的一种方法。它本质上是Generator函数的语法糖。async函数并不属于ES6，而是被列入了ES7，</p>

    
  </div>
</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">觉得我的文章有帮助，可以支持一下</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/09/09/CSS/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/09/10/ECMAScript-面相对象程序设计/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archive/"
              rel="noopener noreferrer"
              target="_self"
              >
              归档
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://yoursite.com/2017/09/10/ECMAScript-引用类型/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
